
/*
   Copyright (C) 2014, MIMO Tech Co., Ltd.

   Revision history
    1.0.0   Initialize.

*/

#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <setjmp.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <limits.h>
#include <sys/ipc.h>
#include <sys/resource.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <netdb.h>
#include <ctype.h>
#include <grp.h>
#include <pwd.h>
#include <dlfcn.h>

#include "common.h"
#include "linkedlist.h"
#include "hash.h"
#include "hmap.h"
#include "radix.h"

#include "sdfconfig.h"
#include "sdflib.h"
#include "sdflog.h"
#include "sdfxml.h"

#include "base_epoll.h"
#include "rauthen.h"
//#include "http_clnt.h"
#include "http.h"
#include "ldap.h"

#include "watch.h"
#include "D02.h"
#include "buffer.h"
#include "api_common.h"
//#include "json.h"

//#define USE_RPC
//#define SYNC_DMCD

//!--Use GRPC
#ifdef GRPC
 #include "http2.h"
 #include "grpc.h"
#endif

//!--Use RPC
#ifdef USE_RPC
 #include "client.h"
#endif

//!--Use XTHREAD_STAT
#ifndef XTHREAD_STAT
#define XTHREAD_STAT	1
#endif

//!--Use STAT_RESET
#ifndef STAT_RESET
#define STAT_RESET	1
#endif

#ifdef XTHREAD_STAT
#include "xthread.h"
#endif

#define MY_NAME							"D02"
#define MY_VERSION						"1.0.0"

#define MAX_LDAP_HOST                   128
#ifdef SYNC_DMCD
#define MAX_HTTP_HOST                   128
#endif
#define MAX_HASH_KEY_SIZE               128
#define MAX_HASH_BUCKET_SIZE			256
#define MAX_URI_PATH_SIZE               2048
#define MAX_SEARCH_ATTRS                129   // (128+1) Reserved last slot for 0x0
#define MAX_FILTER_SIZE                 512
#define MAX_ATTRS_LENGTH                129   // (128+1) Reserved last slot for 0x0
#define MAX_SCOPE_SIZE                  128
#define MAX_KEY_UID_NAME                512
#define MAX_SIZE_BASE_DN                1024

#define MY_ERR_BUFFER_SIZE				256
#define MY_AF_LOG_LIMIT					4096
#define MY_DATA_BUFFER					(64*1024)

/* Biz define */
#define AMF_MAX_PACK_NO                 4095
#define MIN_TIME_STAMP                  38771       //Thu, 1 Jan 1970 17:46:11 +07:00;
#define MAX_TIME_STAMP                  4294967295  //Sun, 7 Feb 2106 13:28:15 +07:00;
#define TO_BOOL(_v) 					(((_v))? 1 : 0)
#define STRCASEEQ(_s1, _s2)				(strcasecmp(_s1 ,_s2)==0)
#define STREQ(_s1, _s2)					(strcmp(_s1 ,_s2)==0)
#define ADJUST_SIZE(_l, _s)			\
{									\
	register int _r_ = (_l) % (_s);	\
	if (_r_ > 0)					\
		(_l) += (_s) - _r_;			\
}
#define STRCPY(_t, _s)    				\
{                 						\
	int _l_ = (int) strlen((_s));       \
	if (_l_ >= (int) sizeof((_t)))      \
		_l_ = sizeof((_t)) - 1;			\
	memcpy ((_t), (_s), _l_);   		\
	((char *)(_t))[_l_] = '\0';    		\
}

#define IS_PARAM_VALID(_aname)  (STRCASEEQ(t_alist->name, _aname) && (t_alist->vals->len!= 0))


#define WATCH_WITH_START( _start, _msg ){                                           \
    gettimeofday(&stoptime, 0);                                                     \
    timeval_subtract(&overall_time, &stoptime, &_start);                            \
    process_time = overall_time.tv_sec*1000000+overall_time.tv_usec;                \
    SDFLOG_INFO((B, "%s : %lu us", _msg, process_time))                             \
}

#define WATCH( _msg ){                                                              \
    gettimeofday(&stoptime, 0);                                                     \
    timeval_subtract(&overall_time, &stoptime, &starttime);                         \
    process_time = overall_time.tv_sec*1000000+overall_time.tv_usec;                \
    SDFLOG_INFO((B, "%s : %lu us", _msg, process_time))                             \
}

#define SET_WATCH( _start) gettimeofday(&_start, 0);


#define LDAP_AMF_GROUP                  "AMF"
#define LDAP_LIST_HANDLE                d02global.ldap_list[d02global.ldap_host_index]
#define LDAP_EXT_HANDLE                 d02global.ldap_list[d02global.ldap_ext_index]
#define ROOT_DB                         "ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
char build_version[] = "@(#"MY_NAME") Version -> "MY_VERSION;


enum D01_AFSTATE
{
    AFSTATE_IDLE = 0,
    AFSTATE_POST,
    AFSTATE_GET_QUERY,
    AFSTATE_PUT,
    AFSTATE_MODDN,
    AFSTATE_DELETE,
    AFSTATE_METHOD,
    AFSTATE_EXTENDED,
    AFSTATE_SUBREL,
    AFSTATE_TRANSACTION,
    
    AFSTATE_QUERY_SERVICE_REGISTRY,
    AFSTATE_WATCH_SERVICE_REGISTRY,
    
    AFSTATE_LAST
};

enum METHOD_STATE{
    METHOD_STATE_IDLE = 0,
    METHOD_STATE_VER_UID,
    METHOD_STATE_MODRDN_MSISDN_ALIAS,
    METHOD_STATE_MODRDN_MSISDN_GUP,
    METHOD_STATE_MODRDN_MSISDN_AMF,
    METHOD_STATE_LAST
    };

enum SUBREL_STATE{
    SUBREL_STATE_IDLE = 0,
    SUBREL_SEARCH_ROOT,
    SUBREL_SEARCH_BACKEND,
    SUBREL_PROCESS_ROOT,
    SUBREL_PROCESS_BACKEND,
    SUBREL_LAST
    };

enum METHODE_NAME{
    METHOD_INSERTSUBSCRIBER = 0,
    METHOD_CHANGENUMBER,
    METHOD_MODIFYIDENTITY,
    METHOD_CREATEPACKAGE,
    METHOD_RESOLVE_ALIASE,
    METHOD_DELETEPACKAGE,
    METHOD_INQUIRY_SESSION,
    METHOD_PULL_SESSION,
    METHOD_PUSH_SESSION,
    METHOD_MODIFY_SESSION,
    METHOD_INQUIRY_SUBSCRIBER,
    METHOD_INQUIRY_PCF_VAS,
    METHOD_RESOLVE_ALIASE_SUBREL,
    METHOD_SUBREL_ADD,
    METHOD_SUBREL_MODDN,
    METHOD_SUBREL_DELETE,
    METHOD_START_TRANSACTION,
    METHOD_END_TRANSACTION,
    METHODE_ALL
    };

enum CREATE_PACKAGE_STATE{
    CRT_PKG_IDLE = 0,                           // s0
    CRT_PKG_QUERY_RUNNING_NUMBER,               // s1
    CRT_PKG_QUERY_PRODUCT_NUMBER,               // s2
    CRT_PKG_QUERY_PRODUCT_OFFERING_VER,         // s3
    CRT_PKG_QUERY_LASTEST_OFFERING_VER,
    CRT_PKG_ADD_AMF_COUNTER_PACK,               // s4
    CRT_PKG_ADD_AMF_COUNTER_ENTRY,              // s5
    CRT_PKG_MOD_GUPIMPI,                        // s6
    CRT_PKG_MOD_GUPIMPU,                        // s7
    CRT_PKG_MOD_RUNNING_NUMBER,                 // s8
    CRT_PKG_EXT_CALL_MANANGE_COUTER,            // s9
    CRT_PKG_CONSTRUCT_HTTP_RESONSE,             // s10
    CRT_PKG_QUERY_ACCOUT_ID,
    CRT_PKG_QUERY_PUBLIC_ID,
    CRT_PKG_QUERY_PRIVATE_ID,
    CRT_PKG_MOD_USR_INPUT,
    CRT_PKG_ROLLBACK,
    CRT_PKG_RESOLVE_ALIASE
    };

enum DELETE_PACKAGE_STATE{
    DEL_PKG_IDLE = 0,                           // s0
    //DEL_PKG_CHK_UID_EXIST,                      // s1
    DEL_PKG_RESOLVE_ALIAS,                      // s1
    DEL_PKG_CHK_AMF_PRODUCT_NO_EXIST,           // s2
    DEL_PKG_QUERY_PRODUCT_NO_LIST,              // s3
    DEL_PKG_REMOVE_PRODUCT_NO_LIST,             // s4
    DEL_PKG_REMOVE_AMF_PRODUCT_NO               // s5
    };    

enum MODIFY_IDENTIY_STATE{
    MODIFY_IDENTIY_IDLE = 0,
    MODIFY_IDENTIY_CCK_UID,
    MODIFY_IDENTIY_CCK_NEW_UID,
    MODIFY_IDENTIY_CCK_ALIAS,
    MODIFY_PROCESS
    };

enum AFSTATE_SUBSCRIBER{
    AFSTATE_SUBSCRIBER_IDLE = 0,
    AFSTATE_SUBSCRIBER_VERIFY_ALIAS,
    AFSTATE_SUBSCRIBER_VA_SEARCH_MSISDN,
    AFSTATE_SUBSCRIBER_VA_VERIFY_MSISDN,
    AFSTATE_SUBSCRIBER_VA_SEARCH_IMSI,
    AFSTATE_SUBSCRIBER_VA_VERIFY_IMSI,
    AFSTATE_SUBSCRIBER_VA_SEARCH_IMPU,
    AFSTATE_SUBSCRIBER_VA_VERIFY_IMPU,
    AFSTATE_SUBSCRIBER_VA_SEARCH_IMPI,
    AFSTATE_SUBSCRIBER_VA_VERIFY_IMPI,
    AFSTATE_SUBSCRIBER_VA_SEARCH_EMAIL,
    AFSTATE_SUBSCRIBER_VA_VERIFY_EMAIL,
    AFSTATE_SUBSCRIBER_VA_VERIFY_PARTNERID,
    AFSTATE_SUBSCRIBER_VA_SEARCH_PARTNERID,
    AFSTATE_SUBSCRIBER_VA_VERIFY_BA,
    AFSTATE_SUBSCRIBER_VA_SEARCH_BA,
    AFSTATE_SUBSCRIBER_VA_VERIFY_DEVICE,
    AFSTATE_SUBSCRIBER_VA_SEARCH_DEVICE,
    AFSTATE_SUBSCRIBER_VA_VERIFY_CA,
    AFSTATE_SUBSCRIBER_VA_SEARCH_CA,
    AFSTATE_SUBSCRIBER_VERIFY,
    AFSTATE_SUBSCRIBER_PROCESS,
    AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE,
#ifdef GRPC
AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE_TO_D20,
#endif
    AFSTATE_SUBSCRIBER_ADD_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_SERVICE,
    AFSTATE_SUBSCRIBER_ADD_PROFILE,
    AFSTATE_SUBSCRIBER_ADD_SUBPROFILE,
    AFSTATE_SUBSCRIBER_ADD_CNTDB,
    AFSTATE_SUBSCRIBER_ADD_AIS,
    AFSTATE_SUBSCRIBER_ADD_SUBSCRIBER,
    AFSTATE_SUBSCRIBER_ADD_GROUPID,
    AFSTATE_SUBSCRIBER_ADD_ASPID,
    AFSTATE_SUBSCRIBER_ADD_SECURITY,
    AFSTATE_SUBSCRIBER_ADD_DOCSIS,
    AFSTATE_SUBSCRIBER_ADD_PRIVATEID,

    AFSTATE_SUBSCRIBER_ADD_MSISDN,
    AFSTATE_SUBSCRIBER_ADD_MSISDN_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_MSISDN_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMSI,
    AFSTATE_SUBSCRIBER_ADD_IMSI_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMSI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMPU,
    AFSTATE_SUBSCRIBER_ADD_IMPU_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMPU_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMPI,
    AFSTATE_SUBSCRIBER_ADD_IMPI_MULIT_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_IMPI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_EMAIL,
    AFSTATE_SUBSCRIBER_ADD_EMAIL_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_EMAIL_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_PARTNERID,
    AFSTATE_SUBSCRIBER_ADD_PARTNERID_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_PARTNERID_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_BAID,
    AFSTATE_SUBSCRIBER_ADD_BAID_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_BAID_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_DEVICEID,
    AFSTATE_SUBSCRIBER_ADD_DEVICEID_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_DEVICEID_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_CAID,
    AFSTATE_SUBSCRIBER_ADD_CAID_MULTI_ALIAS,
    AFSTATE_SUBSCRIBER_ADD_CAID_ALIAS,

    AFSTATE_SUBSCRIBER_ADD_PTS,
    AFSTATE_SUBSCRIBER_ADD_GUP,
    AFSTATE_SUBSCRIBER_ADD_DS3,
    AFSTATE_SUBSCRIBER_ADD_AAA,
    AFSTATE_SUBSCRIBER_ADD_STB,
    AFSTATE_SUBSCRIBER_ADD_SLF,
    AFSTATE_SUBSCRIBER_ADD_PROFILEID,
    AFSTATE_SUBSCRIBER_ADD_AEMF,
    AFSTATE_SUBSCRIBER_ADD_AMF,
    AFSTATE_SUBSCRIBER_ADD_AMFACCOUNT,
    AFSTATE_SUBSCRIBER_WAIT_CLOSE,
    AFSTATE_SUBSCRIBER_LENGTH
};

enum PUSH_SESSION_STATE{
    PUSH_SESSION_IDLE = 0,
    PUSH_SESSION_RESOLVE_ALIAS,
    PUSH_SESSION_SEARCH_CACHEDATA,
    PUSH_SESSION_ADD_SLF,
    PUSH_SESSION_ADD_SLF_SUBDATA,
    PUSH_SESSION_ADD_SLF_MSISDN,
    PUSH_SESSION_ADD_SLF_APPID,
    PUSH_SESSION_ADD_SLF_CACHETYPE,
    PUSH_SESSION_MODIFY_SESSION,
    PUSH_SESSION_END
    };

enum INDEX_NAME{
    CNTDB = 0,
    AIS,
    SUBSCRIBER,
    SUBSCRIBE,
    UID,
    NEWUID,
    IDENTITY_NAME,
    IDENTITY_VALUE,
    IDENTITY_TYPE,
    METHOD_VERSION,
    PRODUCT_OFFER,

    // Alias Group
    MSISDN,
    IMSI,
    IMPU,
    IMPI,
    EMAIL,
    PARTNERID,
    BAID,
    DEVICE,
    CAID,

    SERVICE,
    PROFILE,
    DS3,
    AAA,
    STB,
    SLF,
    GUP,
    AEMF,
    AMF,
    PTS,
    SUBSCRIPTIONSTATE,
    MSCADDRESS,
    VLRNUMBER,
    SERVICEPROFILEID,

    GUPDATASERVLIFESTYLE,
    GUPAUTHENLEVEL,
    GUPREGISTRATIONLEVEL,
    GUPLISTOFOPENID,

    PRIVATEIDLIST,
    PUBLICIDLIST,
    IMPLICITREGSETID,
    REGPRIVATEIDLIST,
    REGISTRATIONSTATUS,
    ALIAID,
    PFPASSWORD,
    DS3PIN,
    SECRETQUESTION,
    SECRETANSWER,
    ACCOUNTID,
    PRODUCTNOLIST,
    PRODUCTOWNERLIST,
    MMTELPROFILEID,
    ADDIFEXIST,
    OLD_NUMBER,
    NEW_NUMBER,

    DS3_POLITE_DEGREE,
    DS3_BRANDID,
    DS3_SPNAME,
    DS3_REGISTRATION_STATUS,
    LANGUAGE,
    IVR_LANGUAGE,
    SMS_LANGUAGE,
    USSD_LANGUAGE,
    EMAIL_LANGUAGE,
    PREFERENCES,
    DS3_CUSTOMER_CATEGORY,
    DS3_CUSTOMER_SUBCATEGORY,
    DS3_CUSTOMER_SEGMENT,
    ADDRESS,
    BIRTHDAY,
    PRIORITY,
    VERSION,
    SENDSMS,
    LOCKED,
    ACTIVATION_DATE,
    COUNTER_STATE,
    EXPIRY_TIME,
    EXPIRY_GRACE_PERIOD,
    PREEXPIRY_THR,
    POSTEXPIRY_THR,
    EXPIRY_NOTIFY_TIME,
    PERSIST_CYCLE,
    LIFECYCLE_UNIT,
    LIFECYCLE_NO,
    RECURRING_LIFECYCLE,
    DS3_TIME_RESOLUTION,
    COUNTER_ROLLOVER,
    REFILL_STOP_TIME,
    REFILL_STOP_EXT,
    REFILL_NOTIFY_TIME,
    AMF_COST_CODE,
    AMF_DYNAMIC_BIZ_INFO,
    AMF_ORDER_DATE,
    AMF_RECURRING_STATE,
    AMF_PACKAGE_REFKEY,
    AMF_ACCOUNT_ID,
    AMF_PRODUCT_NO,
    DS3_PACKAGE_DESC,
    DS3_OFFLINE_NOTIFY_POLICY_CONTROL,
    DS3_RECURRING_NOTIFY_POLICY_CONTROL,
    DS3_COST_CODE,
    SPONSOR_ID,
    OFFER_STATE,
    LAST_INDEX_NAME
};

enum ID_TYPE{
    ID_UID,
    ID_MSISDN,
    ID_IMSI,
    ID_IMPU,
    ID_IMPI,
    ID_EMAIL
    };

    
struct _buffer_t{
    struct _buffer_t *prev;
    struct _buffer_t *next;
    int size;
    int len;
    int cur;
    unsigned char data[1];
};
enum RAFT_STATE_ENUM{
    RAFT_STATE_LEADER = 0,
    RAFT_STATE_FOLLOWER,
    RAFT_STATE_UNKNOWN
    
};

enum LINK_STATUS_ENUM{
    LINK_STATUS_UP = 0,
    LINK_STATUS_DOWN,
    LINK_STATUS_UNKNOWN
};


enum D11_STATUS_ENUM{
    D11_STATUS_SYNC = 0,
    D11_STATUS_UNSYNC
};

enum RESTFUL_COMMAND_TYPE{
    RESTFUL_COMMAND_SEARCH = 0,
    RESTFUL_COMMAND_ADD,
    RESTFUL_COMMAND_MODIFY,
    RESTFUL_COMMAND_DELETE
};

enum D11_STATE_ENUM{
    D11_STATE_IDLE = 0,
    D11_STATE_QUERY_REQUEST,
    D11_STATE_WATCH_REQUEST,
    D11_STATE_WATCH_RESTORE
};

typedef enum _record_type{
    RECORD_GET = 0,
    RECORD_POST,
    RECORD_PUT,
    RECORD_DEL,
    RECORD_MCPRF,
    RECORD_MCPKG,
    RECORD_MMNM,
    RECORD_MMID,
    RECORD_MRESOLV,
    RECORD_UNKNOWN,

    RECORD_ALL
}RECORD_TYPE;

typedef struct thread_info_t{
    int id;
    pthread_t *pth;
}THREAD_INFO;

RING_BUFFER sdf_buffer;

typedef struct indexing{
        BER_ATTRLIST *alist;
        BER_ATTRLIST *index_list[MAX_SIZE_INDEXING];
}INDEXING;

struct _process_control_
{
   pid_t kill;
   pid_t pid;
   pid_t response;
   int active;
};

typedef struct _rahs_shm_
{
    struct _process_control_ main;
    struct _process_control_ fmon;
    int conf;
    int pause;
    int status;
#ifdef STAT_RESET
    int clearstats;
#endif
} RAHS_SHM;

typedef struct _d01_dbllist_
{
    struct _d01_dbllist_ *prev;
    struct _d01_dbllist_ *next;
    time_t time;
    int retry;
    struct _d01_msg_wrapper_ *node;
} DBLIST;

typedef struct crt_pkg_st{
    int product_old_numer;      // store previos amfProductRunningNo for rollback
    int product_number;         // store lastest amfProductNumber
    int runningNo_exist;        // used for check exist amfProductRunningNo
    int send_sms;               // enable to send sms flag
    int rollback_result_code;   // result code of rollback
    int require_mod_expiry;     // require modify expiry date flag
    int require_couter_manage;  // require amf call manage counter flag
    char version[16];           // Lastest Version of package
    char activation_time[16];   // stat time
    char expriry_time[16];      // expriry time
    char usr_expiry_time[20];   // backup user expiry time(yyyymmddHHMMSS+0700)
    char rollback_desc[1024];   // rollback description
    LDAP_OBJECT *counter_pack;  // store template for add new package
    LDAP_OBJECT *counter_entry; // store template for add counterIds
    LDAP_OBJECT *publicIds;     // store list of public under FBB
    LDAP_OBJECT *privateIds;    // store list of privateId under publicId
    LDAP_OBJECT *privateIds_bckp;   // store list of privateIds in order to rollback
    LDAP_OBJECT *publicIds_bckp;    // store list of publicIds in order to rollback
}CRT_PKG_ST;

#ifdef SYNC_DMCD
typedef struct _conn_property{
    struct _conn_property       *next;
    struct _conn_property       *prev;
    char                        host[1024];
    char                        host_port[2048];
    int                         port;
    int                         type;
    int                         status;
}CONN_PROPERTY;

typedef struct _cluster{
    char                        cluster_id[2048];
    int                         conn_d21_count;
    CONN_PROPERTY               conn_d21[128];
    CONN_PROPERTY               *list_conn_d21;
}CLUSTER;
#endif

// -------------------------- Transactio ID mapper -----------------
enum TRANSACTION_STATE
{
    TRANSACTION_STATE_INIT = 0,
    TRANSACTION_STATE_START_RECEIVED,
    TRANSACTION_STATE_RESOLVING,
    TRANSACTION_STATE_SENDING_START_BE,
    TRANSACTION_STATE_RESOLVED,
    TRANSACTION_STATE_COMMIT,
    TRANSACTION_STATE_ROLLBACK,
    TRANSACTION_STATE_END_RECEIVED,
    TRANSACTION_STATE_SENDING_END_BE
};

enum TRANSACTION_DESTINATION
{
    TRANSACTION_DESTINATION_NONE = 0,
    TRANSACTION_DESTINATION_DS3,
    TRANSACTION_DESTINATION_DS4
};

typedef struct _tim_dbllist_
{
    struct _tim_dbllist_ *prev;
    struct _tim_dbllist_ *next;
    time_t time;
    int retry;
    struct _transaction_id_mapper_ *node;
} TIMDBLIST;

typedef struct _transaction_id_mapper_
{
    /* hash */
    char hash_key[MAX_HASH_KEY_SIZE];
    int hash_key_len;
    struct _transaction_id_mapper_ *prev;
    struct _transaction_id_mapper_ *next;

    /* dbllist */
    unsigned int DSx_tid;
    unsigned short int l_sess_tid;
    char object[LDAP_MAX_OID_SIZE]; // input oid or dn
    TIMDBLIST tim_dbl;
    int dest;
    int state;
    time_t time;
    LDAP_CLNT *lc;
    DSSESSION *ref;
} TRANSACTIONIDMAPPER;


//------------------------------------------------------------------

typedef struct _d01_af_instance_
{
    int service;
    int state;
    int sub_state;
    int main_state;
    int is_orig_uid;
    int dsaID;
    int method;
    int tid;
    uint64_t gid;
    int recode_type;           /* Use for specific type of service */
    int result_code[LAST_INDEX_NAME];
    int migration_mode;        /* Use for switching database between ds3 and ds4. MIG_MODE, DS3_MODE, DS4_MODE */
    char key_uid_name[MAX_KEY_UID_NAME];
    char resolve_base_dn[MAX_SIZE_BASE_DN];
    char default_base_dn[MAX_SIZE_BASE_DN];
    char dn[MAX_SIZE_BASE_DN];
    char *result_data;
    char refer_id[128];        /* reference Id */
    char subsys[32];
    char identity_name[LDAP_MAX_ATTR_NAME_SIZE];
    char identity_value[LDAP_MAX_ATTR_VALUE_SIZE];
    char object_class[LDAP_MAX_ATTR_VALUE_SIZE];
#ifdef GRPC
    char group[128];
    char cluster[128];
    char cluster_d21[128];
    char cluster_d20[128];
    char command_type; //SEARCH|MODIFY|DELETE|ADD
    char oid[LDAP_MAX_OID_SIZE];
#endif
    BER_VALLIST *ber_vlist;     /* Reference to ber_value for multi aliase */
    CRT_PKG_ST *amf;            /* Store temporary date. */
    BER_ATTRLIST *alist;
    BER_ATTRLIST *index_list[MAX_SIZE_INDEXING];
    BER_ATTRLIST *res_alist;
    BER_ATTRLIST *index_res_alist[MAX_SIZE_INDEXING];
    TRANSACTIONIDMAPPER *tim;
    BER_ATTRLIST_OBJ *variant_obj;
    struct timeval      timestamp; 
    union
    {
        struct
        {
            unsigned int variant : 1;
            unsigned int reserved : 15;
        }bit;
        unsigned int ivalue;
    } flags;
} AFINSTANCE;

typedef struct _d01_msg_wrapper_
{
    /* hash */
    char hash_key[MAX_HASH_KEY_SIZE];
    int hash_key_len;
    struct _d01_msg_wrapper_ *prev;
    struct _d01_msg_wrapper_ *next;

    /* dbllist */
    int protocolOp;
    int tid;
    char object[LDAP_MAX_OID_SIZE]; // input oid or dn
    DBLIST dbllist;
    DSSESSION *ref;
    AFINSTANCE *instance;
    LDAPMessage_t *lmsg;
} MWRAPPER;


typedef struct _af_uri_list_
{
    struct _af_uri_list_ *prev;
    struct _af_uri_list_ *next;

    char param[MAX_URI_PATH_SIZE];
    char value[MAX_URI_PATH_SIZE];
    int last_flag;
} URILIST;

typedef struct _rahs_conf_warm_
{
    char sflog_level[256];
    int stat_interval;
#ifdef XTHREAD_STAT
    int stat_alignment;
#endif
#ifdef STAT_RESET
    int stat_reset_interval;
#endif
#ifdef SDFLOG_SPLIT
	int sflog_split_interval;
#endif
    int housekeeper_interval;
    int ldap_keepalive_interval;
    int restart_delay;

    int high_msg_count;
    int low_msg_count;

    int sdfdb_format;
    int sdfdb_time_to_wait;

    int tps_limit;
    int tps_window;
    int remoteDSA[128];
    int scaleNumberDSA;

    /* biz logic for amf */
    int sla_crt_pkg;
    int thread_log_max;
    char log_path[1024];

    /* Package Control */
    int limit_package;
    int min_package;
    int max_package;
    int skip_pacakge[128];
    int skip_len;
    int matching_rule_count;
    MatchingRule *matching_rule[16];
    int migration_mode; /* Use for switching database between ds3 and ds4. MIG_MODE, DS3_MODE, DS4_MODE */
    int heartbeat_type;
    int hearthbeat_interval;
    char heartbeat_oid[32];
    char heartbeat_dn[512];
    char heartbeat_scope[16];
    char heartbeat_object[128];
    MigrationState *migration_state;
    int max_rollback_retry;
    int tim_dbl_expiry_time;
    int default_ident_add_target;
} RAHS_CONF_WARM;

#ifdef SYNC_DMCD
typedef struct _http_clnt{
    char host[1024];
    int port;
    int connection;
}HTTP_CLNT;
#endif

#ifdef GRPC
typedef struct _grpc_conf{
    #define GRPC_DEFAULT_CONNECTION     1
    #define GRPC_DEFAULT_CONCURRENCE    10
    int max_connection;
    int max_concurrence;
}GRPC_CONF;
#endif

typedef struct _d01h_
{
    char					directory[256];
    char					instance[64];
    char					common_config[1024];
    char					config[1024];
    RAHS_SHM*				shm;
    int						shm_id;
    int						ipc_sock;
    pid_t					fmon_pid;
    time_t					fmon_start;
    unsigned long			fmon_fault_count;
    pid_t					main_pid;
    time_t					main_start;
    int						shutdown;

    time_t					mid_night;

    RAHS_CONF_WARM			conf_warm;

    int						control_pause;
    int						msg_count_pause;
    int						tps_limit_pause;
    time_t					ref_time;
    int						trans_count;

    int                     MMID_count;   //ModifyIdentity method
    int                     MMNM_count;   //ChangeNumber method
    int                     MCPKG_count;   //CreatePackage method
    int                     MCPRF_count;   //InsertSubscriber method

    HOST_EQUIV*				authen;
    DS_t*                   ldapd;
#ifdef SYNC_DMCD
    HTTP_CLNT_t*            http_clnt[128];
    int                     http_list_count; 
    HMAP_DB                 *cluster_group;
    unsigned long           clusterID_array[256];
    int                     clusterID_len;
#endif
    LDAP_t*                 ldap_list[MAX_LDAP_HOST];
    int                     ldap_list_count;
    int                     ldap_ready_flag;
    int                     ldap_host_index; // for ldap host sharing (round-robin)
    int                     ldap_ext_index; // for ldap ext sharing (round-robin)
    base_epoll_t*			base_epoll;

    /* sdf msg wrapper store here */
    struct
    {
        MWRAPPER *hash_array[MAX_HASH_BUCKET_SIZE];
        int hash_bucket;
    }                       htable;
    DBLIST*                 dbl;
    unsigned long			sdfdb_count;
    unsigned long			sdfdb_purge_count;
#ifdef GRPC
 #define D11_DEFAULT_CLUSTER "cluster0"
    int                     http2_host_count; 
    int                     http2_service_count;
    int                     D11_status;
    int                     D11_sock;
    unsigned long           D11_req_id;
    AFINSTANCE              *D11_instance;      
    char                    *global_search_attributes[MAX_ATTRS_LENGTH];
    HMAP_DB                 *global_configuration;
    GLOBAL_APP_CONF         app_conf;
    GLOBAL_CONF             global_conf;
    GRPC_CONF               grpc_conf;
#endif
    
#ifdef XTHREAD_STAT
    xthread_t               xthread_stat;
    int 					xthread_stat_exit;
#endif
    xthread_t               xthread_log[128];
    int                     xthread_log_exit[128];
#ifdef STAT_RESET
	time_t                  stat_reset_time;
#endif
    uint64_t                gid_prefix;
    struct
    {
        TRANSACTIONIDMAPPER *hash_array[MAX_HASH_BUCKET_SIZE];
        int hash_bucket;
    }                       trans_id_map;
    TIMDBLIST*              tim_dbl;
} D01H;

#ifdef GRPC
HTTP2_SERVICE *HTTP2_SERVICES[128];
ROUTING_RULE *G_OFFILE_RULE = NULL;
char DEFAULT_CLUSTER_D21[128];
char DEFAULT_CLUSTER_D20[128];
#endif
static D01H d02global;

extern int errno;

#ifdef XTHREAD_STAT
int stat_thread(void *param);
#endif 

static int l_sess_write_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_sess_read_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_sess_close_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_sess_recv_msg(DSSESSION *sess);
static int l_sess_send_response(DSSESSION *sess, BER *ber);
static int l_sess_send_error(DSSESSION *sess, LDAPMessage_t *lmsg, int error_code, char *error_msg);

#ifdef SYNC_DMCD
static int h_clnt_open();
static int h_clnt_close(HCSESSION *sess);
static int h_clnt_write_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int h_clnt_read_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int h_clnt_close_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int h_clnt_recv_msg(HCSESSION *sess);
#endif

#ifdef GRPC
static int http2_add_conn(char *group, char *ip, int port, int max_connection, int max_concurrence, char *cluster_name, unsigned long cluster_id, char *node_name, unsigned long node_id, char *key_name, int key_len, int link_status, int state);
#endif
static int l_clnt_write_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_clnt_read_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_clnt_close_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data);
static int l_clnt_send_msg(BER *ber);
static int l_clnt_send_msg_lc(BER *ber, LDAP_CLNT *lc);
static int l_clnt_send_ext_msg(BER *ber);
static int l_clnt_recv_msg(LDAP_CLNT *lc);
static int ldap_object_free(LDAP_OBJECT *obj);
static int get_baseDN(char *alias_type, char *alias_value, char *base_dn);

int FREE_BER_ATTRLIST(BER_ATTRLIST *ba);
int FREE_BER_VALUELIST(BER_VALLIST *va);
char *strptime(const char *s, const char *format, struct tm *tm);
static BER_VALLIST * ldap_get_attrval(LDAP_OBJECT *obj, char *attr);
static int amf_get_field_attrval(char *src,char *dst, int field, char deli);
static int invoke_log_flusher();
static int shutdown_thread();
int log_flusher(void *args);
static int write_log(const char *level, int pid, const char *file, const char *function, int line, const char *format, ...);
static int write_CDR(const char *app_id,
                    const char *refer_id,
                    int record_type,
                    const char *status,
                    const char *reason,
                    const char *record_format,
                     ...);
static int write_CDR2(const char *app_id,
                      const char *refer_id,
                      int record_type,
                      const char *record_format,
                      ...);

/* Interface for cdr */
#define RECORD_FORMAT_GET       "%s,%s"     //!-- <subsystem>,[[<key>,<value>]|[uri]|[dn]]
#define RECORD_FORMAT_PUT       "%s,%s"     //!-- <subsystem>,[[<key>,<value>]|[uri]|[dn]]
#define RECORD_FORMAT_POST      "%s,%s,%s"  //!-- <subsystem>,[[<key>,<value>]|[uri]|[dn]]
#define RECORD_FORMAT_DEL       "%s,%s"     //!-- <subsystem>,[[uri]|[dn]]
#define RECORD_FORMAT_MCPRF     "%s,%s,%s"  //!-- <identityName>, <identityValue>,[newUID]
#define RECORD_FORMAT_MCPKG     "%s,%s,%s"  //!-- <identityName>, <identityValue>, <productOffer>
#define RECORD_FORMAT_MMNM      "%s,%s"     //!-- <existingNumber>, <newNumber>
#define RECORD_FORMAT_MMID      "%s,%s,%s,%s"   //!-- UID, <value>, <type>, <identityName>, <identityValue>
#define RECORD_FORMAT_MRESOLV   "%s,%s,%s,%s"   //!-- UID, <value>, <type>, <identityName>, <identityValue>

#define SDFBIZ_INFO(_format, ...) write_log("INFO", getpid(), __FILE__, __FUNCTION__, __LINE__, _format, ##__VA_ARGS__)
#define SDFBIZ_DEBUG(_format, ...) write_log("DEBUG", getpid(), __FILE__, __FUNCTION__, __LINE__,_format, ##__VA_ARGS__)
#define SDFBIZ_WARN(_format, ...) write_log("WARN", getpid(), __FILE__, __FUNCTION__, __LINE__, _format, ##__VA_ARGS__)
#define SDFBIZ_ERROR(_format, ...) write_log("ERROR", getpid(), __FILE__, __FUNCTION__, __LINE__, _format, ##__VA_ARGS__)
#define SDFBIZ_FATAL(_format, ...) write_log("FATAL", getpid(), __FILE__, __FUNCTION__, __LINE__, _format, ##__VA_ARGS__)

#define USE_RPC_SERVICE(_instance, _group, _service, _cmd_type) do{    \
    if( strcasecmp(_group, "D20") == 0){                    \
        strcpy(_instance->cluster, DEFAULT_CLUSTER_D20);    \
    }else if( strcasecmp(_group, "D21") == 0){              \
        strcpy(_instance->cluster, _instance->cluster_d21); \
    }                                                       \
    _instance->command_type = _cmd_type;                    \
    strcpy(_instance->group, _group);                       \
    _instance->service = _service;                          \
}while(0);
long cmp_long( const void *a, const void *b){
    return *(const long *)a - *(const long *)b;
}
int cmp_int( const void *a, const void *b){
    return *(const int *)a - *(const int *)b;
}

#define SET_GET_METHOD(_instance, _val) STRCASEEQ(_instance->group,"D20")? _val|d02global.global_conf.get_type.d20_get_type : STRCASEEQ(_instance->group,"D21")? _val|d02global.global_conf.get_type.d21_get_type : _val

#ifdef GRPC
char * ROUTING_RULE_TO_STRING(int rule){
    switch( rule ){
        case ROUND_ROBIN:
            return "ROUND_ROBIN";        
        case MASTER_RATIO_WITH_ROUNDROBIN:
            return "MASTER_RATIO_WITH_ROUNDROBIN";
        case MASTER_RATIO_WITH_LEASTUTILIZE:
            return "MASTER_RATIO_WITH_LEASTUTILIZE";
        case ACTIVE_STANDBY:
            return "ACTIVE_STANDBY";
        default:
            return "UNKNOWN";
    }
    return 0;
}

char * RAFT_STATE_TO_STR(int state){
    switch(state){
        case RAFT_STATE_FOLLOWER:
            return "FOLLOWER";
        case RAFT_STATE_LEADER:
            return "LEADER";
        case RAFT_STATE_UNKNOWN:
        default:
            return "UNKNOWN";
    }
}

char * LINK_STATUS_TO_STR(int link_status){
    switch(link_status){
        case LINK_STATUS_UP:
            return "UP";
        case LINK_STATUS_DOWN:
            return "DOWN";
        case LINK_STATUS_UNKNOWN:
        default:
            return "-";
    }
}

char * D11_STATE_TO_STR(int state){
    switch( state ){
        case D11_STATE_IDLE:
            return "D11_STATE_IDLE";
        case D11_STATE_QUERY_REQUEST:
            return "D11_STATE_QUERY_REQUEST";
        case D11_STATE_WATCH_REQUEST:
            return "D11_STATE_WATCH_REQUEST";
        case D11_STATE_WATCH_RESTORE:
            return "D11_STATE_WATCH_RESTORE";
        default:
            return "D11_STATE_UNKNOWN";
    }
}
#endif 


#ifdef SYNC_DMCD
static void test_create_cluster(char *cusid){
    static char func[]="test_create_cluster";
    CLUSTER *cluster01  = NULL;
    create_cluster(&cluster01, cusid, NULL);
    if( cluster01 ){
        add_conn_d21(cluster01, "10.252.192.31", 8080, 0, NULL);
        add_conn_d21(cluster01, "10.252.192.21", 8081, 0, NULL);
        add_conn_d21(cluster01, "10.252.192.41", 8082, 0, NULL);
    }else{
        SDFLOG_INFO((B, "create_cluster return error"))
    }
    hmap_add_tuple_with_data(&d02global.cluster_group, cusid, strlen(cusid), cluster01, 1);
    hmap_print_table(d02global.cluster_group);
    TUPLE *got = NULL;
    hmap_search(d02global.cluster_group, cusid, strlen(cusid), &got);
    if(got == NULL){
        SDFLOG_INFO((B, "Not found tuple"))       
    }else{
        cluster01 = (CLUSTER*)got->data;
        SDFLOG_INFO((B, "Show cluster : %s", cluster01->cluster_id))
        int i = 0;
        for(; i < cluster01->conn_d21_count; i++){
            SDFLOG_INFO((B, "ip[%s] port[%d]", cluster01->conn_d21[i].host, cluster01->conn_d21[i].port))
        }
    }
}

static void make_cluster_array(){
    static char func[] = "make_cluster_array";
    
    if( d02global.cluster_group == NULL){
        return;
    }
    
    TUPLE *head = d02global.cluster_group->list_tuple;
    int i = 0;
    while( head != NULL ){
        
        d02global.clusterID_array[i] = strtoul(((CLUSTER*)head->data)->cluster_id, NULL, 16);
        SDFLOG_DEBUG((B, "clusterID ~~~~ %lu",d02global.clusterID_array[i]))
        i++;
        head = head->next;
        if(head == d02global.cluster_group->list_tuple){
            break;
        }
    }
    // Sorting cluster
    d02global.clusterID_len = i;
    qsort(&d02global.clusterID_array, i, sizeof(long), cmp_long);
}

static unsigned long get_cluster_by_UID(char *uid, unsigned long *clusterID, char *err){

    int f = -1, i = 0, j = 0, n = 0, m = 0;
        
    if( (n = d02global.clusterID_len) <= 0){
        sprintf(err, "ClusterID is empty");
        return -1;
    } 
    
    f = atoi(uid);
    
    // there is only one cluster
    if( n == 1){
        if( clusterID != NULL){
            *clusterID =  d02global.clusterID_array[0];
        }
        return 0;
    }

    // Out of range
    if (f > d02global.clusterID_array[n-1] || f <= d02global.clusterID_array[0]){
        if( clusterID != NULL){
            *clusterID =  d02global.clusterID_array[0];
        }
        return 0;
    }

    i = 0; j = n-1;

    for (;i < j;) {

      m = j-i;
      m = (m >> 1);
      m = m+i;

      if ( f == d02global.clusterID_array[m] ){
        *clusterID = d02global.clusterID_array[m]; // exactly match
         break;
      }else if (f < d02global.clusterID_array[m]){
         j = m-1;
      }else {
         i = m+1;
      }
    }

    // there are only two cluster
    if( f > d02global.clusterID_array[i] ){
        if( clusterID != NULL){
            *clusterID =  d02global.clusterID_array[i+1];
        }
        return 0;
    }else{
        if( clusterID != NULL){
            *clusterID =  d02global.clusterID_array[i];
        }
        return 0;
    }
}
#endif

static int                  ds_tid = 0;
static unsigned int         grpc_tid = 0;
static unsigned short int   trans_id = 0;

static int replace_string( char ch, char nch, char *string){
    int i = 0, r = 0;
    for( ; string[i] != 0 ; i++){
        if( string[i] == ch){
            string[r++] = nch;
        }else{
            string[r++] = string[i];
        }
    }
    string[r] = '\0';
    return 0;
}

static unsigned short int trans_id_gen(){
    ++(trans_id);
    if (trans_id <= 0) trans_id = 1;
    if (trans_id >= 0x7FFF) trans_id = 1;
    return trans_id;
}
static unsigned int grpc_tid_gen(){
    ++(grpc_tid);
    if (grpc_tid <= 0) grpc_tid = 1;
    if (grpc_tid >= 0x7FFFFFFF) grpc_tid = 1;
    return grpc_tid;
}
static int get_tid(){
    ++(ds_tid);
    if (ds_tid <= 0) ds_tid = 1;
    if (ds_tid >= 0x7FFFFFFF) ds_tid = 1;
    return ds_tid;
}

static int
get_int (char *s, int *t)
{
    char *p;
    long n;

    n = strtol (s, &p, 10);
    if (n == LONG_MAX)
        return -1;
    if (p == s)
        return -2;
    if (*p != '\0')
        return -3;
    if (n > INT_MAX)
        return -4;
    *t = (int)n;
    if (*t != n)
        return -5;
    return 0;
}

/*static int
get_uint(char *s, unsigned int *t)
{
    char *p;
    unsigned long n;

    n = strtoul(s, &p, 10);
    if (n == ULONG_MAX)
        return -1;
    if (p == s)
        return -2;
    if (*p != '\0')
        return -3;
    if (n > UINT_MAX)
        return -4;
    *t = (unsigned int)n;
    if ((unsigned long)(*t) != n)
        return -5;
    return 0;
}*/

const char * record_to_string(int record_type){
    switch(record_type){
        case RECORD_GET:
            return "GET";
        case RECORD_POST:
            return "POST";
        case RECORD_PUT:
            return "PUT";
        case RECORD_DEL:
            return "DEL";
        case RECORD_MCPRF:
            return "MCPRF";
        case RECORD_MCPKG:
            return "MCPKG";
        case RECORD_MMNM:
            return "MMNM";
        case RECORD_MMID:
            return "MMID";
        case RECORD_MRESOLV:
            return "MRESOLV";
        default:
            return "unknown";
    }
    return "unknown";
}

static char *
time_to_string (time_t ct)
{
    static char buff[256];
    struct tm tm = *localtime (&ct);
    (void) sprintf (buff, "%04d-%02d-%02d %02d:%02d:%02d", 1900+tm.tm_year, tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    return buff;
}

static char *
signal_to_string (int sig)
{
    static char buff[256];
    char *p;
    extern char *strsignal (int sig);   /* favour linux */

    p = strsignal (sig);
    if (p == NULL)
    {
        (void) sprintf (buff, "UNKNOWN(%d)", sig);
        p = buff;
    }
    return p;
}

static int
timeval_subtract (struct timeval *result, struct timeval *x,struct timeval *y)
{
	if (x->tv_usec < y->tv_usec) {
		int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
		y->tv_usec -= 1000000 * nsec;
		y->tv_sec += nsec;
	}
	if (x->tv_usec - y->tv_usec > 1000000) {
		int nsec = (x->tv_usec - y->tv_usec) / 1000000;
		y->tv_usec += 1000000 * nsec;
		y->tv_sec -= nsec;
	}

	result->tv_sec = x->tv_sec - y->tv_sec;
	result->tv_usec = x->tv_usec - y->tv_usec;

	return x->tv_sec < y->tv_sec;
}

int
fd_set_write(int socket)
{
    epoll_event_element_t *epoll_event_elem = NULL;

    if (epoll_event_add(d02global.base_epoll, socket, EPOLLOUT, &epoll_event_elem) != 0)
        return -1;
    else
        return 0;
}

int
fd_set_read(int socket)
{
    epoll_event_element_t *epoll_event_elem = NULL;

    if (epoll_event_add(d02global.base_epoll, socket, EPOLLIN | EPOLLET, &epoll_event_elem) != 0)
        return -1;
    else
        return 0;
}

int
fd_clear(int socket)
{
    epoll_event_remove(d02global.base_epoll , socket);
    return 0;
}

int
http_alloc_buffer(HSDATA **data, int len)
{
	static char func[] = "http_alloc_buffer";

	if (*data == NULL)
	{
		ADJUST_SIZE(len, MY_DATA_BUFFER)
		*data = (HSDATA*)SDF_MALLOC(sizeof(HSDATA) + len);
		if (*data == NULL)
		{
			SDFLOG_ERROR((B, "Can not allocate memory size (%u)", (unsigned int)(sizeof(HSDATA) + len)))
			return -1;
		}
		(void)memset((*data), 0, sizeof(HSDATA)+len);
		(*data)->size = len;
		(*data)->len = 0;
	}
	else if (((*data)->len + len) > (*data)->size)
	{
		HSDATA *x;
		len += (*data)->len;
		ADJUST_SIZE(len, MY_DATA_BUFFER)
		x = (HSDATA*)SDF_REALLOC((*data), sizeof(HSDATA) + len);
		if (x == NULL)
		{
			SDFLOG_ERROR((B, "Can not reallocate memory size (%u)", (unsigned int)(sizeof(HSDATA) + len)))
			return -1;
		}
		x->size = len;
		*data = x;
		(void)memset((*data)->data+(*data)->len, 0, (*data)->size-(*data)->len);
	}
	return 0;
}

#define CHECK_JSON_SPECIAL_CHARACTER(_PTR)      \
{                                               \
if (_PTR < end && (*(_PTR)!='\\')&&             \
(*(_PTR)!='"'))                                 \
{                                               \
    SDFLOG_ERROR((B, "Invalid JSON format"))    \
    return -1;                                  \
}                                               \
}                                               
#define JSON_ENCODE_SPECIAL_CHAR                \
{                                               \
do{                                             \
pp = strstr(p,"\\");                            \
if (pp != NULL){                                \
    CHECK_JSON_SPECIAL_CHARACTER(pp+1);         \
    memcpy(pp,pp+1,strlen(pp)-1);               \
    *(pp) = (*pp=='"')?0x01:0x02;               \
    end--;                                      \
    *end = 0;                                   \
    pp++;                                       \
}                                               \
}while (pp!=NULL);                              \
}

#define JSON_DECODE_SPECIAL_CHAR                \
{                                               \
const char dq[2] = {0x01,0x00};                 \
const char bs[2] = {0x02,0x00};                 \
char *res;                                      \
do{                                             \
if (((res = strstr(p,dq)) != NULL) && (res<pp)) \
    *res++ = '"';                               \
else if (((res = strstr(p,bs)) != NULL) && (res<pp))    \
    *res++ = '\\';                              \
}while((res!=NULL)&&(res<pp));                  \
}

#define JSON_TRIM_ENCODE_SPECIAL_CHAR(_PTR)     \
{                                               \
int idx=0;                                      \
while (_PTR[idx]!=0)                            \
{                                               \
    if ((_PTR[idx] == '\\') &&                  \
        ((_PTR[idx+1] == '\\')||(_PTR[idx+1] == '"')))  \
    {                                           \
        _PTR[idx] = 0x02;                       \
        _PTR[idx+1] = (_PTR[idx+1]=='"')?0x1:0x02;  \
    }                                           \
idx++;                                          \
}                                               \
}

#define JSON_TRIM_DECODE_SPECIAL_CHAR(_PTR)     \
{                                               \
int idx=0;                                      \
while (_PTR[idx]!=0)                            \
{                                               \
    if ((_PTR[idx] == 0x02) &&                  \
        ((_PTR[idx+1] == 0x02)||(_PTR[idx+1] == 0x01))) \
    {                                           \
        _PTR[idx] = '\\';                       \
        _PTR[idx+1] = (_PTR[idx+1]==0x01)?'"':'\\'; \
    }                                           \
    idx++;                                      \
}                                               \
}

#define FORMAT_STRING_TO_INT(_FORMAT)           \
{                                               \
SDFLOG_DEBUG((B, "format[%s]" ,format))         \
if (strcmp(format, "json")==0)                  \
    _FORMAT = LBER_DECODE_JSON;                 \
else if (strcmp(format, "text")==0)             \
    _FORMAT = LBER_DECODE_PRINTABLE_STRING;     \
else if (strcmp(format, "xml")==0)              \
    _FORMAT = LBER_DECODE_XML;                  \
else                                            \
    _FORMAT = LBER_DECODE_JSON;                 \
}

#define GET_URI_STRING(_OUT,_CHR,_MAX)          \
{                                               \
if (pp!=NULL)                                   \
{                                               \
    p = pp+1;                                   \
    pp = strchr(p, _CHR);                       \
    if (pp!=NULL)                               \
    {                                           \
        int l = (int)(pp-p);                    \
        if (l>=_MAX) l = _MAX-1;                \
        memcpy(_OUT, p, l);                     \
        _OUT[l] = 0;                            \
    }                                           \
    else                                        \
    {                                           \
        strncpy(_OUT, p, _MAX-1);               \
    }                                           \
}                                               \
else                                            \
{                                               \
    _OUT[0] = 0;                                \
}                                               \
}

#define GET_URI_PAGE(_OUT,_FORMAT,_STR)         \
{                                               \
register int flag=0;                            \
p = _STR;                                       \
char *_e=strchr(_STR, '?');                     \
pp = strchr(_STR,'.');                          \
if (pp!=NULL)                                   \
{                                               \
    char *last=pp;                              \
    char *end=strchr(_STR, '?');                \
    if (end==NULL) end = _STR+(int)strlen(_STR);\
    do                                          \
    {                                           \
        pp = last;                              \
        last = strchr(pp+1, '.');               \
    } while ((last!=NULL)&&(last<end));         \
    memcpy(_OUT, _STR, pp-_STR);                \
    _OUT[pp-_STR] = 0;                          \
    p = pp + 1;                                 \
    flag = 1;                                   \
}                                               \
else                                            \
    _FORMAT = LBER_DECODE_JSON;                 \
pp = strchr(p, '?');                            \
if ((flag==1)&&(pp!=NULL))                      \
{                                               \
    memcpy(format, p, pp-p);                    \
    format[pp-p] = 0;                           \
    FORMAT_STRING_TO_INT(_FORMAT);              \
    if( _FORMAT == LBER_DECODE_JSON && strcmp(format, "json") != 0) \
        strcpy(_OUT, _STR);                     \
}                                               \
else if ((flag==1)&&(pp==NULL))                 \
{                                               \
    strcpy(format, p);                          \
    FORMAT_STRING_TO_INT(_FORMAT);              \
    if( _FORMAT == LBER_DECODE_JSON && strcmp(format, "json") != 0) \
    strcpy(_OUT, _STR);                         \
}                                               \
else if (pp!=NULL)                              \
{                                               \
    memcpy(_OUT, p, pp-p);                      \
    _OUT[pp-p] = 0;                             \
}                                               \
else                                            \
    strcpy(_OUT, p);                            \
}

#define GET_URI_SCOPE(_OUT,_STR)                \
{                                               \
strcpy(_OUT, "base");                           \
pp = strchr(_STR, '?');                         \
if ((pp!=NULL)&&((pp=strstr(pp+1,"scope="))!=NULL)) \
{                                               \
    char param[MAX_URI_PATH_SIZE];              \
    pp = pp + 5;                                \
    GET_URI_STRING(param, '&', MAX_URI_PATH_SIZE); \
    pp = param-1;                               \
    GET_URI_STRING(_OUT, ',', MAX_SCOPE_SIZE);  \
}                                               \
SDFLOG_DEBUG((B, "scope[%s]" ,_OUT))            \
}


#define GET_URI_FILTER(_OUT,_STR)               \
{                                               \
pp = strchr(_STR, '?');                         \
if ((pp!=NULL)&&((pp=strstr(pp+1,"filter=("))!=NULL)) \
{                                               \
    pp = pp + 7;                                \
    p = pp;                                     \
    int __i = 0;                                \
    while( p != NULL ){                         \
        if( *p == '(' ){                        \
            __i++;                              \
        }else if( *p == ')'){                   \
            --__i;                              \
            if( __i == 0){                      \
                break;                          \
            }                                   \
        }                                       \
        p++;                                    \
    }                                           \
    if( p == NULL){                             \
        _OUT[0];                                \
    }                                           \
    else if((p-pp+1) > MAX_FILTER_SIZE)         \
    {                                           \
        SDFLOG_ERROR((B, "Filter length [%d] exceed limit [%d]", (int)(p-pp+1), (int)MAX_FILTER_SIZE))    \
        /*METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid parameter");*/                      \
        return -2;                              \
    }                                           \
    else                                        \
    {                                           \
        memcpy(_OUT, pp, p-pp+1);               \
        _OUT[p-pp+1] = 0;                       \
    }                                           \
}                                               \
SDFLOG_DEBUG((B, "filter[%s]" ,_OUT))           \
}

#define GET_URI_ATTR_NAME(_OUT,_STR)            \
{                                               \
pp = strchr(_STR, '?');                         \
if ((pp!=NULL)&&((pp=strstr(pp+1,"attrname="))!=NULL))\
{                                               \
    char param[MAX_URI_PATH_SIZE];              \
    pp = pp + 8;                                \
    GET_URI_STRING(param, '&', MAX_URI_PATH_SIZE);\
    pp = param-1;                               \
    GET_URI_STRING(_OUT, ',', 128);             \
}                                               \
SDFLOG_DEBUG((B, "attrname[%s]" ,_OUT))         \
}

#define GET_URI_ATTR_VALUE(_OUT,_STR)           \
{                                               \
pp = strchr(_STR, '?');                         \
if ((pp!=NULL)&&((pp=strstr(pp+1,"attrvalue="))!=NULL))\
{                                               \
    pp = pp + 9;                                \
    GET_URI_STRING(_OUT, '&', MAX_URI_PATH_SIZE);\
}                                               \
SDFLOG_DEBUG((B, "attrvalue[%s]" ,_OUT))        \
}

#define GEN_GRPC_ATTRS_FROM_BER_VAL(__VAL, i)do{                    \
    BER_VALLIST *ber_val = __VAL;                                   \
    i = 0;                                                          \
    while(ber_val){                                                 \
        SDFLOG_DEBUG((B, "select field[%s]", ber_val->value))       \
        strcpy(d02global.global_search_attributes[i], ber_val->value);                                  \
        af_process_adaptive_naming_inbound_with_string(d02global.global_search_attributes[i],           \
                                                       d02global.global_conf.attributevalue_mapping,    \
                                                       d02global.global_conf.invert_adaptive_naming);   \
        i++;                                                        \
        ber_val = ber_val->next;                                    \
        if( ber_val == __VAL){                                      \
            break;                                                  \
        }                                                           \
    }                                                               \
}while(0)

#define GEN_GRPC_ATTRS(__ATTRS, i)do{           \
    int __r = 0;                                \
    for(__r = 0; __r < i; __r++){               \
        strcpy(d02global.global_search_attributes[__r], __ATTRS[__r]);  \
        af_process_adaptive_naming_inbound_with_string(d02global.global_search_attributes[__r],         \
                                                       d02global.global_conf.attributevalue_mapping,    \
                                                       d02global.global_conf.invert_adaptive_naming);   \
    }                                           \
}while(0)                                       

#define GET_URI_FIELDS(_STR)                    \
{                                               \
pp = strchr(_STR, '?');                         \
if ((pp!=NULL)&&((pp=strstr(pp+1,"fields="))!=NULL)) \
{                                               \
    char param[MAX_URI_PATH_SIZE];              \
    i = 0;                                      \
    pp = pp + 6;                                \
    GET_URI_STRING(param, '&', MAX_URI_PATH_SIZE); \
    pp = param-1;                               \
    do                                          \
    {                                           \
        GET_URI_STRING(attrs[i], ',', 128);     \
        if(attrs[(i)][0]!=0)                    \
        SDFLOG_DEBUG((B, "field[%s]" ,attrs[i]))\
    } while ((i<MAX_SEARCH_ATTRS-1)&&(attrs[(i++)][0]!=0));\
    attrs[i][0] = 0;                            \
                                                \
}                                               \
LDAP_gen_ber_string(attrs, &b_attrs, error);    \
if (b_attrs != NULL)                            \
{                                               \
    b_len = b_attrs->len;                       \
    b_string = b_attrs->berval;                 \
}                                               \
}
#define CHECK_JSON_CHARACTER(_PTR)              \
{                                               \
if (_PTR < end && (*(_PTR)!=':')&&              \
(*(_PTR)!='[') &&(*(_PTR)!='\r')&&              \
(*(_PTR)!=']') && (*(_PTR)!='{')&&              \
(*(_PTR)!='}') &&(*(_PTR)!=',')&&               \
(*(_PTR)!='\n')&&(*(_PTR)!=' ')&&               \
(*(_PTR)!='\\'))                                \
{                                               \
    SDFLOG_ERROR((B, "Invalid JSON format"))    \
    return -1;                                  \
}                                               \
}
#define CHECK_JSON_FORMAT                       \
{                                               \
if ((p>=end)||(pp>=end))                        \
{                                               \
    SDFLOG_DEBUG((B, "Invalid JSON format"))    \
    return -1;                                  \
}                                               \
}
#define FIND_CHAR(_PTR,_CHAR)                   \
{                                               \
while (((*_PTR!=_CHAR)||(*(_PTR-1)=='\\'))&&(_PTR<end)) ++(_PTR); \
CHECK_JSON_FORMAT;                              \
}


#define RESULT_JSON_FORMAT "{\"resultCode\":\"%d\",\"resultDescription\":\"%s\",\"matchedDN\":\"\",\"diagnosticMessage\":\"\"}\n"

#define METHOD_GEN_HTTP_ERROR(sess, status, result_code, result_desc){      \
    HSDATA *wbuff = NULL;                                                   \
    char c_buff[1024];                                                      \
    char m_buff[2048];                                                      \
    c_buff[0] = '\0';                                                       \
    m_buff[0] = '\0';                                                       \
    if(http_gen_error_page(sess, &wbuff, status, NULL) != 0){               \
        SDFLOG_ERROR((B, "http_gen_error_page"));                           \
        return -1;                                                          \
    }                                                                       \
    int len = sprintf(m_buff, RESULT_JSON_FORMAT, result_code, result_desc);\
    int clen = sprintf(c_buff, HTTP_CONTENT_LENGTH": %d\r\n\r\n", len);     \
    if ((wbuff->len + len + clen) > wbuff->size){                           \
        if (http_alloc_buffer(&wbuff, len+clen) != 0)                       \
        {                                                                   \
            SDFLOG_ERROR((B, "adjust http_alloc_buffer"));                  \
            SDF_FREE(wbuff);                                                \
            return -1;                                                      \
        }                                                                   \
    }                                                                       \
    memcpy(wbuff->data + wbuff->len, c_buff, clen);                         \
    wbuff->len = wbuff->len + clen;                                         \
    memcpy(wbuff->data + wbuff->len, m_buff, len);                          \
    wbuff->len = wbuff->len + len;                                          \
    LINKEDLIST_APPEND(sess->w_buffer, wbuff);                               \
}
/* This function require :
    char *nattr;
    char *vattr;
    char base_dn[];
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    BER *b_attrs = NULL;
    BER *ber;
    Control *control = NULL;
*/
#define LDAP_GEN_DELETE_REQUEST()                                           \
do{                                                                         \
    if(nattr[0] != '\0'){                                                   \
        if( vattr[0] != '\0'){                                              \
            LBER_valuelist_add(&vlist, vattr, error);                       \
        }                                                                   \
        LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, nattr,vlist , NULL);   \
        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);                    \
        *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, control, error);\
        LDAP_ber_free(b_attrs);                                             \
        if (control != NULL) SDF_FREE(control);                             \
    }else{                                                                  \
        *tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE, ber, base_dn, control, error); \
        if (control != NULL) SDF_FREE(control);                             \
    }                                                                       \
}while(0);

#define LDAP_CREATE_CONTROL()                                                               \
{                                                                                           \
    Control *control = (Control *) SDF_MALLOC(sizeof(Control));                             \
    if(control != NULL)                                                                     \
    {                                                                                       \
        sprintf(control->comps.control_type, "%s", LDAP_CONTROL_USE_ALIAS_ON_UPDATE);        \
        control->comps.control_value.value[0] = 0;                                           \
        control->comps.control_value.len = 0;                                                \
    }                                                                                        \
}

#define LDAP_CREATE_TRANSACTION_CONTROL(_instance)                                          \
{                                                                                           \
    if((_instance->tim != NULL) && (_instance->tim->state == TRANSACTION_STATE_RESOLVED))   \
    {                                                                                       \
        /*if(control == NULL)*/                                                             \
        /*{*/                                                                               \
            Control *control = (Control *) SDF_MALLOC(sizeof(Control));                     \
        /*}*/                                                                               \
        sprintf(control->comps.control_type, "%s", LDAP_CONTROL_TRANSACTION_ID);            \
        sprintf(control->comps.control_value.value, "%d", _instance->tim->DSx_tid);         \
    }                                                                                       \
}

// #define IDENTITY_BY_UID     0
// #define IDENTITY_BY_ALIASE  1
#define GET_IDENTITY_OLD(_copystr_){                                                                \
    if(base_dn[0] == 0){                                                                        \
        SDFLOG_ERROR((B, "Dn is empty"))                                                        \
        return -3;                                                                              \
    }                                                                                           \
    int __sz = strlen(base_dn);                                                                 \
    int __3th_rdn = 0;                                                                          \
    int __identity = 0;                                                                         \
    p_base_dn = &base_dn[0];                                                                    \
    while(__sz-- > 0){                                                                          \
        if( base_dn[__sz] == ',' ){                                                             \
            __3th_rdn++;                                                                        \
            if(__3th_rdn == 3){                                                                 \
                if( strcasecmp(&base_dn[__sz], ",ds=SUBSCRIBER,o=AIS,dc=C-NTDB") == 0){         \
                    __identity = IDENTITY_BY_UID;                                               \
                } else if(strcasecmp(&base_dn[__sz], ",o=services,o=AIS,dc=C-NTDB") == 0){      \
                     p_base_dn = &base_dn[0];                                                   \
                     if(_copystr_ != NULL) {                                                    \
                        strcpy(_copystr_ /*instance->default_base_dn*/, base_dn);               \
                     }                                                                          \
                     break;                                                                     \
                }else{                                                                          \
                    base_dn[__sz]   = 0;                                                        \
                    p_base_dn = &base_dn[(++__sz)];                                             \
                    break;                                                                      \
                }                                                                               \
            }else if(__3th_rdn == 4){                                                           \
                base_dn[__sz]   = 0;                                                            \
                p_base_dn = &base_dn[(++__sz)];                                                 \
                break;                                                                          \
            }                                                                                   \
        }                                                                                       \
    }                                                                                           \
    if( __3th_rdn < 3 )                                                                         \
    {                                                                                           \
        /*SDFLOG_ERROR((B, "Not allow DN: [%s]", base_dn))*/                                    \
        /*return -1;*/                                                                          \
        if(_copystr_ != NULL) {                                                                 \
            strcpy(_copystr_ /*instance->default_base_dn*/, base_dn);                           \
        }                                                                                       \
        alias_dn_flag = 1;                                                                      \
    }                                                                                           \
}

       
int sdf_time_cmp(time_t time_ref, const char * format, const char *time_str){

    struct tm  tm;
    (void) memset(&tm, 0, sizeof(struct tm));
    strptime(time_str, format, &tm);
    time_t time_usr = mktime(&tm);

    if( time_usr == time_ref){          //input time equal refference time
        return 0;
    }else if ( time_usr > time_ref){    //input time less than refference time
        return 1;
    }else if ( time_usr < time_ref){    //input time more than refference time
        return -1;
    }
    return -2;
}

static int
af_get_http_body_add_param(char *hbody, BER_ATTRLIST **alist, char *object_class)
{
    static char func[] = "af_get_http_body_add_param";
    BER_VALLIST *vlist=NULL;
    char aname[LDAP_MAX_ATTR_NAME_SIZE];
    char avalue[LDAP_MAX_ATTR_VALUE_SIZE];
    char *p, *pp, *end;

    if (hbody==NULL)
    {
        SDFLOG_ERROR((B, "HTTP body is unavailable"))
        return -1;
    }
    end = hbody + (int)strlen(hbody);
    p = hbody;
    pp = p + 1;
    while ((*pp!='"')&&(pp<end)) ++(pp);
    if (pp>=end) return 0;
    pp = p + 1;
    
    //To replace '\"' and '\\' with ASCII 0x01 and 0x02 respectively.
    //These will be decoded back to original char when extract value name.
    JSON_ENCODE_SPECIAL_CHAR  
    
    do
    {
        vlist = NULL;
        ++(p);
        FIND_CHAR(p, '"');
        pp = ++(p);
        FIND_CHAR(pp, '"');
        CHECK_JSON_CHARACTER(pp+1);
        if ((pp-p)>LDAP_MAX_ATTR_NAME_SIZE)
        {
            SDFLOG_ERROR((B, "Attr length exceeds"))
            return -1;
        }
        memcpy(aname, p, pp-p);
        aname[pp-p] = 0;
        SDFLOG_DEBUG((B, "Attr name: [%s]", aname))
        p = pp + 1;
        FIND_CHAR(p, ':');
        while ((*p!='"')&&(*p!='[')&&(p<end)) ++(p);
        if (*p=='"')
        {
            pp = ++(p);
            FIND_CHAR(pp, '"');
            CHECK_JSON_CHARACTER(pp+1);
            FIND_CHAR(pp, '"');
            if ((pp-p)>LDAP_MAX_ATTR_VALUE_SIZE)
            {
                SDFLOG_ERROR((B, "Value length exceeds"))
                return -1;
            }
            
            //To change the decoded ASCIIs back to original char.
            JSON_DECODE_SPECIAL_CHAR
            
            memcpy(avalue, p, pp-p);
            avalue[pp-p] = 0;
            SDFLOG_DEBUG((B, "Single value name: [%s]", avalue))
            LBER_valuelist_add(&vlist, avalue, NULL);
            // find out custom objectClass
            if(object_class != NULL && STREQ(aname,"objectClass")){
                sprintf(object_class, "%s", avalue);
                SDFLOG_DEBUG((B, "## Using custom objectClass ##"))
            }
        }
        else if (*p=='[')
        {
            do
            {
                ++(p);
                FIND_CHAR(p, '"');
                pp = ++(p);
                FIND_CHAR(pp, '"');
                CHECK_JSON_CHARACTER(pp+1);
                if ((pp-p)>LDAP_MAX_ATTR_VALUE_SIZE)
                {
                    SDFLOG_ERROR((B, "Value length exceeds"))
                    return -1;
                }
                
                //To change the decoded ASCIIs back to original char.
                JSON_DECODE_SPECIAL_CHAR
                
                memcpy(avalue, p, pp-p);
                avalue[pp-p] = 0;
                SDFLOG_DEBUG((B, "Multi value name: [%s]", avalue))
                LBER_valuelist_add(&vlist, avalue, NULL);
                p = pp + 1;
                while ((*p!=',')&&(*p!=']')&&(p<end)) ++(p);
                CHECK_JSON_FORMAT;
            } while ((*p==',')&&(*p!=']'));
        }
        else
        {
            return 0; // Provide this case for non attribute case
        }
        LBER_attrlist_add(alist, aname, vlist, NULL);
        p = pp + 1;
        while ((*p!=',')&&(p<end)) ++(p);
    } while (*p==',');

    return 0;
}

static int
af_get_http_body_mod_param(char *hbody, BER_MODLIST **mlist)
{
    static char func[] = "af_get_http_body_mod_param";
    BER_VALLIST *vlist=NULL;
    char aname[LDAP_MAX_ATTR_NAME_SIZE];
    char avalue[LDAP_MAX_ATTR_VALUE_SIZE];
    char *p, *pp, *end;
    int change_type = LDAP_MODIFY_REPLACE;
#define SET_CHANGE_TYPE(){                                  \
    if( STRCASEEQ(aname, "add") ){                          \
        change_type = LDAP_MODIFY_ADD;                      \
    }else if( STRCASEEQ(aname, "delete") ){                 \
        change_type = LDAP_MODIFY_DELETE;                   \
    }else if( STRCASEEQ(aname, "replace")){                 \
        change_type = LDAP_MODIFY_REPLACE;                  \
    }else{                                                  \
        SDFLOG_ERROR((B, "Invalid change type[%s]", aname)) \
        return -1;                                          \
    }                                                       \
}

    if (hbody==NULL)
    {
        SDFLOG_ERROR((B, "HTTP body is unavailable"))
        return -1;
    }
    end = hbody + (int)strlen(hbody);
    p = hbody;
    pp = p + 1;
    
    //To replace '\"' and '\\' with ASCII 0x01 and 0x02 respectively.
    //These will be decoded back to original char when extract value name.
    JSON_ENCODE_SPECIAL_CHAR 
    
    do
    {
        vlist = NULL;
        ++(p);
        FIND_CHAR(p, '"');
        pp = ++(p);
        FIND_CHAR(pp, '"');
        CHECK_JSON_CHARACTER(pp+1);
        if ((pp-p)>LDAP_MAX_ATTR_NAME_SIZE)
        {
            SDFLOG_ERROR((B, "Mod length exceeds"))
            return -1;
        }
        
        memcpy(aname, p, pp-p);
        aname[pp-p] = 0;
        p = pp + 1;
        FIND_CHAR(p, ':');
        while ((*p!='"')&&(*p!='[')&&(*p!='{')&&(p<end)) ++(p);
        
        if (*p=='{')   //Use new API
        {
            SDFLOG_DEBUG((B, "Change type: [%s]", aname))
            SET_CHANGE_TYPE()
            ++(p);
            FIND_CHAR(p, '"');
            pp = ++(p);
            FIND_CHAR(pp, '"');
            //CHECK_JSON_CHARACTER(pp+1);
            if ((pp-p)>LDAP_MAX_ATTR_NAME_SIZE)
            {
                SDFLOG_ERROR((B, "Mod length exceeds"))
                return -1;
            }
            memcpy(aname, p, pp-p);
            aname[pp-p] = 0;
            p = pp + 1;
            FIND_CHAR(p, ':');
            while ((*p!='"')&&(*p!='[')&&(p<end)) ++(p);
        }
        
        SDFLOG_DEBUG((B, "Mod name: [%s]", aname))
        
        if (*p=='"')
        {
            pp = ++(p);
            FIND_CHAR(pp, '"');
            CHECK_JSON_CHARACTER(pp+1);
            if ((pp-p)>LDAP_MAX_ATTR_VALUE_SIZE)
            {
                SDFLOG_ERROR((B, "Value length exceeds"))
                return -1;
            }
                    
            //To change the decoded ASCIIs back to original char.
            JSON_DECODE_SPECIAL_CHAR
            
            memcpy(avalue, p, pp-p);
            avalue[pp-p] = 0;
            SDFLOG_DEBUG((B, "Single value name: [%s]", avalue))
            LBER_valuelist_add(&vlist, avalue, NULL);
        }
        else if (*p=='[')
        {
            do
            {
                ++(p);
                FIND_CHAR(p, '"');
                pp = ++(p);
                FIND_CHAR(pp, '"');
                CHECK_JSON_CHARACTER(pp+1);
                if ((pp-p)>LDAP_MAX_ATTR_VALUE_SIZE)
                {
                    SDFLOG_ERROR((B, "Value length exceeds"))
                    return -1;
                }
                
                //To change the decoded ASCIIs back to original char.
                JSON_DECODE_SPECIAL_CHAR
                
                memcpy(avalue, p, pp-p);
                avalue[pp-p] = 0;
                SDFLOG_DEBUG((B, "Multi value name: [%s]", avalue))
                LBER_valuelist_add(&vlist, avalue, NULL);
                p = pp + 1;
                while ((*p!=',')&&(*p!=']')&&(p<end)) ++(p);
                CHECK_JSON_FORMAT;
            } while ((*p==',')&&(*p!=']'));
        }
        else
        {
            SDFLOG_ERROR((B, "Invalid JSON value"))
            return -1;
        }
        LBER_modlist_add(mlist, change_type, aname, vlist, NULL);
        p = pp + 1;
        while ((*p!=',')&&(p<end)) ++(p);
    } while (*p==',');

    return 0;
}

static int get_objectClass(char *rdn_attr, char *obj){
    if( STRCASEEQ(rdn_attr, "publicId") ){
        sprintf(obj,"%s","gupImpu");
    }else if( STRCASEEQ(rdn_attr, "privateId") ){
        sprintf(obj,"%s","gupImpi");
    }else if( STRCASEEQ(rdn_attr, "serviceProfileId") ){
        sprintf(obj,"%s","gupServiceProfileId");
    }else if( STRCASEEQ(rdn_attr, "serviceId") ){
        sprintf(obj,"%s","gupServiceElement");
    }else if( STRCASEEQ(rdn_attr, "implicitRegSetId") ){
        sprintf(obj,"%s","gupImplicitRegSet");
    }else if( STRCASEEQ(rdn_attr, "aliasId") ){
        sprintf(obj,"%s","gupAliasGroup");
    }else if( STRCASEEQ(rdn_attr, "deviceId") ){
        sprintf(obj,"%s","gupDevice");
    }else if( STRCASEEQ(rdn_attr, "baId") ){
        sprintf(obj,"%s","gupBa");
    }else if( STRCASEEQ(rdn_attr, "caId") ){
        sprintf(obj,"%s","gupCa");
    } else{
        return -1;
    }
    // TODO:
    // email
    // fbbprofile
    return 0;
}

static int check_numeric_valid(char *str, int num_len)
{
    static char func[] = "check_numeric_valid";
    char *nonNumeric;
    unsigned long int numeric;
    numeric = strtol(str, &nonNumeric, 10);
    SDFLOG_DEBUG((B, "Numeric part           [%lu]", numeric))
    SDFLOG_DEBUG((B, "Non numeric charactors [%s]", nonNumeric))
    if (*nonNumeric)
    {
        SDFLOG_WARN((B, "Contain non-numeric charactors"))
        return -1;
    }
    else if (strlen(str) > num_len)
    {
        SDFLOG_WARN((B, "Numeric length exceeds limit [%d]", num_len))
        return -1;
    }
    else
    {
        return 0;
    }
}

static int af_gen_control_transaction(TRANSACTIONIDMAPPER *tim, LDAPMessage_t *lmsg, Control **control)
{
    static char func[] = "af_gen_control_transaction";
    char temp[LDAP_MAX_ATTR_VALUE_SIZE];

    SDFLOG_DEBUG((B, "Setup control"))

    if((tim != NULL) && (tim->state == TRANSACTION_STATE_RESOLVED))
    {
        Control *ctrl = (Control *) SDF_MALLOC(sizeof(Control));
        ctrl->next = ctrl->prev = ctrl;
        SDFLOG_DEBUG((B, "DSx_tid  : [%d]", tim->DSx_tid))
        SDFLOG_DEBUG((B, "l_sess_tid  : [%d]", tim->l_sess_tid))
        
        sprintf(ctrl->comps.control_type, "%s", LDAP_CONTROL_TRANSACTION_ID);
        sprintf(ctrl->comps.control_value.value, "%d", tim->DSx_tid);
        ctrl->comps.control_value.len = strlen(ctrl->comps.control_value.value);
        LINKEDLIST_APPEND(*control, ctrl);

        SDFLOG_DEBUG((B, "Setup control done [p=%p]", *control))
        SDFLOG_DEBUG((B, "control_value [%s]", (*control)->comps.control_value.value))
        SDFLOG_DEBUG((B, "control_type [%s]", (*control)->comps.control_type))
    }

    if(lmsg->controls != NULL)
    {
        Control *tmp_ctrl = lmsg->controls;
        // SDFLOG_DEBUG((B, "lmsg->controls [p=%p]", lmsg->controls))
        while(tmp_ctrl != NULL)
        {
            // SDFLOG_DEBUG((B, "input control_type [%p   %p]", tmp_ctrl, tmp_ctrl->next))
            SDFLOG_DEBUG((B, "input control_type [%s]", tmp_ctrl->comps.control_type))
            SDFLOG_DEBUG((B, "input control_value [%s]", tmp_ctrl->comps.control_value.value))
            if ((strcmp(tmp_ctrl->comps.control_type, LDAP_CONTROL_TRANSACTION_ID) != 0) ||
                (strcmp(tmp_ctrl->comps.control_type, LDAP_CONTROL_MATCHING_IDENTITY) != 0)) 
            {
                Control *ctrl = (Control *) SDF_MALLOC(sizeof(Control));
                ctrl->next = ctrl->prev = ctrl;
                memcpy(ctrl, tmp_ctrl, sizeof(Control));
                SDFLOG_DEBUG((B, "Append input control to control list"))
                LINKEDLIST_APPEND(*control, ctrl);
            }
            tmp_ctrl = tmp_ctrl->next;
            if(tmp_ctrl == lmsg->controls)
            {
                break;
            }
        }
    }

    return 0;
}

static int
af_init_action_post_subscriber_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_post_subscriber_v1";
    char format[16];
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char obj_class[128];
    char rdn_name[LDAP_MAX_ATTR_NAME_SIZE];
    char rdn_value[LDAP_MAX_ATTR_VALUE_SIZE];
    char dn[LDAP_MAX_BASE_DN];
    Control *control=NULL;
    URILIST *plist=NULL, *path=NULL;
    BER_ATTRLIST *alist=NULL;
    BER_VALLIST *vlist=NULL;
    BER *b_attrs=NULL;

    obj_class[0] = '\0';
    pkid[0] = '\0';
    pkvalue[0] = '\0';

    if (pp==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }

    if (strchr(pp+1, '/')!=NULL)
    {

        GET_URI_STRING(pkid, '/', (int)sizeof(pkid));
        SDFLOG_DEBUG((B, "Key name[%s]" , pkid));

        if( strchr(pp+1,'/') != NULL ){
             /* v1/subscriber/$KEY/$VALUE/subdata/profile.json */
            GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,pkvalue))
        }else{
             /* v1/subscriber/$KEY/$VALUE.json */
            GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,buff))
        }
    }
    else
    {
        /* v1/subscriber/$MSISDN.json */
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "Param[%s]" ,buff))
    }

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;

    if (path==NULL)
    {
        GET_URI_PAGE(pkvalue, sess->format, buff);

        // Not found PKVALUE
        if(pkvalue[0] == '\0'){
            strcpy(error, "Not found PKVALUE");
            return -1;
        }

        if(pkid[0] == '\0'){
            /* v1/subscriber/$MSISDN.json */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,msisdn=%s,dc=MSISDN,dc=C-NTDB", pkvalue, pkvalue);
            strcpy(instance->default_base_dn, base_dn);
        }else{
            /* v1/subscriber/$KEY/$VALUE.json */
            sprintf(error, "Not support this identity[%s]", pkid);
            return -1;
        }

        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
        // Create rdn
        vlist = NULL;
        LBER_valuelist_add(&vlist, pkvalue, NULL);
        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &alist, obj_class)!=0) return -1;

        if(!obj_class[0]){
            // Create objectClass
            vlist = NULL;
            LBER_valuelist_add(&vlist, "gupSubProfile", NULL);
            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
            strcpy(instance->object_class, vlist->value);
        }else{
            strcpy(instance->object_class, obj_class);
        }

        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        //SDF_FREE(path);
        return 0;
    }else{
        /* /v1/subscriber/$KEY/$VALUE/subdata/profile.json */

        // Create Path
        dn[0] = '\0';
        buff[0] = '\0';
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        SDFLOG_DEBUG((B, "==>DN#1 :%s", dn))
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        //GET_URI_FIELDS(buff);
        //GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        sprintf(rdn_name, "%s", path->param);
        sprintf(rdn_value, "%s", path->value);
        strcat(buff, dn);
        SDFLOG_DEBUG((B, "==>buff :%s", buff))
        strcpy(dn, buff);
        SDFLOG_DEBUG((B, "==>DN#2 :%s", dn))
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        if ( pkid[0] == '\0' && pkvalue[0] == '\0' ){
            sprintf(error, "Invalid KEY_NAME or VALUE_NAME");
            return -1;
        }

        char root_dn[LDAP_MAX_BASE_DN];
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME");
            return -1;
        }

        sprintf(base_dn, "%sds=gup,subdata=services,%s", dn, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

        // Create rdn
        SDFLOG_DEBUG((B, "rdn [%s]=[%s]", rdn_name, rdn_value))
        vlist = NULL;
        LBER_valuelist_add(&vlist, rdn_value, NULL);
        LBER_attrlist_add(&alist, rdn_name, vlist, NULL);

//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &alist, obj_class)!=0) return -1;

        if(!obj_class[0]){
            SDFLOG_DEBUG((B, "ObjectClass[%s]", obj_class))
            // Create objectClass
            if(get_objectClass(rdn_name, obj_class) != 0){
                sprintf(error, "Not found objectClass");
                return -1;
            }

            vlist = NULL;
            LBER_valuelist_add(&vlist, obj_class, NULL);
            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
            strcpy(instance->object_class, vlist->value);
        }else{
            strcpy(instance->object_class, obj_class);
        }

        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

static int af_gen_uid(AFINSTANCE *instance,char *uid){
    static char func[] = "af_gen_uid";
    char buffer[1024];
    unsigned int key_identity;

    // UID : "66:time_prefix[3]:time_hash[10]"
    HASH_COMPUTE(instance->key_uid_name,strlen(instance->key_uid_name),key_identity);
    SDFLOG_DEBUG((B, "Identity key [%s] -> [%u]", instance->key_uid_name, key_identity))
    sprintf(buffer, "%lu%u", time(NULL), key_identity);
    HASH_COMPUTE(buffer,strlen(buffer),key_identity);
    SDFLOG_DEBUG((B, "Identity uid [%s] -> [%u]", buffer, key_identity))
    sprintf(uid,"66%.*s%010u",3,buffer,key_identity);
    return 0;
}


int af_regen_uid(AFINSTANCE *instance, char *uid){
    static char func[] = "af_regen_uid";

    if(instance->index_list[UID] != NULL && instance->index_list[UID]->vals->len > 0){
        strcpy(instance->key_uid_name, instance->index_list[UID]->vals->value);
        af_gen_uid(instance, uid);
        return 0;
    }else{
        SDFLOG_FATAL((B, "uid is null"))
        return -1;
    }
}

int getUidFromString(char *uid, char *bstring, int blen){
    int len = 0;
    char *p = NULL,*pp = NULL;

    UNUSED(blen);
    p = bstring;
    if((p=strstr(bstring,"uid="))==NULL){
        return -1;
    }
    p+=4;
    pp = p;
    if((p = strstr(p,",")) == NULL){
        return -1;
    }

    len = (int)(p-pp)-1;
    memcpy(uid,pp,p-pp-1);
    uid[len] = 0;

    return 0;
}


static int
get_baseDN(char *alias_type, char *alias_value, char *base_dn){

    if( STRCASEEQ(alias_type, "msisdn") ){
        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=MSISDN,dc=C-NTDB", alias_type, alias_value);
    }else if( STRCASEEQ(alias_type, "imsi") ){
        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=IMSI,dc=C-NTDB",
                alias_type,
                alias_value);
    }else if( STRCASEEQ(alias_type, "publicId") ){
        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=IMPU,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "privateId") ){
        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=IMPI,dc=C-NTDB", alias_type, alias_value);
    }else if( STRCASEEQ(alias_type, "email") ){

        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=EMAIL,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "partnerId") ){

        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=PARTNERID,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "baId") ){

        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=BA,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "caId") ){

        // Create BaseDNs
        sprintf(base_dn, "%s=%s,dc=CA,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "deviceId") ){

        // Create BaseDN
        sprintf(base_dn, "%s=%s,dc=DEVICE,dc=C-NTDB", alias_type, alias_value);

    }else if( STRCASEEQ(alias_type, "UID") ){

        // Create BaseDN
        sprintf(base_dn, "%s=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", alias_type, alias_value);

    }else{
        return -1;
    }

    return 0;
}

static int
ldap_print_object(LDAP_OBJECT *obj){
    static char func[] = "ldap_print_object";
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist = NULL;
    LDAP_OBJECT *tmp = obj;

    while(tmp){
        SDFLOG_DEBUG((B, "###<<OBJCLASS [%s]>>###", tmp->object_class));
        SDFLOG_DEBUG((B, "+++<<DN [%s]>>+++", tmp->name));
        alist = tmp->alist;
        while(alist){
            SDFLOG_DEBUG((B, "ATTR [%s]", alist->name))
                    vlist = alist->vals;
            while(vlist){
                SDFLOG_DEBUG((B, "----> [%s]", vlist->value))
                        vlist = vlist->next;
                if(vlist == alist->vals){
                    break;
                }
            }
            alist = alist->next;
            if(alist == tmp->alist){
                break;
            }
        }
        tmp = tmp->next;
        if(tmp == obj){
            break;
        }
    }
    return 0;

}

int cmp_version(const void *a, const void *b){
    return strcmp((const char*)b,(const char*)a);   //greater sort
}

static int
amf_get_last_version(LDAP_OBJECT *obj_list, char *last_version, double threshold,char *error){

    static char func[] = "amf_get_last_version";
    LDAP_OBJECT *tmp = NULL;
    BER_ATTRLIST *alist = NULL;
    int i = 0, r = 0;
    char versions[16][64];
    char ver[16];
    char creationDate[48];
    char buff[128];

    if( obj_list == NULL ){
        strcpy(error, "No Package available");
        return -1;
    }

    tmp = obj_list;
    while( tmp != NULL ){
        creationDate[0] = '\0';
        ver[0] = '\0';
        alist = tmp->alist;
        while( alist != NULL )
        {
            SDFLOG_DEBUG((B, "alist:%s", alist->name));
            if( STRCASEEQ(alist->name,"version") ){
                strcpy(ver, alist->vals->value);
            }else if( STRCASEEQ(alist->name, "creationDate") ){
                strcpy(creationDate, alist->vals->value);
            }

            alist = alist->next;
            if(alist == tmp->alist)
                break;
        }

        if ( creationDate[0] != '\0' && ver[0] != '\0'){
            r = sprintf(versions[i],"%s", ver);
            versions[i][r] = '\0';
            strcpy(&versions[i][r+1], creationDate);
            i++;
        }

        tmp = tmp->next;
        if(tmp == obj_list)
            break;
    }

    if( i <= 0){
        strcpy(error, "No SID version available");
        return -1;
    }
    qsort(versions, i, sizeof(versions[0]), cmp_version);

    time_t cur = time(NULL);
    struct tm tm;
    memset(&tm,0,sizeof(struct tm));
    int j = 0;
    for(r = 0; r < i; r++){
        j = (int)strlen( versions[r]);
        strcpy(buff, &versions[r][j+1]);
        strptime(buff,"%Y%m%d%H%M%S+0700", &tm); //creationtime formate = yyyyddmmHHMMSS
        time_t ref = mktime(&tm);

        if( difftime(cur,ref) >= threshold ){
            if(last_version[0] == '\0'){        //User NOT specific version of SID
                strcpy(last_version, versions[r]);
                return 0;
            }else{
                if( STREQ(last_version, versions[r]) ){//User specific version of SID
                    strcpy(last_version, versions[r]);
                    return 0;
                }
            }

        }
    }
    strcpy(error, "No lastest SID version available, Creation time is less window time");
    return -1;
}

static int
amf_get_result_state(LDAP_CLNT *lc, char *result_state, char *error){
#ifdef SDF_ONDEBUG
    static char func[] = " amf_get_result_state";
#endif
    LDAP_OBJECT *obj = NULL;
    BER_VALLIST *vlist = NULL;

    /* Check Result state */
    LBER_object_decode(lc, &obj, error);

#ifdef SDF_ONDEBUG
    ldap_print_object(obj);
#endif

    if( (vlist = ldap_get_attrval(obj, "counterPackInfo")) != NULL){
        //got vlist
#ifdef SDF_ONDEBUG
        SDFLOG_DEBUG((B, "attrval [%s]", vlist->value))
#endif
        if(amf_get_field_attrval(vlist->value, result_state, 5,',') != 0){
            ldap_object_free(obj);
            strcpy(error, "Cannot get result state form ManageCounterResponse");
            return -1;
        }
    }
    ldap_object_free(obj);
    return 0;
}

static int ldap_counter_object(LDAP_OBJECT *object_list, char *object_class){
    int counter = 0;
    LDAP_OBJECT *t_obj = NULL;
    t_obj = object_list;

    while( t_obj != NULL ){
        /* Make sure that is the same class */
        if( object_class != NULL && STRCASEEQ(t_obj->object_class, object_class) ){
            counter ++;
        }else{
            counter ++;
        }
        t_obj = t_obj->next;
        if( t_obj == object_list){
            break;
        }
    }
    return counter;
}

#define LINKEDLIST_HAS_NEXT(f,t){   \
    t = t->next;                    \
    if(t == f){                     \
        break;                      \
    }                               \
}                                   \

/* This function use O(n) for best case and O(n)*AMF_MAX_PACK_NO for worst case*/
/* TODO: Use array sorting (store all object to array than sort it)
 */
static int
amf_find_available_product_no(LDAP_OBJECT *obj_list, int total_pack, int *product_no, char *error){
    static char func[] = "amf_find_available_product_no";
    LDAP_OBJECT *t_obj = NULL;
    int p_n = *product_no, r = 0, i = 0, idx_pkg=0;
    int max_rang_product = d02global.conf_warm.max_package - d02global.conf_warm.min_package;

    /* store package to array */
    int array_total_pack[total_pack];

    t_obj = obj_list;
    while( t_obj != NULL ){
        if( t_obj->alist != NULL && STRCASEEQ(t_obj->alist->name, "amfProductNo") ){
            if(t_obj->alist->vals != NULL){
                array_total_pack[i++] = atoi(t_obj->alist->vals->value);
            }else{
                SDFLOG_WARN((B, "Attr[%s] NOT have value", t_obj->alist->name ))
            }
        }else{
            SDFLOG_WARN((B, "Object class[%s] NOT have attribute", t_obj->name ))
        }

        t_obj = t_obj->next;
        if( t_obj == obj_list ){
            break;
        }
    }

    if(i <= 0){
        /* Make sure this productNo is not in skipPackage list */
        for( ; r < max_rang_product ; r++){
            if( bs(d02global.conf_warm.skip_pacakge, d02global.conf_warm.skip_len, p_n) < 0 ){
                *product_no = p_n;
                return 0;
            }else{
                p_n++;
                p_n = (p_n > d02global.conf_warm.max_package)?d02global.conf_warm.min_package:p_n; // rotate product number
            }
        }
        strcpy(error, "Package is full");
        return -1; /*No package avalaible */
    }

    /* Sort Package */
    qsort(array_total_pack, i, sizeof(int), cmp_int);

    /* BigO(max_rang_product * logN(i) * logN(skip_len)) */
    for ( ; r < max_rang_product ; ){
        if( (idx_pkg = bs(array_total_pack, i, p_n)) < 0
                && bs(d02global.conf_warm.skip_pacakge, d02global.conf_warm.skip_len, p_n) < 0){
            /* This package number able to use */
            *product_no = p_n;
            return 0;
        }else{
            p_n++;
            p_n = (p_n > d02global.conf_warm.max_package)?d02global.conf_warm.min_package:p_n; // rotate product number
            r++;
        }
    }
    strcpy(error, "Package is full");
    return -1;
}

static int
amf_store_sid_template(LDAP_OBJECT **obj_list, CRT_PKG_ST *amf){
    LDAP_OBJECT *tmp_obj = NULL, *new_obj = NULL;
    tmp_obj = *obj_list;
    while(tmp_obj){
            if( STREQ(tmp_obj->object_class, "sidProductOfferVersion") ){
                LINKEDLIST_REMOVE(*obj_list, tmp_obj);
                LINKEDLIST_APPEND(amf->counter_pack, tmp_obj);
            }else if( STREQ(tmp_obj->object_class, "sidCounterTemplate") ){
                LINKEDLIST_REMOVE(*obj_list, tmp_obj);
                LINKEDLIST_APPEND(amf->counter_entry, tmp_obj);
            }else{
                LINKEDLIST_REMOVE(*obj_list, tmp_obj);
                LINKEDLIST_APPEND(new_obj, tmp_obj);
            }
            tmp_obj = *obj_list;
    }
    *obj_list = new_obj;
    return 0;
}

static int ldap_object_free(LDAP_OBJECT *obj){
    LDAP_OBJECT *tmp = NULL;
    tmp = obj;
    while( tmp != NULL ){
        if( tmp->alist != NULL ){
            FREE_BER_ATTRLIST(tmp->alist);
            tmp->alist = NULL;
        }

        if(tmp->next == NULL && tmp->prev == NULL){
            SDF_FREE(tmp);
            break;
        }

        LINKEDLIST_REMOVE(obj, tmp);
        SDF_FREE(tmp);
        tmp = obj;
    }
    return 0;
}


static int crt_pkg_amf_free(CRT_PKG_ST *amf){
    if( amf == NULL ){
        return -1;
    }

    if( amf->counter_entry != NULL){
        ldap_object_free(amf->counter_entry);
        amf->counter_entry = NULL;
    }

    if( amf->counter_pack != NULL){
        ldap_object_free(amf->counter_pack);
        amf->counter_pack = NULL;
    }

    if( amf->publicIds != NULL){
        ldap_object_free(amf->publicIds);
        amf->publicIds = NULL;
    }

    if( amf->privateIds != NULL){
        ldap_object_free(amf->privateIds);
        amf->privateIds = NULL;
    }

    if( amf->privateIds_bckp != NULL){
        ldap_object_free(amf->privateIds_bckp);
        amf->privateIds_bckp = NULL;
    }

    if( amf->publicIds_bckp != NULL){
        ldap_object_free(amf->publicIds_bckp);
        amf->publicIds_bckp = NULL;
    }

    SDF_FREE(amf);
    return 0;
}


/* Stupid coding */
static int
amf_gen_attr_counter_pack(AFINSTANCE *instance, char *error){
    //Merg all user input into sid template.
#ifdef SDF_ONDEBUG
    static char func[] = "amf_gen_attr_counter_pack";
#endif

#define FREE_ATTR(_alist)                                       \
    do{                                                         \
        BER_VALLIST *t_val;                                     \
        t_val = _alist->vals;                                   \
        while(t_val != NULL){                                   \
           LINKEDLIST_REMOVE(_alist->vals, t_val);              \
           SDF_FREE(t_val);                                     \
           t_val = _alist->vals;                                \
        }                                                       \
        SDF_FREE(_alist);                                       \
}while(0);


    BER_ATTRLIST *alist = NULL, *new_alist = NULL, *t_alist = NULL;
    if( instance->amf->counter_pack == NULL){
        strcpy(error, "No counter package available");
        return -1;
    }
    //exclude parameter
    alist = instance->amf->counter_pack->alist;

    while(alist){
#ifdef SDF_ONDEBUG
        SDFLOG_DEBUG((B,"attr name[%s]", alist->name));
#endif
        LINKEDLIST_REMOVE(instance->amf->counter_pack->alist, alist);
        if( STRCASEEQ(alist->name, "version") ){
            if(instance->index_list[VERSION] == NULL){
                instance->index_list[VERSION] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[VERSION]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[VERSION]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "priority") ){
            if(instance->index_list[PRIORITY] == NULL){
                instance->index_list[PRIORITY] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[PRIORITY]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[PRIORITY]);
                FREE_ATTR(alist);
            }
        }
        else if( STRCASEEQ(alist->name, "ds3politeDegree")){
            if(instance->index_list[DS3_POLITE_DEGREE] == NULL){
                instance->index_list[DS3_POLITE_DEGREE] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_POLITE_DEGREE]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_POLITE_DEGREE]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "expiryGracePeriod")){
            if(instance->index_list[EXPIRY_GRACE_PERIOD] == NULL){
                instance->index_list[EXPIRY_GRACE_PERIOD] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[EXPIRY_GRACE_PERIOD]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[EXPIRY_GRACE_PERIOD]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "preExpiryThr")){
            if(instance->index_list[PREEXPIRY_THR] == NULL){
                instance->index_list[PREEXPIRY_THR] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[PREEXPIRY_THR]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[PREEXPIRY_THR]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "postExpiryThr")){
            if(instance->index_list[POSTEXPIRY_THR] == NULL){
                instance->index_list[POSTEXPIRY_THR] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[POSTEXPIRY_THR]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[POSTEXPIRY_THR]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "lifecycleUnit")){
            if(instance->index_list[LIFECYCLE_UNIT] == NULL){
                instance->index_list[LIFECYCLE_UNIT] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[LIFECYCLE_UNIT]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[LIFECYCLE_UNIT]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "lifecycleNo")){
            if(instance->index_list[LIFECYCLE_NO] == NULL){
                instance->index_list[LIFECYCLE_NO] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[LIFECYCLE_NO]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[LIFECYCLE_NO]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "recurringLifecycle")){
            if(instance->index_list[RECURRING_LIFECYCLE] == NULL){
                instance->index_list[RECURRING_LIFECYCLE] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[RECURRING_LIFECYCLE]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[RECURRING_LIFECYCLE]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "ds3timeResolution")){
            if(instance->index_list[DS3_TIME_RESOLUTION] == NULL){
                instance->index_list[DS3_TIME_RESOLUTION] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_TIME_RESOLUTION]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_TIME_RESOLUTION]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "counterRollover")){
            if(instance->index_list[COUNTER_ROLLOVER] == NULL){
                instance->index_list[COUNTER_ROLLOVER] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[COUNTER_ROLLOVER]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[COUNTER_ROLLOVER]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "refillStopExt")){
            if(instance->index_list[REFILL_STOP_EXT] == NULL){
                instance->index_list[REFILL_STOP_EXT] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[REFILL_STOP_EXT]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[REFILL_STOP_EXT]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "ds3packageDesc")){
            if(instance->index_list[DS3_PACKAGE_DESC] == NULL){
                instance->index_list[DS3_PACKAGE_DESC] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_PACKAGE_DESC]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_PACKAGE_DESC]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "ds3offlineNotifPolicyControl")){
            if(instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL] == NULL){
                instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "ds3recurringPolicyControl")){
            if(instance->index_list[DS3_RECURRING_NOTIFY_POLICY_CONTROL] == NULL){
                instance->index_list[DS3_RECURRING_NOTIFY_POLICY_CONTROL] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_RECURRING_NOTIFY_POLICY_CONTROL]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_RECURRING_NOTIFY_POLICY_CONTROL]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "ds3CostCode")){
            if(instance->index_list[DS3_COST_CODE] == NULL){
                instance->index_list[DS3_COST_CODE] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[DS3_COST_CODE]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[DS3_COST_CODE]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "persistCycle")){
            if(instance->index_list[PERSIST_CYCLE] == NULL){
                instance->index_list[PERSIST_CYCLE] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[PERSIST_CYCLE]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[PERSIST_CYCLE]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "offerState")){
            if(instance->index_list[OFFER_STATE] == NULL){
                instance->index_list[OFFER_STATE] = alist;
                //hard reset
                alist->len = sprintf(alist->name,"%s","counterState");
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                //hard reset
                instance->index_list[OFFER_STATE]->len = sprintf(instance->index_list[OFFER_STATE]->name,"%s","counterState");
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[OFFER_STATE]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[OFFER_STATE]);
                FREE_ATTR(alist);
            }
        }else if( STRCASEEQ(alist->name, "sponsorId")){
            if(instance->index_list[SPONSOR_ID] == NULL){
                instance->index_list[SPONSOR_ID] = alist;
                LINKEDLIST_APPEND(new_alist, alist);
            }else{
                LINKEDLIST_REMOVE(instance->alist,instance->index_list[SPONSOR_ID]);
                LINKEDLIST_APPEND(new_alist, instance->index_list[SPONSOR_ID]);
                FREE_ATTR(alist);
            }
        }else{
            FREE_ATTR(alist);
        }
        alist = instance->amf->counter_pack->alist;
    }


    //Move from
    alist = instance->alist;
    int reheader = 0;
    while(alist != NULL)
    {
            reheader = 0;
            if(STRCASEEQ(alist->name, "identityName")   ||
               STRCASEEQ(alist->name, "identityValue")  ||
               STRCASEEQ(alist->name, "privateId")      ||
               STRCASEEQ(alist->name, "publicId")       ||
               STRCASEEQ(alist->name, "sendSMS")){
                alist = alist->next;
            }else{
                t_alist  = alist->next;
                if(instance->alist == alist) reheader = 1;
                LINKEDLIST_REMOVE(instance->alist, alist);
                LINKEDLIST_APPEND(new_alist, alist);
                alist = t_alist;
            }

            if((alist == instance->alist && reheader != 1)|| instance->alist == NULL){
                break;
            }
    }

    instance->amf->counter_pack->alist = new_alist;
    return 0;
}

static int
amf_init_accountIds(BER_VALLIST *p_vlist,
                  LDAP_OBJECT **obj,
                  AFINSTANCE *instance,
                  int ID_types,            /*PrivateId|PublicId */
                  char *error){
    static char func[] = "amf_init_accountIds";
    BER_VALLIST *vlist = NULL;
    LDAP_OBJECT *t_obj = NULL, *n_obj = NULL;
    char buff[LDAP_MAX_ATTR_NAME_SIZE];
    int blen = 0;
    int reheader = 0;

    if(p_vlist == NULL){
        strcpy(error, "values was empty");
        SDFLOG_WARN((B, "values was empty"))
        return 0;
    }

    t_obj = *obj;
    while( t_obj != NULL ){
        n_obj = t_obj->next;
        vlist = p_vlist;
        reheader = 0;
        while( vlist != NULL ){
            if( ID_types == PRIVATEIDLIST ){
                blen = sprintf(buff, "privateId=%s", vlist->value);
                if( strncmp( buff, t_obj->name, blen) == 0 ){
                    if(*obj == t_obj) reheader = 1; //remove header
                    LINKEDLIST_REMOVE(*obj, t_obj);
                    LINKEDLIST_APPEND(instance->amf->privateIds,t_obj);
                    break;
                }
            }else if( ID_types == PUBLICIDLIST ){
                blen = sprintf(buff, "publicId=%s", vlist->value);
                if( strncmp( buff, t_obj->name, blen) == 0 ){
                    if(*obj == t_obj) reheader = 1; //remove header
                    LINKEDLIST_REMOVE(*obj, t_obj);
                    LINKEDLIST_APPEND(instance->amf->publicIds,t_obj);
                    break;
                }
            }
            vlist = vlist->next;
            if(vlist == p_vlist ){
                break;
            }
        }

        t_obj = n_obj;
        if( (t_obj == *obj && reheader != 1) || *obj == NULL){
            break;
        }
    }
    return 0;
}
/*
 * obj->name = "privateId="sip:narongsm@ais.co.th,subdata=profile,ds=gup"
 */

static int amf_find_accountIds(LDAP_OBJECT **obj, AFINSTANCE *instance, char *prvt_id, char *error){

    if( prvt_id == NULL ){
        ldap_object_free(*obj);
        strcpy(error, "PrivateId was empty.");
        return -1;
    }

    LDAP_OBJECT *t_obj = NULL;
    LDAP_OBJECT *n_obj = NULL;
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist = NULL;
    char buff[LDAP_MAX_ATTR_NAME_SIZE];
    int blen = 0;
    blen = sprintf(buff, "privateId=%s", prvt_id);

    /* find FBB privateIds */
    t_obj = *obj;
    while( t_obj != NULL ){
        n_obj = t_obj->next;
        if( strncmp(t_obj->name, buff, blen) == 0 ){
            LINKEDLIST_REMOVE(*obj, t_obj);
            LINKEDLIST_APPEND(instance->amf->privateIds, t_obj);
            alist = t_obj->alist;

            /* User specific publicId */
            if ( instance->index_list[IMPU] && instance->index_list[IMPU]->vals){
                vlist = instance->index_list[IMPU]->vals;
                break;
            }

            while( alist != NULL){

                if( strcmp(alist->name, "publicIds") == 0){
                    vlist = alist->vals;                    //get all publicIds
                    break;
                }
                alist = alist->next;
                if(alist == t_obj->alist){
                    break;
                }
            }
            break;
        }

        t_obj = n_obj;
        if( t_obj == *obj || *obj == NULL || vlist != NULL){
            break;
        }
    }


    /* find publicIds under FBB id*/
    if(vlist == NULL){
        ldap_object_free(*obj);
        return 0;
    }

    amf_init_accountIds(vlist, obj, instance, PUBLICIDLIST, error);

    /* find all privatIds under publicId */
    t_obj = instance->amf->publicIds;
    while( t_obj != NULL ){
        alist = t_obj->alist;
        while( alist != NULL ){
            if( strcasecmp(alist->name, "privateIds") == 0){
                amf_init_accountIds(alist->vals, obj, instance, PRIVATEIDLIST, error);
            }
            alist = alist->next;
            if( alist == t_obj->alist ){
                break;
            }
        }

        t_obj = t_obj->next;
        if( t_obj == instance->amf->publicIds ){
            break;
        }
    }
    ldap_object_free(*obj);
    return 0;
}

static int
amf_gen_attr_counter_entry(CRT_PKG_ST *amf, BER_ATTRLIST **alist,char *entry, char *error){

#define FIND_ENTRY(_DST, _SRC){     \
    char *pp = NULL,*p = NULL;      \
    pp = strstr(_SRC, "counterId=");\
    p = strchr(pp+10, ',');         \
    memcpy(_DST, pp, p-pp);         \
    _DST[p-pp] = 0;                 \
}

    LDAP_OBJECT *tmp = NULL;
    BER_ATTRLIST *t_alist = NULL;
    BER_ATTRLIST *n_alist = NULL;
    if(amf->counter_entry == NULL){
        strcpy(error, "Counter entry object was null");
        return -1;
    }

    tmp = amf->counter_entry;
    if(tmp->alist == NULL){
        strcpy(error, "Attribute was empty");
        return -1;
    }
    if(tmp->name[0] == 0){
        strcpy(error, "Entry was empty");
        return -1;
    }

    FIND_ENTRY(entry, tmp->name);

    LINKEDLIST_REMOVE(amf->counter_entry,tmp);

    /* exclude attribute */
    t_alist = tmp->alist;

    while( t_alist != NULL ){
        if( STRCASEEQ(t_alist->name, "priority") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterType") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterValueType") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterConsumeVector") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterLowerLimit") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterUpperLimit") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterThreshold") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterUnit") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterValue") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "replenishValue") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "firstModifiedTime") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "lastModifiedTime") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "amfReserve") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "amfReserveExpiry") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "ds3notificationPolicyControl") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "ds3deselectPolicyControl") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "sponsorId") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "appServProviderId") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "personalization") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else if ( STRCASEEQ(t_alist->name, "counterState") ){
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            LINKEDLIST_APPEND(n_alist, t_alist);
        }else{
            LINKEDLIST_REMOVE(tmp->alist, t_alist);
            FREE_BER_VALUELIST(t_alist->vals);
            t_alist->vals = NULL;
            free(t_alist);
        }
        t_alist = tmp->alist;
    }


    *alist = n_alist;            //move all attr under counter entry
    tmp->alist = NULL;
    SDF_FREE(tmp);

    if(amf->counter_entry == NULL){ //The last entry
        return 1;
    }
    return 0;
}

static int
amf_get__product_number(LDAP_CLNT *lc, int *product_number, char *err){
    static char func[] = "amf_get__product_number";
    LDAP_OBJECT *my_obj = NULL, *tmp_obj = NULL;

    *product_number = d02global.conf_warm.min_package;

    if(LBER_object_decode(lc, &my_obj, err) != 0){
        SDFLOG_ERROR((B, "%s", err))
                return -1;
    }

    // print out ldap_print_object
    ldap_print_object(my_obj);

    //find product_number
    tmp_obj = my_obj;

    //find amfSubProfile Object
    while( tmp_obj != NULL){
        if( STRCASEEQ(tmp_obj->object_class, "amfSubProfile") ){
            break;
        }
        tmp_obj = tmp_obj->next;
        if( tmp_obj == my_obj ){
            SDFLOG_WARN((B, "Not found amfSubProfile object, use amfProductRunningNo=%d", *product_number))
            break;
        }
    }

    if(tmp_obj != NULL && strcmp("amfSubProfile", tmp_obj->object_class) == 0)
    {   BER_ATTRLIST *alist;
        alist = tmp_obj->alist;
        while(alist){
            if( STREQ(alist->name, "amfProductRunningNo")){
                if( alist->vals->value[0] != 0){
                    SDFLOG_DEBUG((B, "amfProductRunningNo=%s", alist->vals->value))
                    *product_number = atoi(alist->vals->value);
                    ldap_object_free(my_obj);
                    return 0;
                }
            }
            alist = alist->next;
            if(alist == tmp_obj->alist){
                break;
            }
        }
    }
    SDFLOG_DEBUG((B, "amfProductRunningNo=%d", *product_number))
    ldap_object_free(my_obj);
    return 1;   //return default package
}

#define AMF_CREATE_RESPONSE(lc, rc, err){       \
    lc->result_code = rc;                       \
    strcpy(lc->diagnosticMessage, err);         \
    }

static BER_VALLIST *
ldap_get_attrval(LDAP_OBJECT *obj, char *attr){
    if( obj == NULL) return NULL;
    BER_ATTRLIST *alist = NULL;
    alist = obj->alist;
    while(alist){
            if( STRCASEEQ(alist->name, attr) ){
                return alist->vals;
            }
            alist = alist->next;
            if(alist == obj->alist)
                break;
    }
    return NULL;
}

static int
amf_get_field_attrval(char *src,char *dst, int field, char deli){

        char *ps = src;
        char *pe = NULL;
        int i = 0;
        int len = 0;
        while( (pe = strchr(ps,(int)deli)) != NULL ){
            if( i == field){            //hit filed
                len = (int)(pe - ps);   //calculate size
                memcpy(dst, ps, len);   //copy field
                dst[len] = '\0';        //null terminate
                return 0;               //found field
            }
            ps = pe+1;                  //move to next token
            ++i;
        }
        // last field
        if(ps != NULL && i == field ){
            strcpy(dst, ps);           //warning: ps must be not null
            return 0;
        }
return -1;
}


int af_process_createPackage_method(LDAP_CLNT *lc, MWRAPPER *mw, char *error){

    static char func[] = "af_process_createPackage_method";

#define AMF_STORE_ROLLBACK(_rcode,_rllbck){             \
    strcpy(mw->instance->amf->rollback_desc,_rllbck);   \
    mw->instance->amf->rollback_result_code = _rcode;   \
}
    /* Declear local variable */
    int main_state = 0;
    int sub_state = 0;
    int use_extend = 0;
    int tid = 0;
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    Control *control=NULL;
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    BER *b_attrs = NULL;
    BER *ber = NULL;

    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Instance may be NULL");
        return CRT_PKG_IDLE;
    }

    /* Reconize state */
    main_state = mw->instance->main_state;
    sub_state = mw->instance->sub_state;

    LDAP_CREATE_CONTROL();
    
    switch ( main_state ){
        case CRT_PKG_QUERY_RUNNING_NUMBER:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_RUNNING_NUMBER >>"));
             switch (lc->result_code){
                 case LDAP_RESULT_SUCCESS:
                 case LDAP_RESULT_NO_SUCH_OBJECT :
                 {
                        int product_number = 0;

                        //Check wheaher amfProductRunningNo is available or not?
                        mw->instance->amf->runningNo_exist = amf_get__product_number(lc, &product_number,error);

                        if(mw->instance->amf->runningNo_exist == -1){
                            SDFLOG_ERROR((B,"Cannot get amfProductRunningNumber."));
                            main_state = CRT_PKG_IDLE;
                            break;
                        }

                        // product_number = amfProductRunningNumber + 1;
                        // if prouct number more then 4096 than is set to default(4000)
                        if( mw->instance->amf->runningNo_exist == 0 ){
                            mw->instance->amf->product_old_numer = product_number;
                            product_number++;
                        }
                        mw->instance->amf->product_number = (product_number > d02global.conf_warm.max_package)?d02global.conf_warm.min_package:product_number;

                        // Create BaseDn
                        // DN := amfProductNo=$product_number,subdata=profile,ds=amf,subdata=services,uid=$uid,ds=SUBSCRIBER,o=AIS,dc=C-NTDB
                        get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                   mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                   root_dn);

                        BER *b_attrs = NULL;
                        char attrs[2][128];
                        strcpy(attrs[0],"amfProductNo");
                        attrs[1][0] = '\0';

                        LDAP_gen_ber_string(attrs, &b_attrs, error);
                        sprintf(base_dn,"subdata=profile,ds=amf,subdata=services,%s",
                                root_dn);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE,
                                                      &ber,
                                                      base_dn,
                                                      "one",
                                                      "amfCounterPack",
                                                      b_attrs->berval,
                                                      b_attrs->len,
                                                      LDAP_DEREF_ALWAYS,
                                                      control,
                                                      error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        main_state = CRT_PKG_QUERY_PRODUCT_NUMBER;
                 }
                     break;
                 default :
                     main_state = CRT_PKG_IDLE;
                     break;
             }
            break;
        case CRT_PKG_QUERY_PRODUCT_NUMBER:
            /* Check wheather amfProductNo was found or not */
            if( lc->result_code ==  LDAP_RESULT_SUCCESS ){
                SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_PRODUCT_NUMBER >>"));
                /* increment amfProductNo by 1 and try to search next */
                /* use ldap search */

                LDAP_OBJECT *obj = NULL;
                if ( LBER_object_decode(lc, &obj, error) != 0){
                    SDFLOG_ERROR((B, "Cannot decode amfPackageNo object[%s].", error))
                    main_state = CRT_PKG_IDLE;
                    AMF_CREATE_RESPONSE(lc, LDAP_RESULT_NO_SUCH_OBJECT, error);
                    break;
                }
                int total_pack = ldap_counter_object(obj, NULL);
                if ( total_pack >= d02global.conf_warm.limit_package ){
                    strcpy(error, "Package was exceed");
                    SDFLOG_ERROR((B, "%s", error))
                    main_state = CRT_PKG_IDLE;
                    AMF_CREATE_RESPONSE(lc, LDAP_RESULT_PACKAGE_EXCEEDED, error);
                    ldap_object_free(obj);
                    break;
                }

                if( amf_find_available_product_no(obj, total_pack, &(mw->instance->amf->product_number), error) != 0 ){
                    SDFLOG_ERROR((B, "No available product number.[%s]", error))
                    main_state = CRT_PKG_IDLE;
                    AMF_CREATE_RESPONSE(lc, LDAP_RESULT_NO_SUCH_OBJECT, error);
                    ldap_object_free(obj);
                    break;
                }
                ldap_object_free(obj);
                // product_number = amfProductRunningNumber + 1;
                // if prouct number more then 4096 than is set to default(4000)
                //mw->instance->amf->product_number = mw->instance->amf->product_number + 1;
                //mw->instance->amf->product_number = (mw->instance->amf->product_number > 4095)?4000:mw->instance->amf->product_number;

                // Create BaseDn
                // DN := amfProductNo=$product_number,subdata=profile,ds=amf,subdata=services,uid=$uid,ds=SUBSCRIBER,o=AIS,dc=C-NTDB
                get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                           mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                           root_dn);
                sprintf(base_dn,"amfProductNo=%d,subdata=profile,ds=amf,subdata=services,%s", mw->instance->amf->product_number, root_dn);
                SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
                tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_ALWAYS, control, error);
                if (control != NULL) SDF_FREE(control);
                
                main_state = CRT_PKG_QUERY_PRODUCT_NUMBER;
                break;
            }else if (lc->result_code == LDAP_RESULT_NO_SUCH_OBJECT){
                /* Found unuse production number, continue next state */
                    SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_PRODUCT_OFFERING_VER >>"));
                    /* continue find out Version of sidProductOfferVersion */
                    /* use ldap search */

                    sprintf(base_dn,"productOffer=%s,o=productCatalog,o=sid,o=nss,o=services,o=AIS,dc=C-NTDB",
                            mw->instance->index_list[PRODUCT_OFFER]->vals->value);
                    SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));

                    BER *b_attrs = NULL;
                    char attrs[3][128];

                    strcpy(attrs[0],"version");
                    strcpy(attrs[1],"creationDate");
                    attrs[2][0] =  '\0';

                    LDAP_ber_free(lc->rber);
                    lc->rber = NULL;

                    LDAP_gen_ber_string(attrs, &b_attrs, error);
                    tid = LDAP_gen_search_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  "one",
                                                  "*",
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  LDAP_DEREF_ALWAYS,
                                                  control,
                                                  error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    main_state = CRT_PKG_QUERY_LASTEST_OFFERING_VER;
                    break;
            }else{
                //exception ocured
                main_state = CRT_PKG_IDLE;
                break;
            }
        case CRT_PKG_QUERY_PRODUCT_OFFERING_VER:
        case CRT_PKG_QUERY_LASTEST_OFFERING_VER :
        {
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_LASTEST_OFFERING_VER >>"));
            /* continue find out Version of sidProductOfferVersion */
            /* use ldap search */

                LDAP_OBJECT *my_obj = NULL;
                LBER_object_decode(lc,&my_obj, error);
                ldap_print_object(my_obj);

                if( amf_get_last_version(my_obj, mw->instance->amf->version, (double)d02global.conf_warm.sla_crt_pkg, error) != 0 ){
                    SDFLOG_ERROR((B, "%s", error))
                    AMF_CREATE_RESPONSE(lc, LDAP_RESULT_NO_SUCH_OBJECT, error);
                    main_state = CRT_PKG_IDLE;
                    break;
                }
                ldap_object_free(my_obj);

            sprintf(base_dn,"version=%s,productOffer=%s,o=productCatalog,o=sid,o=nss,o=services,o=AIS,dc=C-NTDB",
                    mw->instance->amf->version,
                    mw->instance->index_list[PRODUCT_OFFER]->vals->value);
            SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
            tid = LDAP_gen_search_request(LDAP_LIST_HANDLE,
                                          &ber,
                                          base_dn,
                                          "sub",
                                          "*",
                                          NULL,
                                          0,
                                          LDAP_DEREF_ALWAYS,
                                          control,
                                          error);
            LDAP_ber_free(lc->rber);
            if (control != NULL) SDF_FREE(control);
            lc->rber = NULL;
            main_state = CRT_PKG_ADD_AMF_COUNTER_PACK;
            break;
        }
        case CRT_PKG_ADD_AMF_COUNTER_PACK:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_ADD_AMF_COUNTER_PACK >>"));
            /* Store template and Create New amfProductNumber */
            switch (lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                    /* 1. Store template (Must MERGE template with user data)*/
                    /* 2. select last version of sidProductOfferVersion */
                    /* 3. use LDAP Add amfProductNo */
                    // DN := amfProductNo=$product_number,subdata=profile,ds=amf,subdata=services,uid=$uid,ds=SUBSCRIBER,o=AIS,dc=C-NTDB

                    LDAP_OBJECT *obj = NULL;
                    LBER_object_decode(lc,&obj,error);
                    ldap_print_object(obj);
                    amf_store_sid_template(&obj, mw->instance->amf);
                    ldap_object_free(obj);
                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               root_dn);
                    sprintf(base_dn,"amfProductNo=%d,subdata=profile,ds=amf,subdata=services,%s",
                            mw->instance->amf->product_number,
                            root_dn);

                    vlist = NULL;
                    b_attrs = NULL;

                    if(amf_gen_attr_counter_pack(mw->instance, error)!= 0){
                        SDFLOG_ERROR((B, "Cannot create counterPakage [%s]", error));
                        AMF_CREATE_RESPONSE(lc, LDAP_RESULT_OPERATION_ERROR, error);
                        main_state =  CRT_PKG_IDLE;
                        break;
                    }

                    alist = mw->instance->amf->counter_pack->alist;
#ifdef SDF_ONDEBUG
                    ldap_print_object(obj);
#endif
                    // create rdn
                    // amfProductNo=4000
                    char product_number[16];
                    sprintf(product_number, "%d", mw->instance->amf->product_number);
                    LBER_valuelist_add(&vlist, product_number, error);
                    LBER_attrlist_add(&alist, "amfProductNo", vlist, error);

                    // create objectClass
                    // objectClass=amfCounterPack
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "amfCounterPack", error);
                    LBER_attrlist_add(&alist, "objectClass", vlist, error);

                    LDAP_gen_ber_attrlist(alist, &b_attrs, 0, error);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE,
                                               &ber,
                                               base_dn,
                                               b_attrs->berval,
                                               b_attrs->len,
                                               control,
                                               error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    /* used as previos state */
                    sub_state = CRT_PKG_ADD_AMF_COUNTER_PACK;
                    if( mw->instance->amf->counter_entry == NULL){
                        SDFLOG_WARN((B, "No available Counter Entry"))
                        main_state = CRT_PKG_QUERY_ACCOUT_ID;
                    }else{
                        main_state = CRT_PKG_ADD_AMF_COUNTER_ENTRY;
                    }
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* Not found version of sidProductOfferVersion */
                    SDFLOG_ERROR((B, "No available sidProductOfferVersion"))
                    main_state = CRT_PKG_IDLE;
                    break;
                default :
                    main_state = CRT_PKG_IDLE;
                    break;
            }
            break;
        case CRT_PKG_ADD_AMF_COUNTER_ENTRY:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_ADD_AMF_COUNTER_ENTRY >>"));
            switch (lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                    /* add counterId */

                    char entry[LDAP_MAX_DN_SIZE];
                    int is_last = 0;
                    alist = NULL;
                    if( (is_last = amf_gen_attr_counter_entry(mw->instance->amf,
                                                              &alist,
                                                              entry,
                                                              error)) == -1 ){
                        SDFLOG_ERROR((B, "Cannot create counterEntry [%s]", error));
                        main_state = CRT_PKG_ROLLBACK;
                        AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR,error);
                        FREE_BER_ATTRLIST(alist);
                        goto _crt_pkg_rollback;

                    }

                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               root_dn);
                    sprintf(base_dn,"%s,amfProductNo=%d,subdata=profile,ds=amf,subdata=services,%s",
                            entry,
                            mw->instance->amf->product_number,
                            root_dn);

                    // create objectClass
                    // objectClass=amfCounterEntry
                    vlist = NULL;
                    b_attrs = NULL;
                    LBER_valuelist_add(&vlist, "amfCounterEntry", error);
                    LBER_attrlist_add(&alist, "objectClass", vlist, error);

                    // create version
                    vlist = NULL;
                    b_attrs = NULL;
                    LBER_valuelist_add(&vlist, mw->instance->amf->version, error);
                    LBER_attrlist_add(&alist, "version", vlist, error);

                    // create product offer
                    vlist = NULL;
                    b_attrs = NULL;
                    LBER_valuelist_add(&vlist, mw->instance->index_list[PRODUCT_OFFER]->vals->value, error);
                    LBER_attrlist_add(&alist, "productOffer", vlist, error);

                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE,
                                               &ber,
                                               base_dn,
                                               b_attrs->berval,
                                               b_attrs->len,
                                               control,
                                               error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = CRT_PKG_ADD_AMF_COUNTER_ENTRY;
                    if( is_last ){  // the last countId
                        main_state = CRT_PKG_QUERY_ACCOUT_ID;
                    }else{
                        main_state = CRT_PKG_ADD_AMF_COUNTER_ENTRY;
                    }
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* failed to add amfCounterEntry */
                default :
                    /* No need rollback for add package failed */
                    if( sub_state == CRT_PKG_ADD_AMF_COUNTER_PACK){
                        main_state = CRT_PKG_IDLE;
                        break;
                    }

                    sub_state = CRT_PKG_ADD_AMF_COUNTER_ENTRY;
                    main_state = CRT_PKG_ROLLBACK;
                    AMF_STORE_ROLLBACK(lc->result_code,"")
                    goto _crt_pkg_rollback;
            }
            break;
        case CRT_PKG_QUERY_ACCOUT_ID :
        {
            /* search all privateIds and publicIds; */
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_ACCOUT_ID >>"));
            switch( lc->result_code ){
                case LDAP_RESULT_SUCCESS:
                {
                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               root_dn);
                    sprintf(base_dn, "subdata=profile,ds=gup,subdata=services,%s", root_dn);
                    SDFLOG_DEBUG((B, "Search dn[%s]", base_dn))

                            /* clear rber */
                            LDAP_ber_free(lc->rber);
                    lc->rber = NULL;

                    char attrs[6][128];
                    strcpy(attrs[0], "publicId");
                    strcpy(attrs[1], "publicIds");
                    strcpy(attrs[2], "privateId");
                    strcpy(attrs[3], "privateIds");
                    strcpy(attrs[4], "deviceType");
                    attrs[5][0] = '\0';
                    LDAP_gen_ber_string(attrs, &b_attrs, error);
                    tid = LDAP_gen_search_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  "one",
                                                  "*",
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  LDAP_DEREF_ALWAYS,
                                                  control,
                                                  error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = CRT_PKG_QUERY_ACCOUT_ID;
                    main_state = CRT_PKG_QUERY_PRIVATE_ID;
                    break;
                default:
                        if( sub_state == CRT_PKG_ADD_AMF_COUNTER_PACK){
                            /* No need rollback for add amfCounterPack failed */
                            main_state = CRT_PKG_IDLE;
                            break;
                        }
                        sub_state = CRT_PKG_ADD_AMF_COUNTER_ENTRY;
                        main_state = CRT_PKG_ROLLBACK;
                        AMF_STORE_ROLLBACK(lc->result_code,"")
                        goto _crt_pkg_rollback;
                }// end case
            }// end switch
        }// end main case
            break;
        case CRT_PKG_QUERY_PRIVATE_ID :
        {
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_QUERY_PRIVATE_ID >>"));
            /*
             * store and create productNolist
             * add FBB
             */
            LDAP_OBJECT *obj = NULL;
            LBER_object_decode(lc, &obj, error);
            ldap_print_object(obj);
            if( amf_find_accountIds(&obj,
                                    mw->instance,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                    error) != 0)
            {
                SDFLOG_WARN((B, "Cannot prepare acountId [%s]", error));
                lc->result_code = LDAP_RESULT_SUCCESS;
            }
            SDFLOG_DEBUG((B, "======= PrivateIds ======="));
            ldap_print_object(mw->instance->amf->privateIds);
            SDFLOG_DEBUG((B, "======= publicIds ======="));
            ldap_print_object(mw->instance->amf->publicIds);

            if( mw->instance->amf->privateIds == NULL){
                sub_state = CRT_PKG_QUERY_PRIVATE_ID;
                main_state = CRT_PKG_ROLLBACK;
                AMF_STORE_ROLLBACK(LDAP_RESULT_NO_SUCH_OBJECT, "Not found privateId")
                goto _crt_pkg_rollback;
                break;
            }
            main_state = CRT_PKG_MOD_GUPIMPI;
            sub_state = CRT_PKG_QUERY_PRIVATE_ID;
        }
        case CRT_PKG_MOD_GUPIMPI:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_MOD_GUPIMPI >>"));
            switch (lc->result_code){
                case LDAP_RESULT_ATTRIBUTE_OR_VALUE_EXISTS:
                case LDAP_RESULT_SUCCESS:
                {
                    /* Update GUP IMPI */
                    char product_number[16];product_number[0] = '\0';
                    char buff[LDAP_MAX_ATTR_VALUE_SIZE];buff[0] = '\0';
                    int blen = 0;
                    LDAP_OBJECT *obj = NULL;
                    mlist = NULL;
                    vlist = NULL;
                    b_attrs = NULL;

                    obj = mw->instance->amf->privateIds;
                    LINKEDLIST_REMOVE(mw->instance->amf->privateIds, obj);
                    strcpy(base_dn, obj->name);
                    SDFLOG_DEBUG((B, "Add Modify dn[%s]", base_dn))

                    blen = sprintf(buff, "privateId=%s", mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                    if( strncmp(buff, obj->name, blen) == 0 )
                    {/* Owner */
                        sprintf(product_number, "%d|owner", mw->instance->amf->product_number);
                    }else
                    {/* TODO: device type */
                        sprintf(product_number, "%d|user", mw->instance->amf->product_number);
                    }

                    vlist = NULL;
                    LBER_valuelist_add(&vlist, product_number, error);
                    LBER_modlist_add(&mlist, LDAP_MODIFY_ADD, "productNoList", vlist, NULL);

                    LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  control,
                                                  error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    LINKEDLIST_APPEND(mw->instance->amf->privateIds_bckp, obj);
                    sub_state = CRT_PKG_MOD_GUPIMPI;
                    if( mw->instance->amf->privateIds == NULL){
                        main_state = CRT_PKG_MOD_GUPIMPU;
                    }else{
                        main_state = CRT_PKG_MOD_GUPIMPI;
                    }
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* failed to amfCallManage() */
                    /* REQUIRE ROLLBACK */
                default :
                    sub_state = CRT_PKG_MOD_GUPIMPI;
                    main_state = CRT_PKG_ROLLBACK;
                    AMF_STORE_ROLLBACK(lc->result_code,"")
                    goto _crt_pkg_rollback;
            }
            break;
        case CRT_PKG_MOD_GUPIMPU:
        {
            /* Update GUP IMPU */
            LDAP_OBJECT *obj = NULL;
            mlist = NULL;
            vlist = NULL;
            b_attrs = NULL;
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_MOD_GUPIMPU >>"));
            if (lc->result_code == LDAP_RESULT_SUCCESS ||
                    (sub_state = CRT_PKG_MOD_GUPIMPI && lc->result_code == LDAP_RESULT_ATTRIBUTE_OR_VALUE_EXISTS))
            {
                obj = mw->instance->amf->publicIds;
                if( obj != NULL){
                    LINKEDLIST_REMOVE(mw->instance->amf->publicIds, obj);
                    strcpy(base_dn, obj->name);
                    SDFLOG_DEBUG((B, "Add Modify dn[%s]", base_dn));
                    char product_number[16];
                    sprintf(product_number, "%d|user",mw->instance->amf->product_number);
                    LBER_valuelist_add(&vlist, product_number, NULL);
                    LBER_modlist_add(&mlist, LDAP_MODIFY_ADD, "productNoList", vlist, NULL);
                    LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  control,
                                                  error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    LINKEDLIST_APPEND(mw->instance->amf->publicIds_bckp, obj);
                    /* used as previos state */
                    sub_state = CRT_PKG_MOD_GUPIMPU;
                    /* check the last publicIds */
                    if(mw->instance->amf->publicIds == NULL ){

                        /** Exception for CRT_PKG_EXT_CALL_MANANGE_COUTER
                         * if activationDate > now then goto CRT_PKG_MOD_RUNNING_NUMBER
                         * else goto CRT_PKG_EXT_CALL_MANANGE_COUTER
                         */
                        if(mw->instance->amf->require_couter_manage == 1)
                        {
                            main_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                        }else{
                            main_state = CRT_PKG_MOD_RUNNING_NUMBER;
                        }
                    }else{
                        /* Repeat for next the publicIds */
                        main_state = CRT_PKG_MOD_GUPIMPU;
                    }
                    break;
                }else{
                    /* No any publicIds */
                    /** Exception for CRT_PKG_EXT_CALL_MANANGE_COUTER
                     * if activationDate > now then goto CRT_PKG_MOD_RUNNING_NUMBER
                     * else goto CRT_PKG_EXT_CALL_MANANGE_COUTER
                     */
                    if(mw->instance->amf->require_couter_manage == 1)
                    {
                        main_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                    }else{
                        main_state = CRT_PKG_MOD_RUNNING_NUMBER;
                    }
                }
            }else{
                /* REQUIRE ROLLBACK */
                main_state = CRT_PKG_ROLLBACK;
                AMF_STORE_ROLLBACK(lc->result_code,"")
                goto _crt_pkg_rollback;
            }
        }
        case CRT_PKG_EXT_CALL_MANANGE_COUTER:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_EXT_CALL_MANANGE_COUTER >>"));
            switch (lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                    // call ManageCountersRequest
                    // use ldap extended request
                    char buff[LDAP_MAX_ATTR_VALUE_SIZE];

                    alist = NULL;
                    vlist = NULL;
                    b_attrs = NULL;

                    // M methodVersion(SV)
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "4",error);
                    LBER_attrlist_add(&alist, "methodVersion", vlist, error);

                    // M subscriptionId(MV)
                    vlist = NULL;

                    if( STRCASEEQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "privateId") ){
                        sprintf(buff,"3|%s", mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                    }else if( STRCASEEQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "publicId") ){
                        sprintf(buff,"2|%s", mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                    }else{
                        if( mw->instance->index_list[IMPU] == NULL ){
                            SDFLOG_ERROR((B, "AMF doesn't support this identity [%s]", mw->instance->index_list[IDENTITY_VALUE]->vals->value))
                            main_state = CRT_PKG_ROLLBACK;
                            sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                            goto _crt_pkg_rollback;
                        }
                        sprintf(buff,"2|%s", mw->instance->index_list[IMPU]->vals->value);
                    }

                    LBER_valuelist_add(&vlist, buff ,error);
                    LBER_attrlist_add(&alist, "subscriptionId", vlist, error);

                    // M counterPackInfo(MV)
                    buff[0] = 0;
                    sprintf(buff,
                            "%d,"                               // <PRODUCT NO>
                            "1,"                                // <SYNCFLAG>
                            "%s,"                               // <START TIME>
                            "1,"                                // <PRODUCT STATE>
                            "%s,"                               // <EXPIRY TIME>
                            "%s,"                               // <COUNTER NAME>
                            "%d",                               // <NOTIFY FLAG>
                            mw->instance->amf->product_number,
                            mw->instance->amf->activation_time,
                            mw->instance->amf->expriry_time,
                            mw->instance->index_list[PRODUCT_OFFER]->vals->value,
                            mw->instance->amf->send_sms);
                    SDFLOG_DEBUG((B, "amf counterPackageInfo[%s]", buff))
                    vlist = NULL;
                    LBER_valuelist_add(&vlist,
                                       buff,
                                       error);
                    LBER_attrlist_add(&alist, "counterPackInfo", vlist, error);

                    // O chargePhase(SV)
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "0",error);
                    LBER_attrlist_add(&alist, "chargePhase", vlist, error);

                    // O online(SV)
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "1",error);
                    LBER_attrlist_add(&alist, "online", vlist, error);

                    // O recurNotify(SV)
                    //vlist = NULL;
                    //LBER_valuelist_add(&vlist, "",error);
                    //LBER_attrlist_add(&alist, "recurNotify", vlist, error);

                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_extended_request(LDAP_EXT_HANDLE,
                                              &ber,
                                              "0.0.17.1218.8.7.3",
                                              b_attrs->berval,
                                              b_attrs->len,
                                              control,
                                              error
                                              );
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    use_extend = 1;
                    sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                    if( mw->instance->amf->require_mod_expiry == 1){
                        /* user specify time */
                        main_state = CRT_PKG_MOD_USR_INPUT;
                    }else{
                        main_state = CRT_PKG_MOD_RUNNING_NUMBER;
                    }
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* failed to amfCallManage() */
                    /* REQUIRE ROLLBACK */
                default :
                    main_state = CRT_PKG_IDLE;
                    AMF_STORE_ROLLBACK(lc->result_code,"")
                    goto _crt_pkg_rollback;
            }
            break;
        case CRT_PKG_MOD_USR_INPUT:
        {
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_MOD_USR_INPUT >>"));
            switch( lc->result_code )
            {
                case LDAP_RESULT_SUCCESS:
                {
                    int result_state = -1;
                    char buff[LDAP_MAX_ATTR_VALUE_SIZE];buff[0] = '\0';
                    BER_MODLIST *mlist = NULL;
                    BER_VALLIST *vlist = NULL;
                    ber = NULL;

                    /* Check Result state */
                    if(sub_state == CRT_PKG_EXT_CALL_MANANGE_COUTER){//sub_stat as previos state
                            char vbuf[LDAP_MAX_ATTR_VALUE_SIZE];
                            if( amf_get_result_state(lc, vbuf, error) != 0){
                                AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR, error);
                                main_state = CRT_PKG_ROLLBACK;
                                goto _crt_pkg_rollback;
                            }

                            SDFLOG_DEBUG((B, "Result state [%s]", vbuf))
                            result_state = atoi(vbuf);
                            /* Note: SDF will continue when amf return on success and include
                             * result state with success(0) or ccr_direct_debit_timeout(42)
                             */
                            if( !(result_state == AMF_STATE_RESULT_SUCCESS ||
                              result_state == AMF_STATE_RESULT_CCR_DIRECT_DEBIT_TIMEOUT ||
                              result_state == AMF_STATE_RESULT_FUTURE_ACTIVATION))
                            {
                                sprintf(error, "amf manageCounter failed [%d]", result_state);
                                AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR, error);
                                main_state = CRT_PKG_ROLLBACK;
                                goto _crt_pkg_rollback;
                            }
                    }

                    /* Interim modity only expiry Time */
                    vlist = NULL;
                    mlist = NULL;
                    b_attrs = NULL;
                    LBER_valuelist_add(&vlist, mw->instance->amf->usr_expiry_time, error);
                    LBER_modlist_add(&mlist,
                                     LDAP_MODIFY_REPLACE,
                                     "expiryTime",
                                     vlist,
                                     error);

                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               buff);
                    sprintf(base_dn,
                            "amfProductNo=%d,subdata=profile,ds=amf,subdata=services,%s",
                            mw->instance->amf->product_number,
                            buff);
                    SDFLOG_DEBUG((B,"Modify dn[%s]", base_dn))
                    SDFLOG_DEBUG((B,"Replace by [%s]",mw->instance->amf->usr_expiry_time ))
                    LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                            &ber,
                                            base_dn,
                                            b_attrs->berval,
                                            b_attrs->len,
                                            control,
                                            error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                sub_state = CRT_PKG_MOD_USR_INPUT;
                main_state = CRT_PKG_MOD_RUNNING_NUMBER;
                }
                break;
            case LDAP_RESULT_NO_SUCH_OBJECT:
                /* REQUIRE ROLLBACK/ */
            default :
                AMF_STORE_ROLLBACK(lc->result_code, "");
                main_state = CRT_PKG_ROLLBACK;
                sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                goto _crt_pkg_rollback;
            }
            break;
        }
        case CRT_PKG_MOD_RUNNING_NUMBER:
        {
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_MOD_RUNNING_NUMBER >>"));
            switch (lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                    /* Check Result state */
                    if(sub_state == CRT_PKG_EXT_CALL_MANANGE_COUTER){//sub_stat as previos state
                        int result_state = -1;
                        char vbuf[LDAP_MAX_ATTR_VALUE_SIZE];
                            if( amf_get_result_state(lc, vbuf, error) != 0){
                                AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR, error);
                                sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                                main_state = CRT_PKG_ROLLBACK;
                                goto _crt_pkg_rollback;
                            }

                            SDFLOG_DEBUG((B, "Result state [%s]", vbuf))
                            result_state = atoi(vbuf);
                            /* Note: SDF will continue when amf return on success and include
                             * result state with success(0) or ccr_direct_debit_timeout(42)
                             */
                            if( !(result_state == AMF_STATE_RESULT_SUCCESS ||
                              result_state == AMF_STATE_RESULT_CCR_DIRECT_DEBIT_TIMEOUT ||
                              result_state == AMF_STATE_RESULT_FUTURE_ACTIVATION))
                            {
                                sprintf(error, "amf manageCounter failed [%d]", result_state);
                                AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR, error);
                                sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                                main_state = CRT_PKG_ROLLBACK;
                                goto _crt_pkg_rollback;
                            }
                    }

                    /* Update amfProductRunningNo */
                    if(get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                  mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                  root_dn) != 0){
                        SDFLOG_DEBUG((B, "Cannot get baseDn [%s]",mw->instance->index_list[IDENTITY_NAME]->vals->value));
                    }
                    sprintf(base_dn,
                            "subdata=amfProfile,subdata=profile,ds=amf,subdata=services,%s",
                            root_dn);
                    SDFLOG_DEBUG((B, "Add modify DN[%s]", base_dn))
                    char product_number[16];
                    vlist = NULL;
                    mlist = NULL;
                    b_attrs = NULL;
                    sprintf(product_number,"%d",mw->instance->amf->product_number);
                    LBER_valuelist_add(&vlist, product_number, error);
                    LBER_modlist_add(&mlist,
                                     (mw->instance->amf->runningNo_exist)?LDAP_MODIFY_ADD:LDAP_MODIFY_REPLACE,
                                     "amfProductRunningNo",
                                     vlist,
                                     error);
                    LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  control,
                                                  error
                                                  );
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = CRT_PKG_MOD_RUNNING_NUMBER;
                    main_state = CRT_PKG_CONSTRUCT_HTTP_RESONSE;
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* REQUIRE ROLLBACK */
                default :
                    AMF_STORE_ROLLBACK(LDAP_RESULT_OPERATION_ERROR, "");
                    main_state = CRT_PKG_ROLLBACK;
                    sub_state = CRT_PKG_EXT_CALL_MANANGE_COUTER;
                    goto _crt_pkg_rollback;
            }
            break;
        }
        case CRT_PKG_CONSTRUCT_HTTP_RESONSE:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_CONSTRUCT_HTTP_RESONSE >>"));
            switch(lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                   /* Everything have done */
                   /* Create Response Message for http */
                   /* :Response Body:
                    * ProductNumber
                    * version
                    */

                    char *result;
                    result = (char *)malloc(sizeof(char) * 1024);
                    if(mw->instance->amf->rollback_result_code != LDAP_RESULT_SUCCESS){
                        sprintf(result, "%s",
                                mw->instance->amf->rollback_desc);                  /* set cause of rollback*/
                        lc->result_code = mw->instance->amf->rollback_result_code;  /* set result code */
                        strcpy(lc->diagnosticMessage,result);
                    }else{
                        sprintf(result, "\"productNumber\":\"%d\",\"version\":\"%s\"",
                                mw->instance->amf->product_number,
                                mw->instance->amf->version);
                    }
                    mw->instance->result_data = result;
                    main_state = CRT_PKG_IDLE;
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    /* REQUIRE ROLLBACK */
                default :
                    main_state = CRT_PKG_IDLE;
                    break;
            }
            break;
        case CRT_PKG_ROLLBACK:
_crt_pkg_rollback:
            // Rollback all transaction
            SDFLOG_WARN((B, "STATE << CRT_PKG_ROLLBACK >>"));
            switch( sub_state ){
                case CRT_PKG_MOD_RUNNING_NUMBER:
                {
                    /* rollback modify amfProductRunningNo */
                    /* send ldap modify with old amfProductRunningNo */
                    SDFLOG_INFO((B, "Rollback modify amfProductRunningNo"));

                    /* Update amfProductRunningNo */
                    if(get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                  mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                  root_dn) != 0){
                        SDFLOG_DEBUG((B, "Cannot get baseDn [%s]",mw->instance->index_list[IDENTITY_NAME]->vals->value));
                    }
                    sprintf(base_dn,
                            "subdata=amfProfile,subdata=profile,ds=amf,subdata=services,%s",
                            root_dn);
                    SDFLOG_DEBUG((B, "Add modify DN[%s]", base_dn))
                    char product_number[16];

                    sprintf(product_number,
                            "%d",
                            (mw->instance->amf->runningNo_exist)?mw->instance->amf->product_number:mw->instance->amf->product_old_numer);
                    LBER_valuelist_add(&vlist, product_number, error);
                    LBER_modlist_add(&mlist,
                                     (mw->instance->amf->runningNo_exist)?LDAP_MODIFY_DELETE:LDAP_MODIFY_REPLACE,
                                     "amfProductRunningNo",
                                     vlist,
                                     error);
                    LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  b_attrs->berval,
                                                  b_attrs->len,
                                                  control,
                                                  error
                                                  );
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = CRT_PKG_MOD_GUPIMPU;
                    break;
                }// end case CRT_PKG_MOD_RUNNING_NUMBER
                case CRT_PKG_EXT_CALL_MANANGE_COUTER:
                    /* rollback by deleting counter pack */
                    SDFLOG_INFO((B, "Rollback call amf Manage Counter."));
                case CRT_PKG_MOD_GUPIMPU:
                {
                    if( mw->instance->amf->publicIds_bckp ){
                        /* rollback modify publicId */
                        SDFLOG_INFO((B, "Rollback modify publicId."));
                        char product_number[16];
                        LDAP_OBJECT *obj = NULL;
                        mlist = NULL;
                        vlist = NULL;
                        b_attrs = NULL;

                        obj = mw->instance->amf->publicIds_bckp;
                        LINKEDLIST_REMOVE(mw->instance->amf->publicIds_bckp, obj);
                        strcpy(base_dn, obj->name);
                        SDFLOG_DEBUG((B, "Modify delete dn[%s]", base_dn))

                                sprintf(product_number, "%d|user", mw->instance->amf->product_number);
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, product_number, error);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "productNoList", vlist, NULL);

                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                      &ber,
                                                      base_dn,
                                                      b_attrs->berval,
                                                      b_attrs->len,
                                                      control,
                                                      error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        ldap_object_free( obj );
                        if( mw->instance->amf->publicIds_bckp == NULL){
                            sub_state = CRT_PKG_MOD_GUPIMPI;
                        }else{
                            sub_state = CRT_PKG_MOD_GUPIMPU;
                        }
                        break;
                    } // end if
                }// end case CRT_PKG_MOD_GUPIMPU
                case CRT_PKG_MOD_GUPIMPI:
                {
                    if( mw->instance->amf->privateIds_bckp ){
                        /* rollback modify privateId */
                        /* Update GUP IMPI */
                        SDFLOG_INFO((B, "Rollback modify privateId."));

                        char product_number[16];product_number[0] = '\0';
                        char buff[LDAP_MAX_ATTR_VALUE_SIZE];buff[0] = '\0';
                        int blen = 0;
                        LDAP_OBJECT *obj = NULL;
                        mlist = NULL;
                        vlist = NULL;
                        b_attrs = NULL;

                        obj = mw->instance->amf->privateIds_bckp;
                        LINKEDLIST_REMOVE(mw->instance->amf->privateIds_bckp, obj);
                        strcpy(base_dn, obj->name);
                        SDFLOG_DEBUG((B, "Modify delete dn[%s]", base_dn))
                        blen = sprintf(buff, "privateId=%s", mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                        if( strncmp(buff, obj->name, blen) == 0 )
                        {/* Owner */
                                sprintf(product_number, "%d|owner", mw->instance->amf->product_number);
                        }else if( STRCASEEQ("",mw->instance->index_list[IDENTITY_NAME]->vals->value) )
                        {
                            sprintf(product_number, "%d|user", mw->instance->amf->product_number);
                        }
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, product_number, error);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "productNoList", vlist, NULL);

                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE,
                                                      &ber,
                                                      base_dn,
                                                      b_attrs->berval,
                                                      b_attrs->len,
                                                      control,
                                                      error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        ldap_object_free( obj );
                        if( mw->instance->amf->privateIds_bckp == NULL){
                            sub_state = CRT_PKG_ADD_AMF_COUNTER_PACK;
                        }else{
                            sub_state = CRT_PKG_MOD_GUPIMPI;
                        }
                        break;
                    }// end if
                }// end case CRT_PKG_MOD_GUPIMPI
                case CRT_PKG_QUERY_PRIVATE_ID:
                    /* rollback by deleting counter pack */
                case CRT_PKG_ADD_AMF_COUNTER_ENTRY:
                    /* rollback by deleting counter pack */
                    SDFLOG_INFO((B, "Rollback add amfcounterEntry."));
                case CRT_PKG_ADD_AMF_COUNTER_PACK:
                {
                    /* rollback both amfCounterPack and amfCounterEntry */
                    SDFLOG_INFO((B, "Rollback add amfCounterPack."));

                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               root_dn);
                    sprintf(base_dn,"amfProductNo=%d,subdata=profile,ds=amf,subdata=services,%s",
                            mw->instance->amf->product_number,
                            root_dn);
                    SDFLOG_DEBUG((B,"Delete DN[%s]", base_dn))
                    tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE,
                                                  &ber,
                                                  base_dn,
                                                  control,
                                                  error);
                    if (control != NULL) SDF_FREE(control);
                    main_state = CRT_PKG_CONSTRUCT_HTTP_RESONSE;
                    break;
                }// end case CRT_PKG_ADD_AMF_COUNTER_PACK
            }// end switch
            break;
        case CRT_PKG_IDLE:
            SDFLOG_DEBUG((B, "STATE << CRT_PKG_IDLE >>"));
            break;
        default :
            SDFLOG_ERROR((B, "Invalid state"))
            break;
    }



    if (ber != NULL )
    {
        if( use_extend == 1 ){
            SDFLOG_DEBUG((B, "send extended message"))
            if( l_clnt_send_ext_msg(ber) != 0){
                SDFLOG_FATAL((B, "Cannot send ldap request."));
                lc->result_code = LDAP_RESULT_OTHER;
                strcpy(lc->diagnosticMessage, "Cannot send ldap request");
                return CRT_PKG_IDLE;
            }
        }else{
            if( l_clnt_send_msg(ber) != 0 ){
                SDFLOG_FATAL((B, "Cannot send ldap extended request."));
                lc->result_code = LDAP_RESULT_OTHER;
                strcpy(lc->diagnosticMessage, "Cannot send ldap extended request.");
                return CRT_PKG_IDLE;
            }
        }
    }


    /* Clear instance */
    if(main_state == CRT_PKG_IDLE){
        return main_state;
    }

    /* Update Instance */
    mw->instance->main_state = main_state;
    mw->instance->sub_state = sub_state;

    /* Create new edb */
    MWRAPPER *nmw;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        strcpy(error, "Can not allocate memory");
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot allocate memory.");
        return CRT_PKG_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;

    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);

    return main_state;
}

int af_process_modifyIdentiry_method(LDAP_CLNT *lc, MWRAPPER *mw, char *error){

    static char func[] = "af_process_modifyIdentiry_method";

    /* Declear local variable */
    int main_state = 0;
    int sub_state = 0;
    int tid = 0;
    char base_dn[1024];
    Control *control = NULL;
#ifdef GRPC
    HTTP2_BUFFER    *ber = NULL; 
#else
    BER             *ber = NULL;
#endif

    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Instance may be NULL");
        return MODIFY_IDENTIY_IDLE;
    }


    /* Reconize state */
    main_state = mw->instance->main_state;
    sub_state = mw->instance->sub_state;
    LDAP_CREATE_CONTROL();
    
    switch ( main_state ){
        // Add, Modify
        case MODIFY_IDENTIY_CCK_UID:
            switch (lc->result_code){
                case LDAP_RESULT_SUCCESS:
                {
                    if ( STREQ(mw->instance->index_list[IDENTITY_TYPE]->vals->value, "modify") ){

                        // Search New UID Command
                        sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[NEWUID]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
#ifdef GRPC
                        USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
                        tid = grpc_tid_gen();
                        SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                        if( GRPC_gen_search_request(mw->instance->gid, tid, &ber, base_dn, "base", "(objectClass=*)", NULL, 0, SET_GET_METHOD(mw->instance, 0), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                            SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                            return -1;
                        }
#else                        
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_ALWAYS, control, error);
                        if (control != NULL) SDF_FREE(control);
#endif
                        main_state = MODIFY_IDENTIY_CCK_NEW_UID;

                    }else if ( STREQ(mw->instance->index_list[IDENTITY_TYPE]->vals->value, "add") ){
                        // Add alias Command
                        BER_ATTRLIST *alist = NULL;
                        BER_VALLIST *vlist = NULL;
                        BER *b_attrs = NULL;


                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                         vlist = NULL;
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[IDENTITY_VALUE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, mw->instance->index_list[IDENTITY_NAME]->vals->value, vlist, NULL);

                        if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "msisdn") ){

                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=MSISDN,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "msisdnAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "imsi") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=IMSI,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "imsiAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "publicId") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=IMPU,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "impuAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "privateId") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=IMPI,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "impiAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "email") ){
                            // Create BaseDN
                            sprintf(base_dn,"%s=%s,dc=EMAIL,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "emailAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "partnerId") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=PARTNERID,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "partnerAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "baId") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=BA,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "baAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "caId") ){
                            // Create BaseDNs
                            sprintf(base_dn, "%s=%s,dc=CA,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "caAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else if( STREQ(mw->instance->index_list[IDENTITY_NAME]->vals->value, "deviceId") ){
                            // Create BaseDN
                            sprintf(base_dn, "%s=%s,dc=DEVICE,dc=C-NTDB",
                                    mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                    mw->instance->index_list[IDENTITY_VALUE]->vals->value);
                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "deviceAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        }else{
                            SDFLOG_ERROR((B, "Not support this Identity[%s]", mw->instance->index_list[IDENTITY_NAME]->vals->value));
                            lc->result_code = LDAP_RESULT_UNWILLING_TO_PERFORM;
                            sprintf(lc->diagnosticMessage, "Not support this Identity[%s]", mw->instance->index_list[IDENTITY_NAME]->vals->value);
                            return MODIFY_IDENTIY_IDLE;
                        }

                        SDFLOG_DEBUG((B,"Add DN [%s]", base_dn))

                        // Gen BER encoding
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        //tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        
                        main_state = MODIFY_PROCESS;
                    }
                }
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    default:
                        main_state = MODIFY_IDENTIY_IDLE;
                        break;
            }
            break;
        // modify
        case MODIFY_IDENTIY_CCK_NEW_UID:
            switch(lc->result_code){
                case LDAP_RESULT_SUCCESS:

                    // Search Alias
                    get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                               mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                               base_dn);
                    SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
                    //tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_ALWAYS, control, error);
                    
                    main_state = MODIFY_IDENTIY_CCK_ALIAS;

                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                    // Rais ERROR
                default :
                    main_state = MODIFY_IDENTIY_IDLE;
                    break;
            }
            break;
        // modify, delete
        case MODIFY_IDENTIY_CCK_ALIAS:
            switch(lc->result_code){
                case LDAP_RESULT_SUCCESS:
                    if( STREQ(mw->instance->index_list[IDENTITY_TYPE]->vals->value,"delete") ) {

                        get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                   mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                   base_dn);

                        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
                       //tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE, &ber, base_dn, NULL, error);

                    }else if (STREQ(mw->instance->index_list[IDENTITY_TYPE]->vals->value,"modify") ){
                        //modify Command
                        get_baseDN(mw->instance->index_list[IDENTITY_NAME]->vals->value,
                                   mw->instance->index_list[IDENTITY_VALUE]->vals->value,
                                   base_dn);

                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));

                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        BER *b_attrs = NULL;
                        BER_VALLIST *vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[NEWUID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        //tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // do process
                    main_state = MODIFY_PROCESS;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default :
                    // Rais ERROR
                    main_state = MODIFY_IDENTIY_IDLE;
                    break;
            }
            break;
        case MODIFY_PROCESS:
            main_state = MODIFY_IDENTIY_IDLE;
            break;
        default :
            main_state = MODIFY_IDENTIY_IDLE;
            break;

    }

#ifdef GRPC
#else
    if (ber != NULL && l_clnt_send_msg(ber) != 0 )
    {
        SDFLOG_FATAL((B, "Cannot send ldap request."));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot send ldap request");
        return MODIFY_IDENTIY_IDLE;
    }
#endif

    /* Clear instance */
    if(main_state == MODIFY_IDENTIY_IDLE){
        return main_state;
    }

    /* Update Instance */
    mw->instance->main_state = main_state;
    mw->instance->sub_state = sub_state;

    /* Create new edb */
    MWRAPPER *nmw;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        SDFLOG_FATAL((B, "Cannot allocate memory size(%u)",(unsigned int)(sizeof(*mw))));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot allocate memory");
        return MODIFY_IDENTIY_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;

    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);

    return main_state;
}

int af_process_numberChange_method (LDAP_CLNT *lc, MWRAPPER *mw, char *error){
    static char func[] = "af_process_numberChange_method";

    /* Declear local variable */
    int main_state = 0;
    int sub_state = 0;
    int tid = 0;
    char base_dn[1024];
    char err[1024];
    BER *ber = NULL;
    Control *control=NULL;
    UNUSED(error);
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Instance may be NULL");
        return MODIFY_IDENTIY_IDLE;
    }


    /* Reconize state */
    main_state = mw->instance->main_state;
    sub_state = mw->instance->sub_state;

    switch ( main_state ){
        case METHOD_STATE_IDLE:
        case METHOD_STATE_VER_UID:
        case METHOD_STATE_MODRDN_MSISDN_ALIAS:
            switch ( lc->result_code ){
                case LDAP_RESULT_SUCCESS:
                {
                    /* Create modrdn request */
                    /* dn: msisdn=66xxxxxxxxx,dc=MSISDN,dc=C-NTDB */
                    SDFLOG_DEBUG((B, "state::METHOD_STATE_MODRDN_MSISDN_ALIAS"))
                    // Decode ldap response to json format.
                    LBER_attr_decode(lc, LBER_DECODE_JSON, err);
                    if(lc->bstring->berval[0]!=0)
                        SDFLOG_DEBUG((B, "recv:: %s", lc->bstring->berval));

                    // Get UID
                    char *ptr = lc->bstring->berval;
                    if( (ptr = strstr(ptr,"uid=")) == NULL ){
                        main_state = METHOD_STATE_IDLE;
                        break;
                    }

                    ptr += 4; //size of "uid="
                    //char *uid = calloc(sizeof(char), 32);
                    char uid[32];
                    int i = 0;
                    /* Copy UID */
                    while ( (ptr[i]) && (i < 32) ){
                        if( ptr[i] == ',' )
                        {
                            ptr[i] = '\0';
                            break;
                        }
                        uid[i] = ptr[i];
                        ++i;
                    }

                    /* add uid to alist structure */
                    SDFLOG_DEBUG((B ,"GET UID [%s]",  uid));
                    BER_VALLIST *bval = NULL;
                    LBER_valuelist_add( &bval, uid ,err );
                    //free(uid);
                    LBER_attrlist_add( &(mw->instance->alist), "uid", bval, err );
                    mw->instance->index_list[UID] = mw->instance->alist->prev;

                    /* Create modrdn request */
                    sprintf(base_dn, "msisdn=%s,dc=MSISDN,dc=C-NTDB"
                            , mw->instance->index_list[OLD_NUMBER]->vals->value);
                    char buff[128];
                    sprintf( buff, "msisdn=%s", mw->instance->index_list[NEW_NUMBER]->vals->value);
                    SDFLOG_DEBUG((B, "modfidy DN[%s]", base_dn));
                    SDFLOG_DEBUG((B, "new RDN[%s]", buff));
                    LDAP_CREATE_CONTROL();
                    tid = LDAP_gen_moddn_request(LDAP_LIST_HANDLE
                                                  , &ber
                                                  , base_dn
                                                  , buff
                                                  , 1
                                                  , NULL
                                                  ,control
                                                  , err);

                    /* Check gen modrdn */
                    if(tid < 0){
                        SDFLOG_ERROR((B, "Cannot gen modrdn ber"))
                        if (control != NULL) SDF_FREE(control);
                        main_state = METHOD_STATE_IDLE;
                    }
                    if (control != NULL) SDF_FREE(control);
                    main_state = METHOD_STATE_MODRDN_MSISDN_GUP;
                    break;
                }
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    SDFLOG_ERROR((B, "Cannot operate [UID not found]"));
                    main_state = METHOD_STATE_IDLE;
                    break;
            }
            break;
        case METHOD_STATE_MODRDN_MSISDN_GUP:
        {
            switch( lc->result_code ){
                case LDAP_RESULT_SUCCESS:
                    SDFLOG_INFO((B, "Response ok"));
                    break;
                default:
                    SDFLOG_INFO((B, "Response fail[%s]", lc->diagnosticMessage));
                break;
            }

            /* Create modrdn GUP reqeust */
            /* dn: msisdn=66812223333,subdata=profile,ds=gup,subdata=services,uid=123456789101112,ds=SUBSCRIBER,o=AIS,dc=C-NTDB */
            SDFLOG_DEBUG((B, "State::METHOD_STATE_MODRDN_MSISDN_GUP"));
            /* Crate modrdn request */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
                    , mw->instance->index_list[OLD_NUMBER]->vals->value
                    , mw->instance->index_list[UID]->vals->value);
            char buff[128];
            sprintf( buff, "msisdn=%s", mw->instance->index_list[NEW_NUMBER]->vals->value);

            SDFLOG_DEBUG((B, "modfidy DN[%s]", base_dn));
            SDFLOG_DEBUG((B, "new RDN[%s]", buff));
            tid = LDAP_gen_moddn_request(LDAP_LIST_HANDLE
                                          , &ber
                                          , base_dn
                                          , buff
                                          , 1
                                          , NULL
                                          ,control
                                          , err);
            if(tid < 0){
                SDFLOG_ERROR((B, "Cannot gen modrdn ber"));
                if (control != NULL) SDF_FREE(control);
                main_state = METHOD_STATE_IDLE;
            }else{
                if (control != NULL) SDF_FREE(control);
                main_state = METHOD_STATE_MODRDN_MSISDN_AMF;
            }
            break;
        }
        case METHOD_STATE_MODRDN_MSISDN_AMF:
        {
            switch( lc->result_code ){
                case LDAP_RESULT_SUCCESS:
                    SDFLOG_INFO((B, "Response ok"));
                    break;
                default:
                    SDFLOG_INFO((B, "Response fail[%s]", lc->diagnosticMessage));
                break;
            }
            /* Create modrdn AMF request */
            /* dn: msisdn=66812223333,subdata=profile,ds=amf,subdata=services,uid=123456789101112,ds=SUBSCRIBER,o=AIS,dc=C-NTDB */
            SDFLOG_DEBUG((B, "State::METHOD_STATE_MODRDN_MSISDN_AMF"));
            /* Crate modrdn request */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
                    , mw->instance->index_list[OLD_NUMBER]->vals->value
                    , mw->instance->index_list[UID]->vals->value);
            char buff[128];
            sprintf( buff, "msisdn=%s", mw->instance->index_list[NEW_NUMBER]->vals->value);

            SDFLOG_DEBUG((B, "modfidy DN[%s]", base_dn));
            SDFLOG_DEBUG((B, "new RDN[%s]", buff));
            tid = LDAP_gen_moddn_request(LDAP_LIST_HANDLE
                                          , &ber
                                          , base_dn
                                          , buff
                                          , 1
                                          , NULL
                                          ,control
                                          , err);
            if(tid < 0){
                SDFLOG_ERROR((B, "Cannot gen mordn ber"));
                if (control != NULL) SDF_FREE(control);
                main_state = METHOD_STATE_IDLE;
            }else{
                if (control != NULL) SDF_FREE(control);
                main_state = METHOD_STATE_LAST;
            }

            break;
        }
        case METHOD_STATE_LAST:
            SDFLOG_DEBUG((B, "State::METHOD_STATE_LAST"));
            switch( lc->result_code ){
                case LDAP_RESULT_SUCCESS:
                    SDFLOG_INFO((B, "Response ok"));
                    break;
                default:
                    SDFLOG_INFO((B, "Response fail[%s]", lc->diagnosticMessage));
                break;
            }
            main_state = METHOD_STATE_IDLE;
            break;
    }

    if (ber != NULL && l_clnt_send_msg(ber) != 0 )
    {
        SDFLOG_FATAL((B, "Can not send ldap request."));
        return -1;
    }


    /* Clear instance */
    if(main_state == METHOD_STATE_IDLE){
        return main_state;
    }

    /* Update Instance */
    mw->instance->main_state = main_state;
    mw->instance->sub_state = sub_state;

    /* Create new edb */
    MWRAPPER *nmw;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot allocate memory");
        return MODIFY_IDENTIY_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;

    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);
    return main_state;
}

int af_process_insertSubscriber_method(LDAP_CLNT *lc, MWRAPPER *mw, char *error){
    static char func[] = "af_process_insertSubscriber_method";
    char base_dn[LDAP_MAX_BASE_DN];
    char *s,*ss;
    int main_state = 0;
    int sub_state = 0;
    int tid = 0;
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist = NULL;
    BER *b_attrs = NULL;
    BER *ber = NULL;
    Control *control=NULL;

    if(mw == NULL || mw->instance == NULL){
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Instance may be NULL");
        return AFSTATE_SUBSCRIBER_IDLE;
    }

/* Prototype
    switch(next_state){
        case AFSTATE_SUBSCRIBER_IDLE:
            // Must not be here!!!
            // Release Everything.
            break;
        case AFSTATE_SUBSCRIBER_VERIFY:
            switch (sub_state) {
                case AFSTATE_SUBSCRIBER_IDLE:

                case AFSTATE_SUBSCRIBER_ADD_CNTDB:

                case AFSTATE_SUBSCRIBER_ADD_AIS:

                case AFSTATE_SUBSCRIBER_ADD_SUBSCRIBER:

                default:
                    // Exception over here!!!
                    // Release Everything
                    SDFLOG_WARN((B, "No action on veriry subscriber."))
                    break;
            }
        case AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE:
            // Add uid
        case AFSTATE_SUBSCRIBER_ADD_PROFILE:
        case AFSTATE_SUBSCRIBER_ADD_SERVICE:
        case AFSTATE_SUBSCRIBER_ADD_ALIAS:
            switch (sub_state) {
                case AFSTATE_SUBSCRIBER_IDLE:
                case AFSTATE_SUBSCRIBER_ADD_MSISDN:
                case AFSTATE_SUBSCRIBER_ADD_IMSI:
                case AFSTATE_SUBSCRIBER_ADD_IMPU:
                case AFSTATE_SUBSCRIBER_ADD_IMPI:
                    break;
                default:
                    // Exception over here!!!
                    // Release Everything
                    SDFLOG_WARN((B, "No Action on add alias."))
                    break;
            }
        case AFSTATE_SUBSCRIBER_ADD_GUP:
        case AFSTATE_SUBSCRIBER_ADD_AEMF:
        case AFSTATE_SUBSCRIBER_ADD_AMF:
        default:
            // Exception over here!!!
            // Release Everything
            SDFLOG_ERROR((B, "No action on main state!!!"))
            break;

    }
*/
    /* Check LDAP Response */
    switch(lc->result_code){
        case LDAP_RESULT_SUCCESS:
        case LDAP_RESULT_ENTRY_ALREADY_EXISTS:
        case LDAP_RESULT_NO_SUCH_OBJECT:
            // Reconize State
            main_state = mw->instance->main_state;
            sub_state = mw->instance->sub_state;
            break;
        default:
            SDFLOG_ERROR((B, "LDAP ERROR"));
            main_state = AFSTATE_SUBSCRIBER_IDLE;
            break;
    }

    switch(main_state){
        case AFSTATE_SUBSCRIBER_IDLE:
            // Never should be here!!!
            // Release Everything.
            SDFLOG_WARN((B, "Delete Instance"));
            break;
        case AFSTATE_SUBSCRIBER_VERIFY_ALIAS:
            switch(sub_state){
                case AFSTATE_SUBSCRIBER_IDLE:
                {
                    if(lc->result_code == LDAP_RESULT_SUCCESS){
                        // UID is duplicate
                        if (mw->instance->is_orig_uid){
                            // Error occur over here!
                            SDFLOG_WARN((B, "uid[%s] is already exist" ,mw->instance->index_list[UID]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            main_state = AFSTATE_SUBSCRIBER_IDLE;
                            break;
                        }else{
                            // Re-generate UID
                            char my_uid[256];
                            int len = 0;
                            if(af_regen_uid(mw->instance,my_uid) >= 0){
                                len = sprintf(mw->instance->index_list[UID]->vals->value, "%s", my_uid);
                                mw->instance->index_list[UID]->vals->len = len;
                                sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", my_uid);
                                SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));

                                // Create rdn
                                LBER_valuelist_add(&vlist,  mw->instance->index_list[UID]->vals->value, NULL);
                                LBER_attrlist_add(&alist, "uid", vlist, NULL);

                                // Create objectClass
                                vlist = NULL;
                                LBER_valuelist_add(&vlist, "subscriber", NULL);
                                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                                LDAP_CREATE_CONTROL();
                                tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_ALWAYS, control, error);
                                sub_state = AFSTATE_SUBSCRIBER_IDLE;
                                LDAP_ber_free(b_attrs);
                                break;
                            }else{
                                SDFLOG_ERROR((B, "Cannot gen new uid"));
                                main_state = AFSTATE_SUBSCRIBER_IDLE;
                                lc->result_code = LDAP_RESULT_OPERATION_ERROR;
                                strcpy(lc->diagnosticMessage,"Cannot get new uid");
                                break;
                            } // End if re-generate UID
                        } // End if isOriginUID
                    }else if(lc->result_code == LDAP_RESULT_NO_SUCH_OBJECT){
                        // Continue to next state.
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_MSISDN;
                    }else{
                        // Error occur over here!
                        SDFLOG_ERROR((B, "LDAP connection error"));
                        main_state = AFSTATE_SUBSCRIBER_IDLE;
                        break;
                    }// End check ldap response.
                }// End sub state
                case AFSTATE_SUBSCRIBER_VA_SEARCH_MSISDN:
                    if(mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                        sprintf(base_dn, "msisdn=%s,dc=MSISDN,dc=C-NTDB", mw->instance->index_list[MSISDN]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "msisdnAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_MSISDN;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_MSISDN:
                    if(mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                        mw->instance->result_code[MSISDN] = lc->result_code;
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_IMSI;
                    }else{
                        mw->instance->result_code[MSISDN] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_IMSI:
                    if(mw->instance->index_list[IMSI] != NULL && mw->instance->index_list[IMSI]->vals->len > 0){
                        sprintf(base_dn, "imsi=%s,dc=IMSI,dc=C-NTDB", mw->instance->index_list[IMSI]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[IMSI]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "imsi", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "imsiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_IMSI;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_IMSI:
                    if(mw->instance->index_list[IMSI] != NULL && mw->instance->index_list[IMSI]->vals->len > 0){
                        mw->instance->result_code[IMSI] = lc->result_code;
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_IMPU;
                    }else{
                        mw->instance->result_code[IMSI] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_IMPU:
                    if(mw->instance->index_list[IMPU] != NULL && mw->instance->index_list[IMPU]->vals->len > 0){
                        sprintf(base_dn, "publicId=%s,dc=IMPU,dc=C-NTDB", mw->instance->index_list[IMPU]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[IMPU]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "publicId", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impuAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_IMPU;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_IMPU:
                    if(mw->instance->index_list[IMPU] != NULL && mw->instance->index_list[IMPU]->vals->len > 0){
                        mw->instance->result_code[IMPU] = lc->result_code;
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_IMPI;
                    }else{
                        mw->instance->result_code[IMPU] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_IMPI:
                    if(mw->instance->index_list[IMPI] != NULL && mw->instance->index_list[IMPI]->vals->len > 0){
                        sprintf(base_dn, "privateId=%s,dc=IMPI,dc=C-NTDB", mw->instance->index_list[IMPI]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[IMPI]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "privateId", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_IMPI;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_IMPI:
                    if(mw->instance->index_list[IMPI] != NULL && mw->instance->index_list[IMPI]->vals->len > 0){
                        mw->instance->result_code[IMPI] = lc->result_code;
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_EMAIL;
                    }else{
                        mw->instance->result_code[IMPI] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_EMAIL:
                    if(mw->instance->index_list[EMAIL] != NULL && mw->instance->index_list[EMAIL]->vals->len > 0){
                        sprintf(base_dn, "email=%s,dc=EMAIL,dc=C-NTDB", mw->instance->index_list[EMAIL]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[EMAIL]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "email", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "emailAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_EMAIL;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_EMAIL:
                    if(mw->instance->index_list[EMAIL] != NULL && mw->instance->index_list[EMAIL]->vals->len > 0){
                        mw->instance->result_code[EMAIL] = lc->result_code;
                        sub_state = AFSTATE_SUBSCRIBER_VA_SEARCH_PARTNERID;
                    }else{
                        mw->instance->result_code[EMAIL] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_PARTNERID:
                    if(mw->instance->index_list[PARTNERID] != NULL && mw->instance->index_list[PARTNERID]->vals->len > 0){
                        sprintf(base_dn, "partnerId=%s,dc=PARTNERID,dc=C-NTDB", mw->instance->index_list[PARTNERID]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[PARTNERID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "partnerId", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "partnerAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_PARTNERID;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_PARTNERID:
                    if(mw->instance->index_list[PARTNERID] != NULL && mw->instance->index_list[PARTNERID]->vals->len > 0){
                        mw->instance->result_code[PARTNERID] = lc->result_code;
                    }else{
                        mw->instance->result_code[PARTNERID] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_BA:
                    if(mw->instance->index_list[BAID] != NULL && mw->instance->index_list[BAID]->vals->len > 0){
                        sprintf(base_dn, "baId=%s,dc=BA,dc=C-NTDB", mw->instance->index_list[BAID]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[BAID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "baAlias", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "baAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_BA;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_BA:
                    if(mw->instance->index_list[BAID] != NULL && mw->instance->index_list[BAID]->vals->len > 0){
                        mw->instance->result_code[BAID] = lc->result_code;
                    }else{
                        mw->instance->result_code[BAID] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_CA:
                    if(mw->instance->index_list[CAID] != NULL && mw->instance->index_list[CAID]->vals->len > 0){
                        sprintf(base_dn, "caId=%s,dc=CA,dc=C-NTDB", mw->instance->index_list[CAID]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[CAID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "caAlias", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "caAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_CA;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_CA:
                    if(mw->instance->index_list[CAID] != NULL && mw->instance->index_list[CAID]->vals->len > 0){
                        mw->instance->result_code[CAID] = lc->result_code;
                    }else{
                        mw->instance->result_code[CAID] = -1;
                    }
                case AFSTATE_SUBSCRIBER_VA_SEARCH_DEVICE:
                    if(mw->instance->index_list[DEVICE] != NULL && mw->instance->index_list[DEVICE]->vals->len > 0){
                        sprintf(base_dn, "deviceId=%s,dc=DEVICE,dc=C-NTDB", mw->instance->index_list[DEVICE]->vals->value);
                        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

                        // Create rdn
                        LBER_valuelist_add(&vlist,  mw->instance->index_list[DEVICE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "deviceAlias", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "deviceAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, &ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_NEVER, control, error);
                        sub_state = AFSTATE_SUBSCRIBER_VA_VERIFY_DEVICE;
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        break;
                    }
                case AFSTATE_SUBSCRIBER_VA_VERIFY_DEVICE:
                    if(mw->instance->index_list[DEVICE] != NULL && mw->instance->index_list[DEVICE]->vals->len > 0){
                        mw->instance->result_code[DEVICE] = lc->result_code;
                        main_state = AFSTATE_SUBSCRIBER_PROCESS;
                    }else{
                        mw->instance->result_code[DEVICE] = -1;
                    }
                case AFSTATE_SUBSCRIBER_PROCESS:
                    if(mw->instance->index_list[ADDIFEXIST] != NULL && STRCASEEQ(mw->instance->index_list[ADDIFEXIST]->vals->value,"yes")){
                        // Add all alias
                        SDFLOG_DEBUG((B,"Enable force add"))
                    }else{
                        main_state = AFSTATE_SUBSCRIBER_IDLE;
                        if(mw->instance->result_code[MSISDN] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"misidn[%s] is already exist.", mw->instance->index_list[MSISDN]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[IMSI] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"imsi[%s] is already exist.", mw->instance->index_list[IMSI]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[IMPU] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"impu[%s] is already exist.", mw->instance->index_list[IMPU]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[IMPI] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"impi[%s] is already exist.", mw->instance->index_list[IMPI]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[EMAIL] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"email[%s] is already exist.", mw->instance->index_list[EMAIL]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[PARTNERID] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"partnerid[%s] is already exist.", mw->instance->index_list[PARTNERID]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[BAID] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"baId[%s] is already exist.", mw->instance->index_list[BAID]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[DEVICE] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"deviceId[%s] is already exist.", mw->instance->index_list[DEVICE]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        }else if(mw->instance->result_code[CAID] == LDAP_RESULT_SUCCESS){
                            SDFLOG_ERROR((B,"caId[%s] is already exist.", mw->instance->index_list[CAID]->vals->value));
                            lc->result_code = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                            break;
                        } //End if
                    } // End if AddIfExist

                    // Update state
                    main_state = AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE;
                    goto _add_subscribe;
            } // End sub state
            break;
        case AFSTATE_SUBSCRIBER_VERIFY:
            switch (sub_state) {
                case AFSTATE_SUBSCRIBER_IDLE:
                    switch (lc->result_code) {
                        case LDAP_RESULT_SUCCESS:
                        {
                            goto _add_msisdn;
                            main_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                        }
                        case LDAP_RESULT_NO_SUCH_OBJECT:
                        {
                            // Check Matched DN
                            SDFLOG_DEBUG((B,  "MATCH DN [%s]", lc->matchedDN));
                            s = lc->matchedDN;
                            ss = strchr(s,',');
                            *ss = 0;
                            char uid[32];
                            uid[0] = '\0';
                            strcat(uid,"uid=");
                            strcat(uid, mw->instance->index_list[UID]->vals->value);

                            if(STRCASEEQ(s,"ds=SUBSCRIBER")){
                                // Add uid
                                main_state = AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE;
                                goto _add_subscribe;
                            }
                            else if(!STRCASEEQ(s,"o=AIS")){
                                // Add ds=SUBSCRIBER
                                goto _add_subscriber;
                            }
                            else if(!STRCASEEQ(s,"DC=C-NTDB")){
                                //add o=AIS
                                goto _add_ais;
                            }else{
                                //add CNTDB
                                goto _add_cntdb;
                            }
                            break;
                        }
                        default:
                            break;
                    }

                case AFSTATE_SUBSCRIBER_ADD_CNTDB:
_add_cntdb:
                    sprintf(base_dn, "dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"C-NTDB", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    sub_state = AFSTATE_SUBSCRIBER_ADD_AIS;
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                case AFSTATE_SUBSCRIBER_ADD_AIS:
_add_ais:
                    sprintf(base_dn, "o=AIS,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"AIS", NULL);
                    LBER_attrlist_add(&alist, "o", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "tenantConfiguration", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    sub_state = AFSTATE_SUBSCRIBER_ADD_SUBSCRIBER;
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                case AFSTATE_SUBSCRIBER_ADD_SUBSCRIBER:
_add_subscriber:
                    sprintf(base_dn, "ds=SUBSCRIBER,o=AIS,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"SUBSCRIBER", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    main_state = AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE;
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                default:
                    // Exception over here!!!
                    // Release Everything
                    SDFLOG_WARN((B, "No action on verify subscriber."))
                    break;
            }
        case AFSTATE_SUBSCRIBER_ADD_SUBSCRIBE:
        {
_add_subscribe:
            SDFLOG_DEBUG((B ,"Add subscribe state"));
            sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
            SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

            // Create rdn
            LBER_valuelist_add(&vlist,  mw->instance->index_list[UID]->vals->value, NULL);
            LBER_attrlist_add(&alist, "uid", vlist, NULL);

            // Create target DSA
            SDFLOG_DEBUG((B, "scalenumberDSA : %d",d02global.conf_warm.scaleNumberDSA))
            if(d02global.conf_warm.scaleNumberDSA > 0){
                char dsaId[16];
                int index = 0;
                HASH_COMPUTE(mw->instance->index_list[UID]->vals->value, strlen(mw->instance->index_list[UID]->vals->value),index);
                index = index % d02global.conf_warm.scaleNumberDSA;
                mw->instance->dsaID = d02global.conf_warm.remoteDSA[index];
                sprintf(dsaId,"%d",mw->instance->dsaID);
                vlist = NULL;
                LBER_valuelist_add(&vlist,dsaId, NULL);
                LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
            }

            // Create objectClass
            vlist = NULL;
            LBER_valuelist_add(&vlist, "subscriber", NULL);
            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
            LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

            tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
            LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            main_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
            sub_state = AFSTATE_SUBSCRIBER_IDLE;
            break;
        } // End main state
        case AFSTATE_SUBSCRIBER_ADD_MSISDN:
_add_msisdn:
            if(mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add msisdn State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=MSISDN,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"MSISDN", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_MSISDN_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[MSISDN]->vals->next;  // Set ber_vlist to point to next value of MSISDN
                    sprintf(base_dn, "msisdn=%s,dc=MSISDN,dc=C-NTDB", mw->instance->index_list[MSISDN]->vals->value);
                    if(mw->instance->result_code[MSISDN] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "msisdnAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }
                    sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_MSISDN_MULTI_ALIAS){
                    if( mw->instance->ber_vlist != mw->instance->index_list[MSISDN]->vals){ // Has next MSISDN?
                        sprintf(base_dn, "msisdn=%s,dc=MSISDN,dc=C-NTDB", mw->instance->ber_vlist->value);
                            SDFLOG_DEBUG((B, "Add DN[%s](multi-alias)", base_dn));
                            // Create rdn
                            LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                            LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                            // Create Member
                            vlist = NULL;
                            char uid[256];
                            uid[0] = '\0';
                            sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                            LBER_valuelist_add(&vlist,uid, NULL);
                            LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                            // Create target DSA
                            if(d02global.conf_warm.scaleNumberDSA > 0){
                                char dsaId[16];
                                sprintf(dsaId,"%d",mw->instance->dsaID);
                                vlist = NULL;
                                LBER_valuelist_add(&vlist,dsaId, NULL);
                                LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                                SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                            }

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "msisdnAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                            LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                            tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                            LDAP_ber_free(b_attrs);
                            if (control != NULL) SDF_FREE(control);
                            mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                            break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_IMSI;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                }// End sub state
            }// End if MSISDN
        case AFSTATE_SUBSCRIBER_ADD_IMSI:
//_add_imsi:
            if(mw->instance->index_list[IMSI] != NULL && mw->instance->index_list[IMSI]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add imsi State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=IMSI,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"IMSI", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMSI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMSI_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[IMSI]->vals->next;  // Set ber_vlist to point to next value of IMSI
                    sprintf(base_dn, "imsi=%s,dc=IMSI,dc=C-NTDB", mw->instance->index_list[IMSI]->vals->value);
                    if(mw->instance->result_code[IMSI] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[IMSI]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "imsi", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "imsiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    } // End check ldap response.
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMSI_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMSI_MULTI_ALIAS){
                    if( mw->instance->ber_vlist != mw->instance->index_list[IMSI]->vals){ // Has next IMSI?
                        sprintf(base_dn, "imsi=%s,dc=IMSI,dc=C-NTDB",mw->instance->ber_vlist ->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "imsi", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "imsiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_IMPU;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End if IMSI
        case AFSTATE_SUBSCRIBER_ADD_IMPU:
//_add_impu:
            if(mw->instance->index_list[IMPU] != NULL && mw->instance->index_list[IMPU]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add impu State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=IMPU,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"IMPU", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMPU_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMPU_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[IMPU]->vals->next;  // Set ber_vlist to point to next value of IMPU
                    sprintf(base_dn, "publicId=%s,dc=IMPU,dc=C-NTDB", mw->instance->index_list[IMPU]->vals->value);
                    if(mw->instance->result_code[IMPU] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[IMPU]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "publicId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impuAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL,error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    } // End check ldap response

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMPU_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMPU_MULTI_ALIAS){
                    if( mw->instance->ber_vlist != mw->instance->index_list[IMPU]->vals){ // Has next IMPU?
                        sprintf(base_dn, "publicId=%s,dc=IMPU,dc=C-NTDB",mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "publicId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impuAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_IMPI;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_IMPI:
//_add_impi:
            if(mw->instance->index_list[IMPI] != NULL && mw->instance->index_list[IMPI]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add impi State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=IMPI,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"IMPI", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMPI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMPI_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[IMPI]->vals->next;  // Set ber_vlist to point to next value of IMPI
                    sprintf(base_dn, "privateId=%s,dc=IMPI,dc=C-NTDB", mw->instance->index_list[IMPI]->vals->value);
                    if(mw->instance->result_code[IMPI] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[IMPI]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "privateId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_IMPI_MULIT_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMPI_MULIT_ALIAS){
                    if(mw->instance->ber_vlist != mw->instance->index_list[IMPI]->vals){ // Has next IMPI?

                        sprintf(base_dn, "privateId=%s,dc=IMPI,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s](multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "privateId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "impiAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_EMAIL;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_EMAIL:
            if(mw->instance->index_list[EMAIL] != NULL && mw->instance->index_list[EMAIL]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add Email State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=EMAIL,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist,"EMAIL", NULL);
                        LBER_attrlist_add(&alist, "dc", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "dcObject", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        // Update state
                        sub_state = AFSTATE_SUBSCRIBER_ADD_EMAIL_ALIAS;
                        break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_EMAIL_ALIAS){
                        mw->instance->ber_vlist = mw->instance->index_list[EMAIL]->vals->next;  // Set ber_vlist to point to next value of Email
                        sprintf(base_dn, "email=%s,dc=EMAIL,dc=C-NTDB", mw->instance->index_list[EMAIL]->vals->value);
                        SDFLOG_DEBUG((B, "Currently Email(%s) : Next Email(%s)",mw->instance->index_list[EMAIL]->vals->value,mw->instance->ber_vlist->value));
                        if(mw->instance->result_code[EMAIL] == LDAP_RESULT_NO_SUCH_OBJECT){
                            SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                            // Create rdn
                            LBER_valuelist_add(&vlist,mw->instance->index_list[EMAIL]->vals->value, NULL);
                            LBER_attrlist_add(&alist, "email", vlist, NULL);

                            // Create Member
                            vlist = NULL;
                            char uid[256];
                            uid[0] = '\0';
                            sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                            LBER_valuelist_add(&vlist,uid, NULL);
                            LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                            // Create target DSA
                            if(d02global.conf_warm.scaleNumberDSA > 0){
                                char dsaId[16];
                                sprintf(dsaId,"%d",mw->instance->dsaID);
                                vlist = NULL;
                                LBER_valuelist_add(&vlist,dsaId, NULL);
                                LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                                SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                            }

                            // Create objectClass
                            vlist = NULL;
                            LBER_valuelist_add(&vlist, "emailAlias", NULL);
                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                            LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                            tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                            LDAP_ber_free(b_attrs);
                            if (control != NULL) SDF_FREE(control);
                        }else{
                            SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                            // Create rdn
                            BER_MODLIST *mlist = NULL;
                            vlist = NULL;
                            char uid[256];
                            uid[0] = '\0';
                            sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                            LBER_valuelist_add(&vlist,uid, NULL);
                            LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                            LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                            tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                            LDAP_ber_free(b_attrs);
                            if (control != NULL) SDF_FREE(control);
                        }
                        // Update state
                        sub_state = AFSTATE_SUBSCRIBER_ADD_EMAIL_MULTI_ALIAS;
                        break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_EMAIL_MULTI_ALIAS){
                    if( mw->instance->ber_vlist != mw->instance->index_list[EMAIL]->vals){ // Has next email?
                        sprintf(base_dn, "email=%s,dc=EMAIL,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (Multi-Alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "email", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);


                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "emailAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;  // Set ber_vlist to point to next value of Email

                        break;
                    }else{
                        // No anymore email
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_PARTNERID;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_PARTNERID:
            if(mw->instance->index_list[PARTNERID] != NULL && mw->instance->index_list[PARTNERID]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add PartnerId State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=PARTNERID,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"PARTNERID", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PARTNERID_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_PARTNERID_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[PARTNERID]->vals->next;  // Set ber_vlist to point to next value of PARTNERID
                    sprintf(base_dn, "partnerId=%s,dc=PARTNERID,dc=C-NTDB", mw->instance->index_list[PARTNERID]->vals->value);
                    if(mw->instance->result_code[PARTNERID] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[PARTNERID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "partnerId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "partnerAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PARTNERID_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_PARTNERID_MULTI_ALIAS){
                    if(mw->instance->ber_vlist != mw->instance->index_list[PARTNERID]->vals){ // Has next PARTNERID?
                        sprintf(base_dn, "partnerId=%s,dc=PARTNERID,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "partnerId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "partnerAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_BAID;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_BAID:
            if(mw->instance->index_list[BAID] != NULL && mw->instance->index_list[BAID]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add Baid State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=BA,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"BA", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_BAID_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_BAID_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[BAID]->vals->next;  // Set ber_vlist to point to next value of BAID
                    sprintf(base_dn, "baId=%s,dc=BA,dc=C-NTDB", mw->instance->index_list[BAID]->vals->value);
                    if(mw->instance->result_code[BAID] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[BAID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "baId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "baAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_BAID_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_BAID_MULTI_ALIAS){
                    if(mw->instance->ber_vlist != mw->instance->index_list[BAID]->vals){ // Has next BAID?
                        sprintf(base_dn, "baId=%s,dc=BA,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "baId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "baAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);

                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_DEVICEID;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_DEVICEID:
            if(mw->instance->index_list[DEVICE] != NULL && mw->instance->index_list[DEVICE]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add Device State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=DEVICE,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"DEVICE", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_DEVICEID_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_DEVICEID_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[DEVICE]->vals->next;  // Set ber_vlist to point to next value of DEVICE
                    sprintf(base_dn, "deviceId=%s,dc=DEVICE,dc=C-NTDB", mw->instance->index_list[DEVICE]->vals->value);
                    if(mw->instance->result_code[DEVICE] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[DEVICE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "deviceId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "deviceAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_DEVICEID_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_DEVICEID_MULTI_ALIAS){
                    if(mw->instance->ber_vlist != mw->instance->index_list[DEVICE]->vals){ // Has next DEVICE?
                        sprintf(base_dn, "deviceId=%s,dc=DEVICE,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "deviceId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "deviceAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_CAID;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_CAID:
            if(mw->instance->index_list[CAID] != NULL && mw->instance->index_list[CAID]->vals->len > 0){
                SDFLOG_DEBUG((B ,"Add caId State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "dc=CA,dc=C-NTDB");
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"CA", NULL);
                    LBER_attrlist_add(&alist, "dc", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "dcObject", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_CAID_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_CAID_ALIAS){
                    mw->instance->ber_vlist = mw->instance->index_list[CAID]->vals->next;  // Set ber_vlist to point to next value of CAID
                    sprintf(base_dn, "caId=%s,dc=CA,dc=C-NTDB", mw->instance->index_list[CAID]->vals->value);
                    if(mw->instance->result_code[CAID] == LDAP_RESULT_NO_SUCH_OBJECT){
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[CAID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "caId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "caAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }else{
                        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn));
                        // Create rdn
                        BER_MODLIST *mlist = NULL;
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_REPLACE, "aliasedObjectName", vlist, NULL);
                        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                        tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                    }

                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_CAID_MULTI_ALIAS;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_CAID_MULTI_ALIAS){
                    if(mw->instance->ber_vlist != mw->instance->index_list[CAID]->vals){ // Has next CAID?
                        sprintf(base_dn, "caId=%s,dc=CA,dc=C-NTDB", mw->instance->ber_vlist->value);
                        SDFLOG_DEBUG((B, "Add DN[%s] (multi-alias)", base_dn));
                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->ber_vlist->value, NULL);
                        LBER_attrlist_add(&alist, "caId", vlist, NULL);

                        // Create Member
                        vlist = NULL;
                        char uid[256];
                        uid[0] = '\0';
                        sprintf(uid,"uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",mw->instance->index_list[UID]->vals->value);
                        LBER_valuelist_add(&vlist,uid, NULL);
                        LBER_attrlist_add(&alist, "aliasedEntryName", vlist, NULL);

                        // Create target DSA
                        if(d02global.conf_warm.scaleNumberDSA > 0){
                            char dsaId[16];
                            sprintf(dsaId,"%d",mw->instance->dsaID);
                            vlist = NULL;
                            LBER_valuelist_add(&vlist,dsaId, NULL);
                            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
                            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
                        }

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "caAlias", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        
                        mw->instance->ber_vlist = mw->instance->ber_vlist->next;
                        break;
                    }else{
                        // No anymore msisdn
                        // Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    }
                } // End sub state
            } // End main state
        case AFSTATE_SUBSCRIBER_ADD_PROFILE:
            SDFLOG_DEBUG((B ,"Add Profile State"));
            switch(lc->result_code){
                case LDAP_RESULT_SUCCESS:
                case LDAP_RESULT_ENTRY_ALREADY_EXISTS:
                    sprintf(base_dn, "subdata=profile,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "subscriberSubdata", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                default:
                    SDFLOG_DEBUG((B, "Exception on add profile state"));
                    break;
            }
            // Update state
            main_state = AFSTATE_SUBSCRIBER_ADD_SERVICE;
            break;
        case AFSTATE_SUBSCRIBER_ADD_SERVICE:
//_add_service:
            SDFLOG_DEBUG((B ,"Add Service State"));
            switch(lc->result_code){
                case LDAP_RESULT_SUCCESS:
                case LDAP_RESULT_ENTRY_ALREADY_EXISTS:
                    sprintf(base_dn, "subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"services", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "subscriberSubdata", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                default:
                    SDFLOG_DEBUG((B, "Exception on add service state"));
                    break;
            }
            // Update stats
            main_state = AFSTATE_SUBSCRIBER_ADD_GUP;
            break;
        case AFSTATE_SUBSCRIBER_ADD_GUP:
            SDFLOG_DEBUG((B ,"Add GUP State"));
            if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                sprintf(base_dn, "ds=gup,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                // Create rdn
                LBER_valuelist_add(&vlist,"gup", NULL);
                LBER_attrlist_add(&alist, "ds", vlist, NULL);

                // Create objectClass
                vlist = NULL;
                LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                LDAP_ber_free(b_attrs);
                if (control != NULL) SDF_FREE(control);
                // Update state
                sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                break;
            }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILE){
                sprintf(base_dn, "subdata=profile,ds=gup,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                // Create rdn
                LBER_valuelist_add(&vlist,"profile", NULL);
                LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                // Create objectClass
                vlist = NULL;
                LBER_valuelist_add(&vlist, "v-gupCommon", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                LDAP_ber_free(b_attrs);
                if (control != NULL) SDF_FREE(control);
                // Update next state
                sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                break;
            }

            if(sub_state == AFSTATE_SUBSCRIBER_ADD_MSISDN){
                // Select next state
                sub_state = AFSTATE_SUBSCRIBER_ADD_IMSI;

                if (mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                    sprintf(base_dn
                            , "msisdn=%s,subdata=profile,ds=gup,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
                            , mw->instance->index_list[MSISDN]->vals->value
                            , mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,mw->instance->index_list[MSISDN]->vals->value, NULL);
                    LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                    // Create members
                    vlist = NULL;
                    if(mw->instance->index_list[SUBSCRIPTIONSTATE] != NULL
                            && mw->instance->index_list[SUBSCRIPTIONSTATE]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SUBSCRIPTIONSTATE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, mw->instance->index_list[SUBSCRIPTIONSTATE]->name, vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[SERVICEPROFILEID] != NULL
                            && mw->instance->index_list[SERVICEPROFILEID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SERVICEPROFILEID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "serviceProfileId", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[GUPDATASERVLIFESTYLE] != NULL
                            && mw->instance->index_list[GUPDATASERVLIFESTYLE]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[GUPDATASERVLIFESTYLE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "gupDataServLifestyle", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[GUPAUTHENLEVEL] != NULL
                            && mw->instance->index_list[GUPAUTHENLEVEL]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[GUPAUTHENLEVEL]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "gupAuthenLevel", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[GUPREGISTRATIONLEVEL] != NULL
                            && mw->instance->index_list[GUPREGISTRATIONLEVEL]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[GUPREGISTRATIONLEVEL]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "gupRegistrationLevel", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[GUPLISTOFOPENID] != NULL
                            && mw->instance->index_list[GUPLISTOFOPENID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[GUPLISTOFOPENID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "gupListOfOpenId", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[PRIVATEIDLIST] != NULL
                            && mw->instance->index_list[PRIVATEIDLIST]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[PRIVATEIDLIST]->vals->value, NULL);
                        LBER_attrlist_add(&alist, mw->instance->index_list[PRIVATEIDLIST]->name, vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[IMPLICITREGSETID] != NULL
                            && mw->instance->index_list[IMPLICITREGSETID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[IMPLICITREGSETID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "implicitRegSetId", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[REGPRIVATEIDLIST] != NULL
                            && mw->instance->index_list[REGPRIVATEIDLIST]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[REGPRIVATEIDLIST]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "regPrivateIdList", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[REGISTRATIONSTATUS] != NULL
                            && mw->instance->index_list[REGISTRATIONSTATUS]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[REGISTRATIONSTATUS]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "registrationStatus", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[ALIAID] != NULL
                            && mw->instance->index_list[ALIAID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[ALIAID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "aliasId", vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[PFPASSWORD] != NULL
                            && mw->instance->index_list[PFPASSWORD]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[PFPASSWORD]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[PFPASSWORD]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[DS3PIN] != NULL
                            && mw->instance->index_list[DS3PIN]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3PIN]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[DS3PIN]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[SECRETQUESTION] != NULL
                            && mw->instance->index_list[SECRETQUESTION]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SECRETQUESTION]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[SECRETQUESTION]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[SECRETANSWER] != NULL
                            && mw->instance->index_list[SECRETANSWER]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SECRETANSWER]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[SECRETANSWER]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[ACCOUNTID] != NULL
                            && mw->instance->index_list[ACCOUNTID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[ACCOUNTID]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[ACCOUNTID]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[PRODUCTNOLIST] != NULL
                            && mw->instance->index_list[PRODUCTNOLIST]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[PRODUCTNOLIST]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[PRODUCTNOLIST]->name , vlist, NULL);
                    }

                    vlist = NULL;
                    if(mw->instance->index_list[MMTELPROFILEID] != NULL
                            && mw->instance->index_list[MMTELPROFILEID]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MMTELPROFILEID]->vals->value, NULL);
                        LBER_attrlist_add(&alist,mw->instance->index_list[MMTELPROFILEID]->name , vlist, NULL);
                    }

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "gupSubProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                } // End if MSISDN
            } // End sub state

            if(sub_state == AFSTATE_SUBSCRIBER_ADD_IMSI){
                sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILEID;
                if (mw->instance->index_list[IMSI] != NULL && mw->instance->index_list[IMSI]->vals->len > 0){
                    sprintf(base_dn
                            , "imsi=%s,subdata=profile,ds=gup,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
                            , mw->instance->index_list[IMSI]->vals->value
                            , mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,mw->instance->index_list[IMSI]->vals->value, NULL);
                    LBER_attrlist_add(&alist, "imsi", vlist, NULL);

                    // Create members
                    vlist = NULL;
                    if(mw->instance->index_list[SUBSCRIPTIONSTATE] != NULL
                            && mw->instance->index_list[SUBSCRIPTIONSTATE]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SUBSCRIPTIONSTATE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "subscriptionState", vlist, NULL);
                    }
                    vlist = NULL;
                    if(mw->instance->index_list[MSISDN] != NULL
                            && mw->instance->index_list[MSISDN]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);
                    }
                    vlist = NULL;
                    if(mw->instance->index_list[MSCADDRESS] != NULL
                            && mw->instance->index_list[MSCADDRESS]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MSCADDRESS]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "mscAddress", vlist, NULL);
                    }
                    vlist = NULL;
                    if(mw->instance->index_list[VLRNUMBER] != NULL
                            && mw->instance->index_list[VLRNUMBER]->vals->len > 0){
                        LBER_valuelist_add(&vlist, mw->instance->index_list[VLRNUMBER]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "vlrNumber", vlist, NULL);
                    }

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "gupSimProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, NULL, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    break;
                } // End if IMSI
            } // End sub state

            if(sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILEID){
                /* Set next state */
                sub_state = AFSTATE_SUBSCRIBER_IDLE;
                main_state = AFSTATE_SUBSCRIBER_ADD_PTS;
            }// End sub state
        case AFSTATE_SUBSCRIBER_ADD_PTS:
            if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                if(mw->instance->index_list[PTS] != NULL && STRCASEEQ(mw->instance->index_list[PTS]->vals->value,"YES")){
                    SDFLOG_DEBUG((B ,"Add PTS State"));
                    sprintf(base_dn, "ds=pts,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"pts", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_SERVICE;
                    main_state = AFSTATE_SUBSCRIBER_ADD_PTS;
                    break;
                } // End if PTS
                else {
                    // Update state
                    main_state = AFSTATE_SUBSCRIBER_ADD_AEMF;
                }
            }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_SERVICE){
                SDFLOG_DEBUG((B ,"Add PTS State"));
                sprintf(base_dn, "ds=Service,ds=pts,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                // Create rdn
                LBER_valuelist_add(&vlist,"Service", NULL);
                LBER_attrlist_add(&alist, "ds", vlist, NULL);

                // Create objectClass
                vlist = NULL;
                LBER_valuelist_add(&vlist, "ptsServiceProfile", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                LDAP_ber_free(b_attrs);
                if (control != NULL) SDF_FREE(control);
                // Update state
                sub_state = AFSTATE_SUBSCRIBER_IDLE;
                main_state = AFSTATE_SUBSCRIBER_ADD_AEMF;
                break;
            }
        case AFSTATE_SUBSCRIBER_ADD_AEMF:
            if(mw->instance->index_list[AEMF] != NULL && STRCASEEQ(mw->instance->index_list[AEMF]->vals->value,"YES")){
                SDFLOG_DEBUG((B ,"Add AEMF State"));
                sprintf(base_dn, "ds=aemf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                // Create rdn
                LBER_valuelist_add(&vlist,"aemf", NULL);
                LBER_attrlist_add(&alist, "ds", vlist, NULL);

                // Create objectClass
                vlist = NULL;
                LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                LDAP_ber_free(b_attrs);
                if (control != NULL) SDF_FREE(control);
                // Update state
                main_state = AFSTATE_SUBSCRIBER_ADD_AMF;
                break;
            } // End if AEMF
        case AFSTATE_SUBSCRIBER_ADD_AMF:
            if(mw->instance->index_list[AMF] != NULL && STRCASEEQ(mw->instance->index_list[AMF]->vals->value,"YES")){
                SDFLOG_DEBUG((B ,"Add AMF State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"amf", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILE){
                    sprintf(base_dn, "subdata=profile,ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "v-amfCommon", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update State
                    sub_state = AFSTATE_SUBSCRIBER_ADD_AMFACCOUNT;
                    break;
                }else if(sub_state == AFSTATE_SUBSCRIBER_ADD_AMFACCOUNT){
                    /* Optional Entry */
                    if(mw->instance->index_list[AMF_ACCOUNT_ID] != NULL && mw->instance->index_list[AMF_ACCOUNT_ID]->vals->len > 0){
                        sprintf(base_dn, "accountId=%s,subdata=profile,ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",
                        mw->instance->index_list[AMF_ACCOUNT_ID]->vals->value,
                        mw->instance->index_list[UID]->vals->value);
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "accountId", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "amfAccount", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        // Update State
                        sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                        break;                        
                    }else if(mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                        sprintf(base_dn, "accountId=mbb_personal_1,subdata=profile,ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "accountId", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "amfAccount", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        // Update State
                        sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                        break;
                    }else{
                        // Go to next state
                        sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                    }
                }  /* No else */
                if(sub_state == AFSTATE_SUBSCRIBER_ADD_MSISDN){
                    if(mw->instance->index_list[MSISDN] != NULL && mw->instance->index_list[MSISDN]->vals->len > 0){
                        sprintf(base_dn, "msisdn=%s,ds=amf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[MSISDN]->vals->value,mw->instance->index_list[UID]->vals->value);
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist,mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "v-amfProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        //Update state
                        main_state = AFSTATE_SUBSCRIBER_ADD_DS3;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                        break;
                    }else{
                        main_state = AFSTATE_SUBSCRIBER_ADD_DS3;
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    } // End if MSISDN
                } // End sub state
            } // End Main state
        case AFSTATE_SUBSCRIBER_ADD_DS3:
            if(mw->instance->index_list[DS3] != NULL && STRCASEEQ(mw->instance->index_list[DS3]->vals->value, "YES")){
                SDFLOG_DEBUG((B ,"Add DS3 State"));
                if(sub_state == AFSTATE_SUBSCRIBER_IDLE){
                    sprintf(base_dn, "ds=ds3,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"ds3", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                    main_state = AFSTATE_SUBSCRIBER_ADD_DS3;
                    break;
                }else if ( sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILE ){
                    sprintf(base_dn, "subdata=profile,ds=ds3,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "v-ds3common", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_SUBPROFILE;
                    break;
                }else if ( sub_state == AFSTATE_SUBSCRIBER_ADD_SUBPROFILE ){
                    sprintf(base_dn, "subdata=ds3profile,subdata=profile,ds=ds3,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"ds3profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);


                    if(mw->instance->index_list[DS3_POLITE_DEGREE] != NULL
                            && mw->instance->index_list[DS3_POLITE_DEGREE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_POLITE_DEGREE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3politeDegree", vlist, NULL);
                    }

                    if(mw->instance->index_list[DS3_BRANDID] != NULL
                            && mw->instance->index_list[DS3_BRANDID]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_BRANDID]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3brandId", vlist, NULL);
                    }

                    if(mw->instance->index_list[DS3_SPNAME] != NULL
                            && mw->instance->index_list[DS3_SPNAME]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_SPNAME]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3spName", vlist, NULL);
                    }

                    if(mw->instance->index_list[DS3_REGISTRATION_STATUS] != NULL
                            && mw->instance->index_list[DS3_REGISTRATION_STATUS]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_REGISTRATION_STATUS]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3registrationStatus", vlist, NULL);
                    }

                    if(mw->instance->index_list[LANGUAGE] != NULL
                            && mw->instance->index_list[LANGUAGE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[LANGUAGE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "language", vlist, NULL);
                    }

                    if(mw->instance->index_list[IVR_LANGUAGE] != NULL
                            && mw->instance->index_list[IVR_LANGUAGE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[IVR_LANGUAGE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ivrLanguage", vlist, NULL);
                    }

                    if(mw->instance->index_list[SMS_LANGUAGE] != NULL
                            && mw->instance->index_list[SMS_LANGUAGE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[SMS_LANGUAGE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "smsLanguage", vlist, NULL);
                    }

                    if(mw->instance->index_list[USSD_LANGUAGE] != NULL
                            && mw->instance->index_list[USSD_LANGUAGE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[USSD_LANGUAGE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ussdLanguage", vlist, NULL);
                    }

                    if(mw->instance->index_list[EMAIL_LANGUAGE] != NULL
                            && mw->instance->index_list[EMAIL_LANGUAGE]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[EMAIL_LANGUAGE]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "emailLanguage", vlist, NULL);
                    }

                    if(mw->instance->index_list[PREFERENCES] != NULL
                            && mw->instance->index_list[PREFERENCES]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[PREFERENCES]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "preferences", vlist, NULL);
                    }

                    if(mw->instance->index_list[DS3_CUSTOMER_CATEGORY] != NULL
                            && mw->instance->index_list[DS3_CUSTOMER_CATEGORY]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_CUSTOMER_CATEGORY]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3customerCategory", vlist, NULL);
                    }

                    if(mw->instance->index_list[DS3_CUSTOMER_SUBCATEGORY] != NULL
                            && mw->instance->index_list[DS3_CUSTOMER_SUBCATEGORY]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[DS3_CUSTOMER_SUBCATEGORY]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "ds3customerSubCategory", vlist, NULL);
                    }

                    if(mw->instance->index_list[ADDRESS] != NULL
                            && mw->instance->index_list[ADDRESS]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[ADDRESS]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "address", vlist, NULL);
                    }

                    if(mw->instance->index_list[BIRTHDAY] != NULL
                            && mw->instance->index_list[BIRTHDAY]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[BIRTHDAY]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "birthday", vlist, NULL);
                    }

                    if(mw->instance->index_list[EMAIL] != NULL
                            && mw->instance->index_list[EMAIL]->vals->len > 0){
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, mw->instance->index_list[EMAIL]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "email", vlist, NULL);
                    }

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "ds3subProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_MSISDN;
                    break;
                }else if ( sub_state == AFSTATE_SUBSCRIBER_ADD_MSISDN ){
                    if( (mw->instance->index_list[MSISDN] != NULL) && (mw->instance->index_list[MSISDN]->vals->len > 0) ){
                        sprintf(base_dn, "msisdn=%s,ds=ds3,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB"
                                , mw->instance->index_list[MSISDN]->vals->value
                                , mw->instance->index_list[UID]->vals->value);
                        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                        // Create rdn
                        LBER_valuelist_add(&vlist, mw->instance->index_list[MSISDN]->vals->value, NULL);
                        LBER_attrlist_add(&alist, "msisdn", vlist, NULL);

                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "v-ds3profile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                        tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                        LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        // Update state
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                        main_state = AFSTATE_SUBSCRIBER_ADD_AAA;
                        break;
                    }else{
                        // Update state
                        sub_state = AFSTATE_SUBSCRIBER_IDLE;
                        main_state = AFSTATE_SUBSCRIBER_ADD_AAA;
                    }// End sub state
                }// End main state
            } // End createDS3
        case AFSTATE_SUBSCRIBER_ADD_AAA:
            if(mw->instance->index_list[AAA] != NULL && STRCASEEQ(mw->instance->index_list[AAA]->vals->value, "YES")){
                SDFLOG_DEBUG((B ,"Add AAA State"));
                if( sub_state == AFSTATE_SUBSCRIBER_IDLE ){
                    sprintf(base_dn, "ds=aaa,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"aaa", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_DOCSIS;
                    main_state = AFSTATE_SUBSCRIBER_ADD_AAA;
                    break;
                }else if ( sub_state == AFSTATE_SUBSCRIBER_ADD_DOCSIS ){
                    sprintf(base_dn, "ds=docsis,ds=aaa,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"docsis", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                    break;
                }else if ( sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILE ){
                    sprintf(base_dn, "subdata=profile,ds=docsis,ds=aaa,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "v-docsisCommon", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    main_state = AFSTATE_SUBSCRIBER_ADD_STB;
                    break;
                }
            } //End create aaa
        case AFSTATE_SUBSCRIBER_ADD_STB:
            if(mw->instance->index_list[STB] != NULL && STRCASEEQ(mw->instance->index_list[STB]->vals->value, "YES")){
                SDFLOG_DEBUG((B ,"Add STB State"));
                if( sub_state == AFSTATE_SUBSCRIBER_IDLE ){
                    sprintf(base_dn, "ds=stb,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"stb", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    main_state = AFSTATE_SUBSCRIBER_ADD_SLF;
                    break;
                }
            } //End create slf
        case AFSTATE_SUBSCRIBER_ADD_SLF:
            if(mw->instance->index_list[SLF] != NULL && STRCASEEQ(mw->instance->index_list[SLF]->vals->value, "YES")){
                SDFLOG_DEBUG((B ,"Add SLF State"));
                if( sub_state == AFSTATE_SUBSCRIBER_IDLE ){
                    sprintf(base_dn, "ds=slf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"slf", NULL);
                    LBER_attrlist_add(&alist, "ds", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_ADD_PROFILE;
                    main_state = AFSTATE_SUBSCRIBER_ADD_SLF;
                    break;
                }else if( sub_state == AFSTATE_SUBSCRIBER_ADD_PROFILE ){
                    sprintf(base_dn, "subdata=profile,ds=slf,subdata=services,uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", mw->instance->index_list[UID]->vals->value);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn));

                    // Create rdn
                    LBER_valuelist_add(&vlist,"profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);

                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "v-slfCommon", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, &ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
                    LDAP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
                    // Update state
                    sub_state = AFSTATE_SUBSCRIBER_IDLE;
                    main_state = AFSTATE_SUBSCRIBER_WAIT_CLOSE;
                    break;
                }
            } //End create slf
        case AFSTATE_SUBSCRIBER_WAIT_CLOSE:
            main_state = AFSTATE_SUBSCRIBER_IDLE;
            lc->result_code = LDAP_RESULT_SUCCESS;
            sprintf(lc->matchedDN, "uid=%s,"ROOT_DB, mw->instance->index_list[UID]->vals->value);
            break;
        default:
            // Exception over here!!!
            // Release Everything
            SDFLOG_ERROR((B, "No action on main state!!!"))
            main_state = AFSTATE_SUBSCRIBER_IDLE;
            lc->result_code = LDAP_RESULT_OPERATION_ERROR;
            strcpy(lc->diagnosticMessage,"method state error");
            break;
    } // End main state

    if (ber != NULL && l_clnt_send_msg(ber) != 0 )
    {
        SDFLOG_FATAL((B, "Cannot send ldap request."));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot send ldap request");
        return AFSTATE_SUBSCRIBER_IDLE;
    }

    if(main_state == AFSTATE_SUBSCRIBER_IDLE){
        return main_state;
    }

    /* Update Instance */
    mw->instance->main_state = main_state;
    mw->instance->sub_state = sub_state;

    /* Create new edb */
    MWRAPPER *nmw;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        strcpy(error, "Can not allocate memory");
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        lc->result_code = LDAP_RESULT_OTHER;
        strcpy(lc->diagnosticMessage, "Cannot allocate memory.");
        return AFSTATE_SUBSCRIBER_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;

    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);
    return main_state;
}

static int af_find_uid(AFINSTANCE *instance, BER_ATTRLIST **alist,char *uid){
    static char func[] = "af_find_uid";
    BER_ATTRLIST *p_alist;
    p_alist = *alist;
    char full_name[256];
    full_name[0]='\0';
    instance->identity_name[0] = '\0';
    //find uid in attr list.
    if(alist == NULL){
        SDFLOG_ERROR((B, "No attribrute list."))
        return -1;
    }
    while(p_alist){
        SDFLOG_DEBUG((B, "Attribute [%s]", p_alist->name));
        if(STREQ(p_alist->name, "msisdn")
                ||STREQ(p_alist->name, "imsi")
                ||STREQ(p_alist->name, "impu")
                ||STREQ(p_alist->name, "impi")
                ||STREQ(p_alist->name, "email")
                ||STREQ(p_alist->name, "baId")
                ||STREQ(p_alist->name, "caId")
                ||STREQ(p_alist->name, "deviceId")
                ||STREQ(p_alist->name, "partnerId")){
            if(p_alist->vals->len > 0){
                SDFLOG_DEBUG((B, "Append [%s] -> [%s]", p_alist->vals->value,full_name));
                if( instance->identity_name[0] == '\0'){
                    strcpy(instance->identity_name, p_alist->name);
                    strcpy(instance->identity_value, p_alist->vals->value);
                }
                (void)strcat(full_name, p_alist->vals->value);
            }
        }else if(STREQ(p_alist->name, "uid")){
            if(p_alist->vals->len > 0){
                SDFLOG_DEBUG((B, "uid [%s]", p_alist->vals->value))
                strcpy(uid, p_alist->vals->value);
                strcpy(instance->identity_name,"uid");
                strcpy(instance->identity_value, p_alist->vals->value);
                return 1;
            }
        }
        p_alist = p_alist->next;
        if(p_alist == *alist){
            break;
        }
    }

    strcpy(instance->key_uid_name, full_name);
    af_gen_uid(instance, uid);
    // Generate new uid
    // UID : "66:time_prefix[3]:time_hash[10]"
    unsigned int key_identity;
    BER_VALLIST *bvalue = NULL;
    HASH_COMPUTE(full_name,strlen(full_name),key_identity);
    SDFLOG_DEBUG((B, "Identity key [%s] -> [%u]", full_name, key_identity))
    sprintf(full_name, "%lu%u", time(NULL), key_identity);
    HASH_COMPUTE(full_name,strlen(full_name),key_identity);
    sprintf(uid,"66%.*s%010u",3,full_name,key_identity);
    LBER_valuelist_add(&bvalue,uid,NULL);
    LBER_attrlist_add(alist,"uid",bvalue,NULL);
    return 0;
}

static int make_index(AFINSTANCE *instance, BER_ATTRLIST *alist){
    if(alist == NULL){
        return -1;
    }

    BER_ATTRLIST *p_alist;
    p_alist = alist;
    while(p_alist){
        if(STRCASEEQ(p_alist->name, "msisdn")){
            instance->index_list[MSISDN] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "imsi")){
            instance->index_list[IMSI] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "impu") || STRCASEEQ(p_alist->name, "publicId")){
            instance->index_list[IMPU] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "impi") || STRCASEEQ(p_alist->name, "privateId")){
            instance->index_list[IMPI] = p_alist;
        }else if(STRCASEEQ(p_alist->name,"uid")){
            instance->index_list[UID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "creategup")){
            instance->index_list[GUP] = p_alist;
        }else if(STRCASEEQ(p_alist->name,"baId")){
            instance->index_list[BAID] = p_alist;
        }else if(STRCASEEQ(p_alist->name,"caId")){
            instance->index_list[CAID] = p_alist;
        }else if(STRCASEEQ(p_alist->name,"deviceId")){
            instance->index_list[DEVICE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createaemf")){
            instance->index_list[AEMF] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createamf")){
            instance->index_list[AMF] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createpts")){
            instance->index_list[PTS] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createds3")){
            instance->index_list[DS3] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createaaa")){
            instance->index_list[AAA] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createslf")){
            instance->index_list[SLF] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "createstb")){
            instance->index_list[STB] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "email")){
            instance->index_list[EMAIL] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "partnerId")){
            instance->index_list[PARTNERID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "mscAddress")){
            instance->index_list[MSCADDRESS] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "vlrnumber")){
            instance->index_list[VLRNUMBER] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "gupdataservlifestyle")){
            instance->index_list[GUPDATASERVLIFESTYLE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "serviceProfileId")){
            instance->index_list[SERVICEPROFILEID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "addIfExist")){
            instance->index_list[ADDIFEXIST] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "subscriptionState")){
            instance->index_list[SUBSCRIPTIONSTATE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "gupAuthenLevel")){
            instance->index_list[GUPAUTHENLEVEL] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "gupRegistrationLevel")){
            instance->index_list[GUPREGISTRATIONLEVEL] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "gupListOfOpenId")){
            instance->index_list[GUPLISTOFOPENID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "privateIdList")){
            instance->index_list[PRIVATEIDLIST] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "implicitRegSetId")){
            instance->index_list[IMPLICITREGSETID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "regPrivateIdList")){
            instance->index_list[REGPRIVATEIDLIST] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "registrationStatus")){
            instance->index_list[REGISTRATIONSTATUS] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "aliasId")){
            instance->index_list[ALIAID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "pfPassword")){
            instance->index_list[PFPASSWORD] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3pin")){
            instance->index_list[DS3PIN] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "secretQuestion")){
            instance->index_list[SECRETQUESTION] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "secretAnswer")){
            instance->index_list[SECRETANSWER] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "accountId")){
            instance->index_list[ACCOUNTID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "productNoList")){
            instance->index_list[PRODUCTNOLIST] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "mmTelProfileId")){
            instance->index_list[MMTELPROFILEID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3politeDegree")){
            instance->index_list[DS3_POLITE_DEGREE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3brandId")){
            instance->index_list[DS3_BRANDID] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3spName")){
            instance->index_list[DS3_SPNAME] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3registrationStatus")){
            instance->index_list[DS3_REGISTRATION_STATUS] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "language")){
            instance->index_list[LANGUAGE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ivrLanguage")){
            instance->index_list[IVR_LANGUAGE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "smsLanguage")){
            instance->index_list[SMS_LANGUAGE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ussdLanguage")){
            instance->index_list[USSD_LANGUAGE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "emailLanguage")){
            instance->index_list[EMAIL_LANGUAGE] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "preferences")){
            instance->index_list[PREFERENCES] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3customerCategory")){
            instance->index_list[DS3_CUSTOMER_CATEGORY] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3customerSubCategory")){
            instance->index_list[DS3_CUSTOMER_SUBCATEGORY] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "ds3customerSegment")){
            instance->index_list[DS3_CUSTOMER_SEGMENT] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "address")){
            instance->index_list[ADDRESS] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "birthday")){
            instance->index_list[BIRTHDAY] = p_alist;
        }else if(STRCASEEQ(p_alist->name, "addAmfAccountId")){
                instance->index_list[AMF_ACCOUNT_ID] = p_alist;
        }
        p_alist = p_alist->next;
        if(p_alist == alist){
            break;
        }
    }

    return 0;
}

#define CHECK_MANDATORY(_rec_type, sess, _instance, _param_name, _ref_id){               \
    if(_instance == NULL){                                                      \
        SDFLOG_ERROR((B, "Not found mandatory [%s]",_param_name));              \
/*        METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid parameter");*/\
        write_CDR2("SDF", _ref_id, _rec_type,"failed,40300,not found mandatory[%s]", _param_name);\
        return -2;                                                              \
    }                                                                           \
}

/* 20150706040302+700 ==> 20150706:040302 */
static int
amf_change_time_format(char ntime[],char *otime){
    memcpy(&ntime[0], otime,8);                         // copy [yyyymmdd]
    ntime[8] = ':';                                     // append ":"
    memcpy(&ntime[9], otime+8, 6);                      // copy [HHMMSS]
    ntime[15] = 0;                                      // null terminate
    return 0;
}


/************************\
 * createPackage Method *
\************************/
/* Detail
 *
 * */

static int
af_init_action_method_createPackage_v1(AFINSTANCE *instance,
                                      DSSESSION *sess,
                                      char *subsys,
                                      char *p,
                                      char *pp,
                                      unsigned int *tid,
                                      BER **ber,
                                      char *error){

    static char func[] = "af_init_action_method_createPackage_v1";
    URILIST *plist=NULL, *path=NULL;
    BER *b_attrs=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    char attrs[3][128];
    Control *control=NULL;

    UNUSED(subsys);

    // Create amf data
    instance->amf = SDF_MALLOC( sizeof(CRT_PKG_ST) );
    memset(instance->amf,0,sizeof(CRT_PKG_ST));

    while ( pp != NULL )
    {
        path = (URILIST*) SDF_MALLOC ( sizeof( *path ) );
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING( path->param, '/', MAX_URI_PATH_SIZE );
        GET_URI_STRING( path->value, '/', MAX_URI_PATH_SIZE );
        if ( (path->param[0] == 0) && (path->value[0] == 0) )
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ( (path->param[0] != 0) &&(path->value[0] == 0) )
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if ( path != NULL ) path->last_flag = 1;

    path = plist;

    if ( path == NULL )
    {
        BER_ATTRLIST *content_alist=NULL, *t_alist=NULL;

        // Parse json to attribute list.
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &content_alist, NULL)!=0) return -1;

        t_alist = content_alist;
        (void) memset( instance->index_list, 0 , sizeof(instance->index_list) );

        // Make index of input data
        while( t_alist ){

            SDFLOG_DEBUG((B, "Param[%s]", t_alist->name));
            if ( STRCASEEQ(t_alist->name, "identityName") ){
                instance->index_list[IDENTITY_NAME] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "identityValue") ){
                instance->index_list[IDENTITY_VALUE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "publicId") ){
                instance->index_list[IMPU] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "privateId") ){
                instance->index_list[IMPI] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "productOffer") ){
                instance->index_list[PRODUCT_OFFER] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "sendSMS") ){
                instance->index_list[SENDSMS] = t_alist;
                instance->amf->send_sms = (STRCASEEQ(t_alist->vals->value,"TRUE"))?1:0;
            }else if ( STRCASEEQ(t_alist->name, "version") ){
                instance->index_list[VERSION] = t_alist;
                strcpy(instance->amf->version, t_alist->vals->value);
            }else if ( STRCASEEQ(t_alist->name, "ds3politeDegree") ){
                instance->index_list[DS3_POLITE_DEGREE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "priority") ){
                instance->index_list[PRIORITY] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "locked") ){
                instance->index_list[LOCKED] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "activationDate") ){
                instance->index_list[ACTIVATION_DATE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "expiryTime") ){
                instance->index_list[EXPIRY_TIME] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "expiryGracePeriod") ){
                instance->index_list[EXPIRY_GRACE_PERIOD] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "refillStopExt")){
                instance->index_list[REFILL_STOP_EXT] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "refillNotifyTime") ){
                instance->index_list[REFILL_NOTIFY_TIME] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "preExpiryThr") ){
                instance->index_list[PREEXPIRY_THR] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "postExpiryThr") ){
                instance->index_list[POSTEXPIRY_THR] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "expiryNotifyTime") ){
                instance->index_list[EXPIRY_NOTIFY_TIME] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "persistCycle") ){
                instance->index_list[PERSIST_CYCLE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "lifecycleUnit") ){
                instance->index_list[LIFECYCLE_UNIT] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "lifecycleNo") ){
                instance->index_list[LIFECYCLE_NO] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "recurringLifecycle") ){
                instance->index_list[RECURRING_LIFECYCLE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3timeResolution") ){
                instance->index_list[DS3_TIME_RESOLUTION] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "counterRollover") ){
                instance->index_list[COUNTER_ROLLOVER] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "refillStopTime") ){
                instance->index_list[REFILL_STOP_TIME] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3CostCode") ){
                instance->index_list[DS3_COST_CODE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "amfDynamicBizInfo") ){
                instance->index_list[AMF_DYNAMIC_BIZ_INFO] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "amfOrderDate") ){
                instance->index_list[AMF_ORDER_DATE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "amfRecurringState") ){
                instance->index_list[AMF_RECURRING_STATE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "amfPackageRefKey") ){
                instance->index_list[AMF_PACKAGE_REFKEY] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3packageDesc") ){
                instance->index_list[DS3_PACKAGE_DESC] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3offlineNotifyPolicyControl") ){
                instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3recurringPolicyControl") ){
                instance->index_list[DS3_RECURRING_NOTIFY_POLICY_CONTROL] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "sponsorId") ){
                instance->index_list[SPONSOR_ID] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "counterState") ){
                instance->index_list[OFFER_STATE] = t_alist;
            }else if ( STRCASEEQ(t_alist->name, "ds3offlineNotifPolicyControl") ){
                instance->index_list[DS3_OFFLINE_NOTIFY_POLICY_CONTROL] = t_alist;
            }

            t_alist = t_alist->next;
            if(t_alist == content_alist){
                break;
            }

        }

        // Check Mandatory
        CHECK_MANDATORY(RECORD_MCPKG,sess, instance->index_list[IDENTITY_NAME], "identityName", instance->refer_id);
        CHECK_MANDATORY(RECORD_MCPKG,sess, instance->index_list[IDENTITY_VALUE], "identityValue", instance->refer_id);
        CHECK_MANDATORY(RECORD_MCPKG,sess, instance->index_list[PRODUCT_OFFER], "productOffer", instance->refer_id);
        CHECK_MANDATORY(RECORD_MCPKG,sess, instance->index_list[REFILL_STOP_TIME], "refillStopTime", instance->refer_id);
        CHECK_MANDATORY(RECORD_MCPKG,sess, instance->index_list[AMF_ORDER_DATE], "amfOrderDate", instance->refer_id);

        /* | start time | expiry time | DS3 Action | AMF Action |
         * ------------------------------------------------------
         * |    none    |   none      |  cur : cur |  cur : cur |
         * |    user    |   none      |  user: user|  user: user|
         * |
         * |
         */

        /* Checking Ativation is more than expiry */

        if( instance->index_list[ACTIVATION_DATE] != NULL && instance->index_list[EXPIRY_TIME] != NULL){
            struct tm  tm;
            (void) memset(&tm, 0, sizeof(struct tm));
            strptime(instance->index_list[ACTIVATION_DATE]->vals->value, "%Y%m%d%H%M%S+0700", &tm);
            time_t act = mktime(&tm);
            if( sdf_time_cmp(act,"%Y%m%d%H%M%S+0700",instance->index_list[EXPIRY_TIME]->vals->value) == -1){
                    SDFLOG_ERROR((B, "expiryTime[%s] is less than activationDate[%s]",
                                  instance->index_list[EXPIRY_TIME]->vals->value,
                                  instance->index_list[ACTIVATION_DATE]->vals->value))
//                    METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid parameter");
                    write_CDR2("SDF", instance->refer_id, RECORD_MCPKG,
                              RECORD_FORMAT_MCPKG",failed,40300,invalid expiryTime[%s]",
                              instance->index_list[IDENTITY_NAME]->vals->value,
                              instance->index_list[IDENTITY_VALUE]->vals->value,
                              instance->index_list[PRODUCT_OFFER]->vals->value,
                              instance->index_list[EXPIRY_TIME]->vals->value
                              );
                    return -2;
            }
        }

        // Set Activation and Expriry time
        char b_time[32];
        BER_VALLIST *vlist = NULL;
        BER_ATTRLIST *alist = NULL;
        time_t my_time;
        struct tm *my_tm = NULL;
        if (instance->index_list[ACTIVATION_DATE] == NULL ){//user not specific time
            time(&my_time);
            my_tm = localtime(&my_time);
            strftime(b_time,32,"%Y%m%d%H%M%S+0700", my_tm);
            LBER_valuelist_add(&vlist, b_time, error);
            LBER_attrlist_add(&alist, "activationDate", vlist, error);
            instance->index_list[ACTIVATION_DATE] = alist;
            LINKEDLIST_APPEND(content_alist,alist);
            amf_change_time_format(b_time, instance->index_list[ACTIVATION_DATE]->vals->value);
            strcpy(instance->amf->activation_time, b_time);
        }else{                                              //user specific time
            //change format time
            //20150705121090+700 ==> 20150705:121090
            amf_change_time_format(b_time, instance->index_list[ACTIVATION_DATE]->vals->value);
            strcpy(instance->amf->activation_time, b_time);
        }

        instance->amf->require_couter_manage = 1;           //require call amfMangeCouter

        if(instance->index_list[EXPIRY_TIME] == NULL){      //user not specific time, use same activateTime
            vlist = NULL;
            alist = NULL;
            LBER_valuelist_add(&vlist, instance->index_list[ACTIVATION_DATE]->vals->value, error);
            LBER_attrlist_add(&alist, "expiryTime", vlist, error);
            instance->index_list[EXPIRY_TIME] = alist;
            LINKEDLIST_APPEND(content_alist, alist);
            amf_change_time_format(b_time, instance->index_list[EXPIRY_TIME]->vals->value);
            strcpy(instance->amf->expriry_time, b_time);
            instance->amf->require_mod_expiry = 0;          //no require call amfMangeCounter
        }else{                                              //user specific time
            // Verify expiryTime
            if( sdf_time_cmp(time(NULL),
                             "%Y%m%d%H%M%S+0700",
                             instance->index_list[EXPIRY_TIME]->vals->value) < 0 ){
                SDFLOG_ERROR((B, "expiryTime[%s] is less than current time",instance->index_list[EXPIRY_TIME]->vals->value))
//                METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid parameter");
                write_CDR2("SDF", instance->refer_id, RECORD_MCPKG,
                          RECORD_FORMAT_MCPKG",failed,40300,invalid expiryTime[%s]",
                          instance->index_list[IDENTITY_NAME]->vals->value,
                          instance->index_list[IDENTITY_VALUE]->vals->value,
                          instance->index_list[PRODUCT_OFFER]->vals->value,
                          instance->index_list[EXPIRY_TIME]->vals->value
                          );
                return -2;
            }


            if( sdf_time_cmp(time(NULL),
                             "%Y%m%d%H%M%S+0700",
                             instance->index_list[ACTIVATION_DATE]->vals->value) <= 0 ){
                //Note: AMF require start == expiry for recurring
                //keep expiry to backup time for modify later in CRT_PKG_MOD_USER_INPUT state
                strcpy(instance->amf->usr_expiry_time, instance->index_list[EXPIRY_TIME]->vals->value);
                strcpy(instance->index_list[EXPIRY_TIME]->vals->value, instance->index_list[ACTIVATION_DATE]->vals->value);
                amf_change_time_format(b_time, instance->index_list[ACTIVATION_DATE]->vals->value);
                strcpy(instance->amf->expriry_time, b_time);
                instance->amf->require_mod_expiry = 1;          //require call amfMangeCounter
            }else{
                //Note: Package in the future
                //Using start and expiry following user input
                //No need modify expiry after call manageCounter
                amf_change_time_format(b_time, instance->index_list[EXPIRY_TIME]->vals->value);
                strcpy(instance->amf->expriry_time, b_time);
            }
        }

        // Verify refillStopTime
        if( sdf_time_cmp(time(NULL),
                         "%Y%m%d%H%M%S+0700",
                         instance->index_list[REFILL_STOP_TIME]->vals->value) < 0 ){
            SDFLOG_ERROR((B, "refillStopTime[%s] is less than current time",instance->index_list[REFILL_STOP_TIME]->vals->value))
//            METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid parameter");
            write_CDR2("SDF", instance->refer_id, RECORD_MCPKG,
                      RECORD_FORMAT_MCPKG",failed,40300,invalid refillStopTime[%s]",
                      instance->index_list[IDENTITY_NAME]->vals->value,
                      instance->index_list[IDENTITY_VALUE]->vals->value,
                      instance->index_list[PRODUCT_OFFER]->vals->value,
                      instance->index_list[REFILL_STOP_TIME]->vals->value);
            return -2;
        }

        // Check Identity name
        if( strcmp(instance->index_list[IDENTITY_NAME]->vals->value, "privateId") != 0){
            SDFLOG_ERROR((B, "This method doesn't support identity [%s]", instance->index_list[IDENTITY_NAME]->vals->value))
//            METHOD_GEN_HTTP_ERROR(sess, 403, 40300, "Missing or invalid paramester");
            write_CDR2("SDF", instance->refer_id, RECORD_MCPKG,
                      RECORD_FORMAT_MCPKG",failed,40300,not support identity[%s]",
                      instance->index_list[IDENTITY_NAME]->vals->value,
                      instance->index_list[IDENTITY_VALUE]->vals->value,
                      instance->index_list[PRODUCT_OFFER]->vals->value,
                      instance->index_list[IDENTITY_NAME]->vals->value);
            return -2;
        }

        // Setup default baseDN
        get_baseDN(instance->index_list[IDENTITY_NAME]->vals->value, instance->index_list[IDENTITY_VALUE]->vals->value, root_dn);
        strcpy(instance->identity_name, instance->index_list[IDENTITY_NAME]->vals->value);
        strcpy(instance->identity_value, instance->index_list[IDENTITY_VALUE]->vals->value);

        // Search ProductRunningNumber
        sprintf(base_dn, "subdata=amfProfile,subdata=profile,ds=amf,subdata=services,%s", root_dn);
        SDFLOG_DEBUG((B, "Search ProductRunningNumber DN[%s]", base_dn));

        strcpy(attrs[0],"amfProductRunningNo");
        strcpy(attrs[1],"objectClass");
        attrs[2][0] = '\0';
        LDAP_gen_ber_string(attrs, &b_attrs, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE,
                                       ber,
                                       base_dn,
                                       "base",
                                       "amfSubProfile",
                                       b_attrs->berval,
                                       b_attrs->len,
                                       LDAP_DEREF_ALWAYS,
                                       control,
                                       error);
        LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        instance->main_state = CRT_PKG_QUERY_RUNNING_NUMBER;
        instance->alist = content_alist;            // DON'T free it!
        instance->state = AFSTATE_METHOD;
        instance->method = METHOD_CREATEPACKAGE;
    }

return 0;
}


/************************\
 * modifyIdentity Method *
\************************/

/*
 * Detail
 *
 * (1) Check UID
 * (2) Check NEWUID
 * (3) if
 *      (3.1) if UID doesn't exist then return error;
 *      (3.2) if NEW UID Doesn't exist then ***;
 */


static int
af_init_action_method_modifyIdentity_v1(AFINSTANCE *instance,
                                      DSSESSION *sess,
                                      char *subsys,
                                      char *p,
                                      char *pp,
                                      unsigned int *tid,
                                      BER **ber,
                                      char *error){
    static char func[] = "af_init_action_method_changeNumber_v1";
    URILIST *plist=NULL, *path=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    BER *b_attrs=NULL;
    char *b_string=NULL;
    int blen = 0;
    int index = 0;
    UNUSED(subsys);
    Control *control=NULL;
    
    while ( pp != NULL )
    {
        path = (URILIST*) SDF_MALLOC ( sizeof( *path ) );
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING( path->param, '/', MAX_URI_PATH_SIZE );
        GET_URI_STRING( path->value, '/', MAX_URI_PATH_SIZE );
        if ( (path->param[0] == 0) && (path->value[0] == 0) )
        {
            SDFLOG_ERROR((B, "Invalid path structure"))
            write_CDR2("SDF", instance->refer_id, RECORD_MMID,"failed,invalid path structure");
            return -1;
        }
        else if ( (path->param[0] != 0) &&(path->value[0] == 0) )
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if ( path != NULL ) path->last_flag = 1;

    path = plist;

    if ( path == NULL )
    {
        BER_ATTRLIST *content_alist=NULL, *t_alist=NULL;
        int r = 0;
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &content_alist, NULL)!=0) return -1;

        t_alist = content_alist;

        (void) memset( instance->index_list, 0 , sizeof(instance->index_list) );

        while( t_alist ){

            if( STRCASEEQ(t_alist->name, "type") ){
                instance->index_list[IDENTITY_TYPE] = t_alist;
                ++r;
            }else if ( STRCASEEQ(t_alist->name, "identityName") ){
                instance->index_list[IDENTITY_NAME] = t_alist;
                ++r;
            }else if ( STRCASEEQ(t_alist->name, "identityValue") ){
                instance->index_list[IDENTITY_VALUE] = t_alist;
                ++r;
            }else if ( STRCASEEQ(t_alist->name, "UID") ){
                instance->index_list[UID] = t_alist;
                ++r;
            }else if ( STRCASEEQ(t_alist->name, "newUID") ){
                instance->index_list[NEWUID] = t_alist;
                ++r;
            }
            //else if{ STRCASEEQ(t_alist->name, "newUID") {
            // instance->index_list[NEWUID] = t_alist;
            // ++r;
            //}

            if(r == 5){ // 2' is number of input ie. existnumber, newnumber.
                break;
            }

            t_alist = t_alist->next;
            if(t_alist == content_alist){
                break;
            }
        }

        //Verify Madatory Parameter
        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[IDENTITY_TYPE],"type", instance->refer_id)
        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[IDENTITY_NAME],"identityName", instance->refer_id)
        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[IDENTITY_VALUE],"identityValue", instance->refer_id)
        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[UID],"UID", instance->refer_id)


        if(!(STREQ(instance->index_list[IDENTITY_TYPE]->vals->value, "modify") ||
             STREQ(instance->index_list[IDENTITY_TYPE]->vals->value, "add") ||
             STREQ(instance->index_list[IDENTITY_TYPE]->vals->value, "delete"))){
            write_CDR2("SDF", instance->refer_id, RECORD_MMID,"failed,invalid type");
            return -1;
        }
         if(STREQ(instance->index_list[IDENTITY_TYPE]->vals->value, "modify")){
            CHECK_MANDATORY(RECORD_MMID,sess, instance->index_list[NEWUID],"newUID", instance->refer_id);
            HASH_COMPUTE(instance->index_list[NEWUID]->vals->value, strlen(instance->index_list[UID]->vals->value),index);
        }else{
            HASH_COMPUTE(instance->index_list[UID]->vals->value, strlen(instance->index_list[UID]->vals->value),index);
        }

        index = index % d02global.conf_warm.scaleNumberDSA;
        instance->dsaID = d02global.conf_warm.remoteDSA[index];

        if( STREQ(instance->index_list[IDENTITY_TYPE]->vals->value, "delete")){
            // Search Alias
            get_baseDN(instance->index_list[IDENTITY_NAME]->vals->value,
                       instance->index_list[IDENTITY_VALUE]->vals->value,
                       base_dn);

            SDFLOG_DEBUG((B, "Search aliase DN[%s]", base_dn));
            LDAP_CREATE_CONTROL();
            *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, "base", "*", NULL, 0, LDAP_DEREF_ALWAYS, control, error);
            if (control != NULL) SDF_FREE(control);
            instance->main_state = MODIFY_IDENTIY_CCK_ALIAS;

        }else{
            //Checking UID
            sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", instance->index_list[UID]->vals->value);
            SDFLOG_DEBUG((B, "Search DN[%s]", base_dn));
            LDAP_CREATE_CONTROL();
            *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, "base", "*", b_string, blen, LDAP_DEREF_NEVER, control, error);
            instance->main_state = MODIFY_IDENTIY_CCK_UID;
        }

        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        
        instance->alist = content_alist;

        instance->state = AFSTATE_METHOD;
        instance->method = METHOD_MODIFYIDENTITY;
    }
    return 0;
}

/************************\
 * Change Number Method *
\************************/

/*
 * Operation Step.
 *
 * 1. Send ldap search request.[IDLE]ldapsearch()---->
 * 2. Check exiting uid wheather have or not.ldapsearch()<----
 *      a. if uid is exists then get uid and being modify rdn. ldapmodrdn()---->
 *          whatever, continue next. ldapmodrdn()<----
 *      b. Send modify rdn of gub subscriber. ldapmodrdn()---->
 *          whatever, continue next. ldapmodrdn()---->
 *      c. Send modiry rdn of amf subscriber. ldapmodrdn()---->
 *          Response to http server. ldapmodrdn()---->
 *
 * [ State Design ]
 *
 * +--->(IDLE)
 * |       |
 * |   (VER_UID)
 * |       |
 * |<------+
 * |       |(Can get UID)
 * | (MODRND_MSISDN)
 * |       |
 * |       |
 * |  (MODRDN_GUB)
 * |       |
 * |       |
 * |  (MODRDN_AMF)
 * |       |
 * +-------+
 */

static int
af_init_action_method_changeNumber_v1(AFINSTANCE *instance,
                                      DSSESSION *sess,
                                      char *subsys,
                                      char *p,
                                      char *pp,
                                      unsigned int *tid,
                                      BER **ber,
                                      char *error){
    static char func[] = "af_init_action_method_changeNumber_v1";
    URILIST *plist=NULL, *path=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    BER *b_attrs=NULL;
    char *b_string=NULL;
    int blen=0;
    Control *control=NULL;
    UNUSED(subsys);

    while ( pp != NULL )
    {
        path = (URILIST*) SDF_MALLOC ( sizeof( *path ) );
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING( path->param, '/', MAX_URI_PATH_SIZE );
        GET_URI_STRING( path->value, '/', MAX_URI_PATH_SIZE );
        if ( (path->param[0] == 0) && (path->value[0] == 0) )
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ( (path->param[0] != 0) &&(path->value[0] == 0) )
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if ( path != NULL ) path->last_flag = 1;

    path = plist;

    if ( path == NULL )
    {
        BER_ATTRLIST *content_alist=NULL, *t_alist=NULL;
        int r = 0;
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &content_alist, NULL)!=0) return -1;

        t_alist = content_alist;

        (void) memset( instance->index_list, 0 , sizeof(instance->index_list) );

        while( t_alist ){

            if( STRCASEEQ(t_alist->name, "existingNumber") ){
                instance->index_list[OLD_NUMBER] = t_alist;
                ++r;
            }

            if ( STRCASEEQ(t_alist->name, "newNumber") ){
                instance->index_list[NEW_NUMBER] = t_alist;
                ++r;
            }

            if(r == 2){ // 2' is number of input ie. existnumber, newnumber.
                break;
            }

            t_alist = t_alist->next;
            if(t_alist == content_alist){
                break;
            }
        }

        (void) memset( instance->result_code, -1, ( sizeof( int )*LAST_INDEX_NAME ) );

        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[OLD_NUMBER], "existingNumber", instance->refer_id)
        CHECK_MANDATORY(RECORD_MMID, sess, instance->index_list[NEW_NUMBER], "newNumber", instance->refer_id)
        sprintf(base_dn, "msisdn=%s,dc=MSISDN,dc=C-NTDB", instance->index_list[OLD_NUMBER]->vals->value);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, "base", "*", b_string, blen, LDAP_DEREF_NEVER, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        instance->alist = content_alist;
        instance->main_state = METHOD_STATE_MODRDN_MSISDN_ALIAS;
        instance->state = AFSTATE_METHOD;
        instance->method = METHOD_CHANGENUMBER;
    }
    return 0;
}

static int
af_init_action_method_insertSubscriber_v1(AFINSTANCE *instance,
                                          DSSESSION *sess,
                                          char *subsys,
                                          char *p,
                                          char *pp,
                                          unsigned int *tid,
                                          BER **ber,
                                          char *error)
{
    static char func[] = "af_init_action_method_insertSubscriber_v1";
    char uid[16];
    URILIST *plist=NULL, *path=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    BER *b_attrs=NULL;
    char *b_string=NULL;
    int blen=0;
    Control *control=NULL;
    struct timeval elap_tm;

    UNUSED(subsys);

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        BER_ATTRLIST *alist=NULL, *content_alist=NULL;
        BER_VALLIST *vlist=NULL;
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &content_alist, NULL)!=0) return -1;

        if((instance->is_orig_uid = af_find_uid(instance, &content_alist, uid)) < 0 ){
            return -1;
       }
        if(content_alist != NULL){
            init_watch(TMR1, error);
            make_index(instance,content_alist);
            stop_watch(TMR1, &elap_tm, error);
            SDFLOG_DEBUG((B, "\x1b[41m<<<<< make index elap time: %lu.%.6d >>>>>\x1b[0m", elap_tm.tv_sec, elap_tm.tv_usec))
        }

        (void)memset(instance->result_code,-1,sizeof(int)*LAST_INDEX_NAME);

        sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB",uid);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

        // Create rdn
        LBER_valuelist_add(&vlist, uid, NULL);
        LBER_attrlist_add(&alist, "uid", vlist, NULL);

        // Create objectClass
        vlist = NULL;
        LBER_valuelist_add(&vlist, "subscribe", NULL);
        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
        instance->alist = content_alist;
        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, "base", "*", b_string, blen, LDAP_DEREF_ALWAYS, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        //SDF_FREE(path);
        instance->main_state = AFSTATE_SUBSCRIBER_VERIFY_ALIAS;
        instance->sub_state = AFSTATE_SUBSCRIBER_IDLE;
        instance->state = AFSTATE_METHOD;
        instance->method = METHOD_INSERTSUBSCRIBER;
    }
    return 0;
}

// af_init_action_post_device_v1 creates an LDAP add request.
// return 0 if successful, otherwise -1.
static int
af_init_action_post_device_v1(DSSESSION *sess, char *p, \
        char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{

    static char func[] = "af_init_action_post_device_v1";
    //char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    BER_ATTRLIST *alist=NULL;
    BER_VALLIST *vlist=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char obj_class[128];
    obj_class[0] = '\0';
    BER *b_attrs=NULL;
    Control *control=NULL;
    dn[0] = 0;

    // Get pairs of key and value from URI
    // URI pattern is /v1/device/devdata/$devdata/deviceId/$deviceId.json
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Parse HTTP body
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, \
            &alist, obj_class)!=0) return -1;

        // Form base dn
        sprintf(base_dn, "%s,ds=DEVICE,o=AIS,dc=C-NTDB", dn);
        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
        sprintf(instance->default_base_dn, "%s", base_dn);

        // Create objectClass
        if(!obj_class[0]){ // Continue if not found objectClass
            vlist = NULL;
            LBER_valuelist_add(&vlist, "stbManagedDeviceProfile", NULL);
            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
            strcpy(instance->object_class, vlist->value);
        }else{
            strcpy(instance->object_class, obj_class);
        }

        // Create target DSA
        SDFLOG_DEBUG((B, "scalenumberDSA : %d",d02global.conf_warm.scaleNumberDSA))
        if(d02global.conf_warm.scaleNumberDSA > 0){
            char dsaId[16];
            int index = 0;
            HASH_COMPUTE(dn, strlen(dn),index);
            index = index % d02global.conf_warm.scaleNumberDSA;
            sprintf(dsaId,"%d",d02global.conf_warm.remoteDSA[index]);
            vlist = NULL;
            LBER_valuelist_add(&vlist,dsaId, NULL);
            LBER_attrlist_add(&alist, "masteredBy", vlist, NULL);
            SDFLOG_DEBUG((B, "Bypass to DSA : %s",dsaId))
        }

        // Generate BER encoding
        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, \
            b_attrs->berval, b_attrs->len, control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        
        return 0;
    }
    return 0;
}

// af_init_action_post_device_v1 creates an LDAP add request.
// return 0 if successful, otherwise -1.
static int
af_init_action_get_device_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_get_device_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    int b_len=0;
    char *b_string=NULL;
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;
    Control *control=NULL;
    BER *b_attrs=NULL;

    dn[0] = 0;
    strcpy(object, "*");
    strcpy(attrs[0], "objectClass");
    strcpy(attrs[1], "*");
    attrs[2][0] = 0;

    // Get pairs of key and value from URI
    // URI pattern is /v1/device/devdata/$devdata/deviceId/$deviceId.json
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_FILTER(object, buff);
        GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Form base dn
        sprintf(base_dn, "%s,ds=DEVICE,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, \
            object, b_string, b_len, LDAP_DEREF_ALWAYS,control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }
    return 0;
}


// af_init_action_post_device_v1 creates an LDAP add request.
// return 0 if successful, otherwise -1.
// e.g. /v1/device/devdata/$devdata/deviceId/$deviceId.json
static int
af_init_action_put_device_v1(DSSESSION *sess, char *p, char *pp, 
    unsigned int *tid, BER **ber,AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_put_device_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    BER *b_attrs=NULL;
    BER_MODLIST *mlist=NULL;
    Control *control=NULL;
    dn[0] = 0;

    // Get pairs of key and value from URI
    // URI pattern is /v1/device/devdata/$devdata/deviceId/$deviceId.json
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Parse HTTP body
//        if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) return -1;
        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);

        // Form base dn
        sprintf(base_dn, "%s,ds=DEVICE,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))

        // Generate BER encoding
        // LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, \
            b_attrs->berval, b_attrs->len, control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        
        return 0;
    }
    return 0;
}

// af_init_action_post_device_v1 creates an LDAP add request.
// return 0 if successful, otherwise -1.
static int
af_init_action_delete_device_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_post_device_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char nattr[LDAP_MAX_ATTR_NAME_SIZE];
    char vattr[LDAP_MAX_ATTR_VALUE_SIZE];
    BER *b_attrs=NULL;
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    Control *control=NULL;
    dn[0] = 0;
    nattr[0] = '\0';
    vattr[0] = '\0';
    buff[0] = '\0';

    // Get pairs of key and value from URI
    // URI pattern is /v1/device/devdata/$devdata/deviceId/$deviceId.json
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Form base dn
        sprintf(base_dn, "%s,ds=DEVICE,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "DELETE DN[%s]", base_dn))

        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        LDAP_GEN_DELETE_REQUEST();

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            //SDF_FREE(path);
            return -1;
        }

        return 0;
    }
    return 0;
}

//############################################################################//
//############################ Configuration #################################//
//############################################################################//

int
af_init_action_post_configuration_v1(DSSESSION *sess, char *p, \
        char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{

    static char func[] = "af_init_action_post_configuration_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    BER_ATTRLIST *alist=NULL;
    BER_VALLIST *vlist=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char obj_class[128];
    obj_class[0] = '\0';
    BER *b_attrs=NULL;
    Control *control=NULL;
    //int b_len=0;
    //char *b_string=NULL;

    dn[0] = 0;

    // Get pairs of key and value from URI
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    // Actual process begins here
    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Parse HTTP body
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, \
            &alist, obj_class)!=0) return -1;

        // Form base dn
        sprintf(base_dn, "%so=services,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))

        // Create rdn
        // LBER_valuelist_add(&vlist, path->value, NULL);
        // LBER_attrlist_add(&alist, path->param, vlist, NULL);

        // Create objectClass
        if(!obj_class[0]){ // Continue if not found objectClass
            vlist = NULL;
            if (strcmp(path->param, "serviceId") == 0) {
                LBER_valuelist_add(&vlist, "gupGlobalService", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                strcpy(instance->object_class, vlist->value);
            }
            else if (strcmp(path->param, "counterId") == 0) {
                LBER_valuelist_add(&vlist, "sidCounterTariff", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                strcpy(instance->object_class, vlist->value);
            }
            else if (strcmp(path->param, "version") == 0) {
                LBER_valuelist_add(&vlist, "sidProductOfferVersion", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                strcpy(instance->object_class, vlist->value);
            }
            else if (strcmp(path->param, "sidNotificationElem") == 0) {
                LBER_valuelist_add(&vlist, "sidNotificationElement", NULL);
                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                strcpy(instance->object_class, vlist->value);
            }
            else {
                SDFLOG_ERROR((B, "No default objectClass for the request body; checking from [%s]", path->param))
                // return -1; 
                // Must continue for the garbage collecting.
                // And let the LDAP return the error.
            }
            
        }
        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Generate BER encoding
        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, \
            b_attrs->berval, b_attrs->len, control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) {
            LDAP_ber_free(b_attrs);
        }
        if (control != NULL) SDF_FREE(control);

        return 0;
    }
    
}

int
af_init_action_get_configuration_v1(DSSESSION *sess, char *p, char *pp, 
    unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_get_configuration_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    BER *b_attrs=NULL;
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;
    int b_len=0;
    char *b_string=NULL;
    Control *control=NULL;
    dn[0] = 0;
    strcpy(object, "*");
    strcpy(attrs[0], "objectClass");
    strcpy(attrs[1], "*");
    attrs[2][0] = 0;

    // Get pairs of key and value from URI
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    // Actual process begins here
    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_FILTER(object, buff);
        GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Form base dn
        sprintf(base_dn, "%so=services,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, \
            object, b_string, b_len, LDAP_DEREF_ALWAYS, control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) {
            LDAP_ber_free(b_attrs);
        }
        if (control != NULL) SDF_FREE(control);

        return 0;   
    }

}

int
af_init_action_put_configuration_v1(DSSESSION *sess, char *p, char *pp, 
    unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_put_configuration_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    BER *b_attrs=NULL;
    Control *control=NULL;
    //int b_len=0;
    //char *b_string=NULL;
    BER_MODLIST *mlist=NULL;

    dn[0] = 0;

    // Get pairs of key and value from URI
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    // Actual process begins here
    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        
        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        // Parse HTTP body
 //       if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) {
 //           return -1;
 //       }

        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);

        // Form base dn
        sprintf(base_dn, "%so=services,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))
        
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, \
            b_attrs->berval, b_attrs->len, control, error);

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }

        if (b_attrs != NULL) {
            LDAP_ber_free(b_attrs);
        }
        if (control != NULL) SDF_FREE(control);
        return 0;

    }

}

int
af_init_action_delete_configuration_v1(DSSESSION *sess, char *p, char *pp, 
    unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_delete_configuration_v1";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char nattr[LDAP_MAX_ATTR_NAME_SIZE];
    char vattr[LDAP_MAX_ATTR_VALUE_SIZE];
    BER *b_attrs=NULL;
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    Control *control=NULL;
    int b_len=0;
    char *b_string=NULL;
    nattr[0] = '\0';
    vattr[0] = '\0';
    buff[0] = '\0';
    dn[0] = 0;

    UNUSED(b_len);
    UNUSED(b_string);
    // Get pairs of key and value from URI
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    // Actual process begins here
    path = plist;
    if (path==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);
        //GET_URI_FIELDS(buff);
        //GET_URI_FILTER(object, buff);
        //GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

        // Form base dn
        sprintf(base_dn, "%so=services,o=AIS,dc=C-NTDB", dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))

        // Free memory of plist
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);
        LDAP_CREATE_CONTROL();
        // Make a request to LDAP server
        LDAP_GEN_DELETE_REQUEST();

        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            //SDF_FREE(path);
            return -1;
        }

        return 0;   
    }

}

//############################################################################//
//############################################################################//
//############################################################################//

static int
af_init_action_post_subsystem_v1(DSSESSION *sess, char *subsys, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_post_subsystem_v1";
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    BER_ATTRLIST *alist=NULL;
    BER_VALLIST *vlist=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char obj_class[128];
    obj_class[0] = '\0';
    BER *b_attrs=NULL;
    Control *control=NULL;

    dn[0] = 0;
    GET_URI_STRING(pkid, '/', MAX_URI_PATH_SIZE);
    GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
    SDFLOG_DEBUG((B, "Primary Key [%s][%s]", pkid, pkvalue))
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(buff, pkvalue);
        GET_URI_PAGE(pkvalue, sess->format, buff);
        // Create rdn
        LBER_valuelist_add(&vlist, pkvalue, NULL);
        LBER_attrlist_add(&alist, "ds", vlist, NULL);
        
//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &alist, obj_class)!=0) return -1;

        if(!obj_class[0]){
            // Create objectClass
            vlist = NULL;
            LBER_valuelist_add(&vlist, "cntdbDsElement", NULL);
            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
            strcpy(instance->object_class, vlist->value);
        }else{
            strcpy(instance->object_class, obj_class);
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);        
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        //SDF_FREE(path);
        return 0;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);

//        if (af_get_http_body_add_param(sess->r_buffer->data + sess->header_length, &alist, obj_class)!=0) return -1;

        if( obj_class[0] ){
            strcpy(instance->object_class, obj_class);
        }
        if (strcmp(subsys, "pts")==0)
        {
            if (strcmp(path->value, "Profile")==0)
            {
                // Create rdn
                LBER_valuelist_add(&vlist, "Profile", NULL);
                LBER_attrlist_add(&alist, "ds", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "ptsPartnerProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }
            else if (strcmp(path->param, "ptsAppKeyName")==0)
            {
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "ptsAppKeyName", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "ptsServiceProfileEntry", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }
        else if (strcmp(subsys, "aemf")==0)
        {
            if (strcmp(path->param, "aemfArmedEventParam")==0)
            {
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "aemfArmedEventParam", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "aemfArmedEvent", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }
            else if (strcmp(path->param, "aemfArmedEventId")==0)
            {
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "aemfArmedEventId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "aemfArmedEventEntry", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }
        else if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
            if (strcmp(path->param, "subdata")==0)
            {
                if(STREQ(path->value, "loan")){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    if(!obj_class[0]){ // Continue if not found objectClass
                        // Create objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "amfLoanProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
                }else if(STREQ(path->value, "point")){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    // Create objectClass
                    if(!obj_class[0]){ // Continue if not found objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "amfPointProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
                }else if(STREQ(path->value, "amfProfile")){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    // Create objectClass
                    if(!obj_class[0]){ // Continue if not found objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "amfSubProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
                }else{
                    if(obj_class[0] == '\0'){ // Continue if not found objectClass
                        SDFLOG_ERROR((B, "Invalid path structure"))
                        return -1;
                    }else{
                        // Create rdn
                        LBER_valuelist_add(&vlist, path->value, NULL);
                        LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    }
                }

            }else if (STREQ(path->param, "amfAppKeyName")){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "amfAppKeyName", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "amfPointProfileEntry", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if (STREQ(path->param, "amfPointDate")){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "amfPointDate", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "amfPointJournal", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if (STREQ(path->param, "accountId")){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "accountId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "amfAccount", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }
        else if( strcmp(subsys, "aaa") == 0 ){
            if( strcmp(path->param, "privateId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "privateId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "docsisProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }else if ( strcmp(subsys, "ds3") == 0 ){
            if( strcmp(path->param, "subdata") == 0 ){
                if( strcmp(path->value, "ds3profile") == 0 ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    // Create objectClass
                    if(!obj_class[0]){ // Continue if not found objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "ds3subProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
                }else{
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    // Create objectClass
                    if(!obj_class[0]){ // Continue if not found objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "ds3security", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
                }
            }else if( strcmp(path->param, "ds3groupId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "ds3groupId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "ds3groupProfile", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "ds3aspId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "ds3aspId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "ds3trustedAsp", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }else if ( strcmp(subsys, "stb") == 0 ){
            if( strcmp(path->param, "privateId") == 0 ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, "privateId", vlist, NULL);
                    // Create objectClass
                    if(!obj_class[0]){ // Continue if not found objectClass
                        vlist = NULL;
                        LBER_valuelist_add(&vlist, "stbAppserviceProfile", NULL);
                        LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                        strcpy(instance->object_class, vlist->value);
                    }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }
            }
        }else if ( strcmp(subsys, "slf") == 0 ){
            if( strcmp(path->param, "systemId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "systemId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfServiceLocation", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "msisdn") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "msisdn", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfSessionCache", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "slfCacheType") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "slfCacheType", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfCacheContext", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "slfCacheId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "slfCacheId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfCacheAlias", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "slfAppId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "slfAppId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfApplContext", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "slfCachType") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "slfCachType", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfApplCacheContext", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else if( strcmp(path->param, "slfCacheId") == 0 ){
                // Create rdn
                LBER_valuelist_add(&vlist, path->value, NULL);
                LBER_attrlist_add(&alist, "slfCacheId", vlist, NULL);
                // Create objectClass
                if(!obj_class[0]){ // Continue if not found objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfSsTrans", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    strcpy(instance->object_class, vlist->value);
                }
            }else{
                if( obj_class[0] ){
                    // Create rdn
                    LBER_valuelist_add(&vlist, path->value, NULL);
                    LBER_attrlist_add(&alist, path->param, vlist, NULL);
                    // Create objectClass
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, obj_class, NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                }else{
                    sprintf(error, "Not support attribute[%s]", path->param);
                    SDFLOG_ERROR((B, "%s,", error))
                    LINKEDLIST_REMOVE(plist, path);
                    SDF_FREE(path);
                    return -1;
                }    
            }
        }
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);


        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy(instance->default_base_dn, base_dn);

        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
        LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        //SDF_FREE(path);
    }

    return 0;
}

static int
af_init_action_get_subscriber_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, void **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_get_subscriber_v1";
    char format[16];
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char attrs[MAX_SEARCH_ATTRS][128];
    char dn[LDAP_MAX_BASE_DN];
    URILIST *plist=NULL, *path=NULL;
    BER *b_attrs=NULL;
    char *b_string=NULL;
    Control *control=NULL;
    int b_len = 0;
    int i = 0;

    pkid[0] = '\0';
    pkvalue[0] = '\0';
    strcpy(object, "(objectClass=*)");
    strcpy(attrs[0], "*");
    attrs[1][0] = 0;


    if (pp==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }

    if (strchr(pp+1, '/')!=NULL)
    {

        GET_URI_STRING(pkid, '/', (int)sizeof(pkid));
        SDFLOG_DEBUG((B, "Key name[%s]" , pkid));

        if( strchr(pp+1,'/') != NULL ){
             /* v1/subscriber/$KEY/$VALUE/subdata/profile.json */
            GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,pkvalue))
        }else{
             /* v1/subscriber/$KEY/$VALUE.json */
            GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,buff))
        }
    }
    else
    {
        /* v1/subscriber/$MSISDN.json */
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "Param[%s]" ,buff))
    }

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {

        GET_URI_PAGE(pkvalue, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_SCOPE(scope, buff);
        GET_URI_FILTER(object, buff);
        //sprintf(scope,"%s","one");

        // Not found PKVALUE
        if(pkvalue[0] == '\0'){
            strcpy(error, "Not found PKVALUE");
            return -1;
        }

        if(pkid[0] == '\0'){
            /* v1/subscriber/$MSISDN.json */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,msisdn=%s,dc=MSISDN,dc=C-NTDB", pkvalue, pkvalue);
        }else{
            /* v1/subscriber/$KEY/$VALUE.json */
            char root_dn[LDAP_MAX_BASE_DN];
            if( get_baseDN(pkid, pkvalue, root_dn) != 0 ){
                sprintf(error, "Invalid KEY_NAME [%s]", pkid);
                return -1;
            }
            sprintf(base_dn, "subdata=profile,ds=gup,subdata=services,%s", root_dn);
        }

        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
//        *tid = create_request(ber,  base_dn, "", GET, Subtree, base_dn);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, "*", b_string, b_len, LDAP_DEREF_ALWAYS, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        return 0;
    }else{
        /* /v1/subscriber/$KEY/$VALUE/subdata/profile.json */

        dn[0] = '\0';
        buff[0] = '\0';

        // Create Path
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }

        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        if ( pkid[0] == '\0' && pkvalue[0] == '\0' ){
            sprintf(error, "Invalid KEY_NAME or VALUE_NAME");
            return -1;
        }

        char root_dn[LDAP_MAX_BASE_DN];
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn, "%sds=gup,subdata=services,%s", dn, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
//        *tid = create_request(ber,  base_dn, "", GET, Subtree, base_dn);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, "*", b_string, b_len, LDAP_DEREF_ALWAYS, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }

    return 0;
}

static int
af_init_action_get_subsystem_v1(DSSESSION *sess, char *subsys, char *p, char *pp, unsigned int *tid, void **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_get_subsystem_v1";
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    Control *control=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    BER *b_attrs=NULL;
    int b_len=0;
    char *b_string=NULL;
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i=0;

    dn[0] = 0;
    strcpy(object, "*");
    strcpy(attrs[0], "objectClass");
    strcpy(attrs[1], "*");
    attrs[2][0] = 0;
    GET_URI_STRING(pkid, '/', MAX_URI_PATH_SIZE);
    GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
    SDFLOG_DEBUG((B, "Primary Key [%s][%s]", pkid, pkvalue))
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(buff, pkvalue);
        GET_URI_PAGE(pkvalue, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_FILTER(object, buff);
        GET_URI_SCOPE(scope, buff);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
//        *tid = create_request(ber,  base_dn, "", GET, Subtree, base_dn);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, object, b_string, b_len, LDAP_DEREF_ALWAYS, control,error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_FIELDS(buff);
        GET_URI_FILTER(object, buff);
        GET_URI_SCOPE(scope, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
//        *tid = create_request(ber,  base_dn, "", GET, Subtree, base_dn);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, ber, base_dn, scope, object, b_string, b_len, LDAP_DEREF_ALWAYS,control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }
    return 0;
}

static int
af_init_action_put_subscriber_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_put_subscriber_v1";
    char format[16];
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char dn[LDAP_MAX_BASE_DN];
    Control *control=NULL;
    URILIST *plist=NULL, *path=NULL;
    BER *b_attrs=NULL;
    BER_MODLIST *mlist=NULL;
    pkid[0] = '\0';
    pkvalue[0] = '\0';
    if (pp==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }

    if (strchr(pp+1, '/')!=NULL)
    {

        GET_URI_STRING(pkid, '/', (int)sizeof(pkid));
        SDFLOG_DEBUG((B, "Key name[%s]" , pkid));

        if( strchr(pp+1,'/') != NULL ){
             /* v1/subscriber/$KEY/$VALUE/subdata/profile.json */
            GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,pkvalue))
        }else{
             /* v1/subscriber/$KEY/$VALUE.json */
            GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,buff))
        }
    }
    else
    {
        /* v1/subscriber/$MSISDN.json */
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "Param[%s]" ,buff))
    }

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        GET_URI_PAGE(pkvalue, sess->format, buff);

        // Not found PKVALUE
        if(pkvalue[0] == '\0'){
            return -1;
        }

        if(pkid[0] == '\0'){
            /* v1/subscriber/$MSISDN.json */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,msisdn=%s,dc=MSISDN,dc=C-NTDB", pkvalue, pkvalue);
        }else{
            /* v1/subscriber/$KEY/$VALUE.json */
            char root_dn[LDAP_MAX_BASE_DN];
            get_baseDN(pkid, pkvalue, root_dn);
            sprintf(base_dn, "subdata=profile,ds=gup,subdata=services,%s", root_dn);
        }
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))
 //       if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) return -1;
//        *tid = create_request(ber,  base_dn, "", PUT, Subtree, base_dn);
//        add_modify_entry((Request**)ber, base_dn, mlist, 1);
        //LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control,error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }else{
        /* /v1/subscriber/$KEY/$VALUE/subdata/profile.json */

        // Create Path
        dn[0] = '\0';
        buff[0] = '\0';
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }

        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        if ( pkid[0] == '\0' && pkvalue[0] == '\0' ){
            sprintf(error, "Invalid KEY_NAME or VALUE_NAME");
            return -1;
        }

        char root_dn[LDAP_MAX_BASE_DN];
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME");
            return -1;
        }

        sprintf(base_dn, "%sds=gup,subdata=services,%s", dn, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))

//        if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) return -1;

        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
        LDAP_CREATE_CONTROL();
        *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control,error);

        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

static int
af_init_action_put_subsystem_v1(DSSESSION *sess, char *subsys, char *p, char *pp, unsigned int *tid, void **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_put_subsystem_v1";
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    BER_MODLIST *mlist=NULL;
    BER *b_attrs=NULL;
    Control *control=NULL;

    dn[0] = 0;
    GET_URI_STRING(pkid, '/', MAX_URI_PATH_SIZE);
    GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
    SDFLOG_DEBUG((B, "Primary Key [%s][%s]", pkid, pkvalue))
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(buff, pkvalue);
        GET_URI_PAGE(pkvalue, sess->format, buff);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))
//        if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) return -1;
//        *tid = create_request(ber,  base_dn, "", PUT, Subtree, base_dn);
//        add_modify_entry((Request**)ber, base_dn, mlist, 1);
        //LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
        //LDAP_CREATE_CONTROL();        
        //*tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            //SDF_FREE(path);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        //SDF_FREE(path);
        return 0;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))
//        if (af_get_http_body_mod_param(sess->r_buffer->data + sess->header_length, &mlist)!=0) return -1;
        //LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
        //LDAP_CREATE_CONTROL();
        //*tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, ber, base_dn, b_attrs->berval, b_attrs->len, control, error);
//        *tid = create_request(ber,  base_dn, "", PUT, Subtree, base_dn);
//        add_modify_entry((Request**)ber, base_dn, mlist, 1);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return 0;
    }
    return 0;
}

static int
af_init_action_delete_subscriber_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_delete_subscriber_v1";
    char format[16];
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    URILIST *plist=NULL, *path=NULL;
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    BER *b_attrs = NULL;
    Control *control=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    char dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char nattr[LDAP_MAX_ATTR_NAME_SIZE];
    char vattr[LDAP_MAX_ATTR_VALUE_SIZE];
    pkid[0] = '\0';
    pkvalue[0] = '\0';
    nattr[0] = '\0';
    vattr[0] = '\0';
    buff[0] = '\0';
    if (pp==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }

    if (strchr(pp+1, '/')!=NULL)
    {

        GET_URI_STRING(pkid, '/', (int)sizeof(pkid));
        SDFLOG_DEBUG((B, "Key name[%s]" , pkid));

        if( strchr(pp,'/') != NULL ){
             /* v1/subscriber/$KEY/$VALUE/subdata/profile.json */
            GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,pkvalue))
        }else{
             /* v1/subscriber/$KEY/$VALUE.json */
            GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,buff))
        }
    }
    else
    {
        /* v1/subscriber/$MSISDN.json */
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "Param[%s]" ,buff))
    }

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        GET_URI_PAGE(pkvalue, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);

        // Not found PKVALUE
        if(pkvalue[0] == '\0'){
            strcpy(error, "Invalid path structure");
            return -1;
        }

        if(pkid[0] == '\0'){
            /* v1/subscriber/$MSISDN.json */
            sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,msisdn=%s,dc=MSISDN,dc=C-NTDB", pkvalue, pkvalue);
            strcpy( instance->default_base_dn, base_dn);
        }else{
            /* v1/subscriber/$KEY/$VALUE.json */
            char root_dn[LDAP_MAX_BASE_DN];
            get_baseDN(pkid, pkvalue, root_dn);
            sprintf(base_dn, "subdata=profile,ds=gup,subdata=services,%s", root_dn);
            strcpy( instance->default_base_dn, base_dn);
        }

        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
        LDAP_CREATE_CONTROL();
        LDAP_GEN_DELETE_REQUEST();
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            return -1;
        }
        return 0;
    }else{
        /* /v1/subscriber/$KEY/$VALUE/subdata/profile.json */

        // Create Path
        dn[0] = '\0';
        buff[0] = '\0';
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }

        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        if ( pkid[0] == '\0' && pkvalue[0] == '\0' ){
            sprintf(error, "Invalid KEY_NAME or VALUE_NAME");
            return -1;
        }

        char root_dn[LDAP_MAX_BASE_DN];
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME");
            return -1;
        }
        sprintf(base_dn, "%sds=gup,subdata=services,%s", dn, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
        LDAP_GEN_DELETE_REQUEST();
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            return -1;
        }
    }
    return 0;
}

static int
af_init_action_delete_identity_v1(DSSESSION *sess, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_delete_identity_v1";
    char format[16];
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    URILIST *plist=NULL, *path=NULL;
    Control *control=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    char dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    pkid[0] = '\0';
    pkvalue[0] = '\0';
    buff[0] = '\0';
    if (pp==NULL)
    {
        strcpy(error, "Invalid path structure");
        SDFLOG_ERROR((B, "Invalid path structure"))
        return -1;
    }

    if ( strchr(pp+1, '/') != NULL)
    {

        GET_URI_STRING(pkid, '/', (int)sizeof(pkid));
        SDFLOG_DEBUG((B, "Key name[%s]" , pkid));
        
        if( strchr(pp+1,'/') != NULL ){
             /* v1/identity/$KEY/$VALUE/subdata/profile.json */
            GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,pkvalue))
        }else{
             /* v1/identity/$KEY/$VALUE.json */
            GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
            SDFLOG_DEBUG((B, "Param[%s]" ,buff))
        }
    }
    else
    {
        /* v1/identity/$UID.json */
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "Param[%s]" ,buff))
    }

    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        /* /v1/identity/$KEY/$VALUE.json or /v1/identity/$UID.json*/ 
        GET_URI_PAGE(pkvalue, sess->format, buff);
        //GET_URI_ATTR_NAME(nattr, buff);
        //GET_URI_ATTR_VALUE(vattr, buff);

        if(pkvalue[0] == '\0'){
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "%s", error))
            return -1;
        }

        if(pkid[0] == '\0'){
            /* v1/identity/$UID.json */
            sprintf(base_dn, "uid=%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", pkvalue);
            strcpy(instance->default_base_dn, base_dn);
        }else{
            /* v1/identity/$KEY/$VALUE.json */
            char root_dn[LDAP_MAX_BASE_DN];
            if ( get_baseDN(pkid, pkvalue, root_dn) != 0 ){
                sprintf(error, "Invalid KEY_NAME");
                SDFLOG_ERROR((B, "%s", error))
                return -1;
            }
            strcpy(base_dn, root_dn);
            strcpy(instance->default_base_dn, base_dn);
        }

        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
        *tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE, ber, base_dn, NULL, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (control != NULL) SDF_FREE(control);
        return 0;
    }else{
        /* /v1/identity/$KEY/$VALUE/subdata/profile.json */

        // Create Path
        dn[0] = '\0';
        buff[0] = '\0';
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }

        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        //GET_URI_ATTR_NAME(nattr, buff);
        //GET_URI_ATTR_VALUE(vattr, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);

        if ( pkid[0] == '\0' && pkvalue[0] == '\0' ){
            sprintf(error, "Invalid KEY_NAME or VALUE_NAME");
            SDFLOG_ERROR((B, "%s", error))
            return -1;
        }

        char root_dn[LDAP_MAX_BASE_DN];
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME");
            SDFLOG_ERROR((B, "%s", error))
            return -1;
        }
        sprintf(base_dn, "%s,%s", dn, root_dn);
        strcpy( instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
         *tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE, ber, base_dn, NULL, error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

static int
af_init_action_delete_subsystem_v1(DSSESSION *sess, char *subsys, char *p, char *pp, unsigned int *tid, BER **ber, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_delete_subsystem_v1";
    char pkid[MAX_URI_PATH_SIZE], pkvalue[MAX_URI_PATH_SIZE];
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char dn[LDAP_MAX_BASE_DN];
    char base_dn[LDAP_MAX_BASE_DN];
    char root_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char nattr[LDAP_MAX_ATTR_NAME_SIZE];
    char vattr[LDAP_MAX_ATTR_VALUE_SIZE];
    BER *b_attrs=NULL;
    BER_VALLIST *vlist = NULL;
    BER_MODLIST *mlist = NULL;
    Control *control=NULL;
    nattr[0] = '\0';
    vattr[0] = '\0';
    buff[0] = '\0';
    dn[0] = 0;

    GET_URI_STRING(pkid, '/', MAX_URI_PATH_SIZE);
    GET_URI_STRING(pkvalue, '/', MAX_URI_PATH_SIZE);
    SDFLOG_DEBUG((B, "Primary Key [%s][%s]", pkid, pkvalue))
    while (pp != NULL)
    {
        path = (URILIST *) SDF_MALLOC (sizeof(*path));
        path->param[0] = 0;
        path->value[0] = 0;
        path->last_flag = 0;
        GET_URI_STRING(path->param, '/', MAX_URI_PATH_SIZE);
        GET_URI_STRING(path->value, '/', MAX_URI_PATH_SIZE);
        if ((path->param[0] == 0)&&(path->value[0] == 0))
        {
            strcpy(error, "Invalid path structure");
            SDFLOG_ERROR((B, "Invalid path structure"))
            return -1;
        }
        else if ((path->param[0] != 0)&&(path->value[0] == 0))
        {
            path->last_flag = 1;
        }
        SDFLOG_DEBUG((B, "PATH[/%s/%s/]", path->param, path->value))
        LINKEDLIST_APPEND(plist, path);
    }
    if (path!=NULL) path->last_flag = 1;

    path = plist;
    if (path==NULL)
    {
        strcpy(buff, pkvalue);
        GET_URI_PAGE(pkvalue, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
        LDAP_CREATE_CONTROL();
        LDAP_GEN_DELETE_REQUEST();
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            return -1;
        }
        return 0;
    }
    else
    {
        while ((path!=NULL)&&(path->last_flag==0))
        {
            sprintf(buff, "%s=%s,", path->param, path->value);
            strcat(buff, dn);
            strcpy(dn, buff);
            LINKEDLIST_REMOVE(plist, path);
            SDF_FREE(path);
            path = plist;
        }
        strcpy(buff, path->value);
        GET_URI_PAGE(path->value, sess->format, buff);
        GET_URI_ATTR_NAME(nattr, buff);
        GET_URI_ATTR_VALUE(vattr, buff);
        sprintf(buff, "%s=%s,", path->param, path->value);
        strcat(buff, dn);
        strcpy(dn, buff);
        LINKEDLIST_REMOVE(plist, path);
        SDF_FREE(path);
        if (strcmp(subsys, "amf")==0)
        {
            strcat(dn, "subdata=profile,");
        }

        //if ( STRCASEEQ(pkid, "UID") ){
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,ds=SUBSCRIBER,o=ais,dc=C-NTDB", dn, subsys, pkid, pkvalue);
        //}else{
        //    sprintf(base_dn, "%sds=%s,subdata=services,%s=%s,dc=%s,dc=C-NTDB", dn, subsys, pkid, pkvalue, pkid);
        //}

        root_dn[0] = '\0';
        if(get_baseDN(pkid, pkvalue, root_dn) != 0){
            sprintf(error, "Invalid KEY_NAME [%s]", pkid);
            return -1;
        }
        sprintf(base_dn,"%sds=%s,subdata=services,%s", dn, subsys, root_dn);
        strcpy(instance->default_base_dn, base_dn);
        SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
        LDAP_CREATE_CONTROL();
        LDAP_GEN_DELETE_REQUEST();
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            return -1;
        }
        return 0;
    }
    return 0;
}

#ifdef USE_RPC

int add_modify_entry(Request **req, const char *dn, BER_MODLIST *modlist, int free_flag){
    static char func[] = "add_entry";
    
    if( req == NULL ){
        SDFLOG_ERROR((B, "Cannot add entry : Request is null"))
        return -1;
    }
        
    Entry *entry = Req_entry(*req);

    
    BER_MODLIST *p_modlist = modlist;
    BER_VALLIST *p_attrv = NULL, *pp_attrv = NULL;
    
    while( p_modlist ){
        p_attrv = pp_attrv = p_modlist->vals;
        EntryAttribute *attr = Req_add_attr(entry);
        Req_set_entry_dn(entry, dn);
        Req_set_attr_name(attr, p_modlist->name);
        
        while( p_attrv ){
            Req_set_attr_value(attr, p_attrv->value);
            
            if (free_flag==1)
            {
                LINKEDLIST_REMOVE(p_modlist->vals, p_attrv);
                free(p_attrv);
                p_attrv = p_modlist->vals;
            }
            else
            {
                p_attrv = p_attrv->next;
                if( p_attrv == pp_attrv ){
                    break;
                }
            }
        }
                
        if (free_flag==1){
            LINKEDLIST_REMOVE(modlist, p_modlist);
            free(p_modlist);
            p_modlist = modlist;
        }
        else{
            p_modlist = p_modlist->next;
            if( p_modlist == modlist ){
                break;
            }
        }
    }

    return 0;
}

int create_request(Request **req,  const char *basedn, const char *filter, RESTMethod method, SearchScope scope, const char *dn){
    static char func[] = "create_request";
    int tid_id = 1;
    //TODO: Generate new transaction ID
    Request *new_request = NULL;
    if(req == NULL){
        SDFLOG_ERROR((B, "Cannot create request: Request** is null"))
        return -1;
    }
    
    new_request = new_Request();
    
    if( new_request == NULL ){
        SDFLOG_ERROR((B, "Cannot Allocate memory."))
        return -1;
    }
    
    /* create Request */
    Req_set_BaseDn(new_request, basedn);       //set basedn
    Req_set_Filter(new_request, filter);       //set filter
    Req_set_Method(new_request, method);       //set method
    Req_set_Scope(new_request, scope);         //set scope
    Req_set_Dn(new_request, dn);               //set Dn
    *req = new_request;
    return tid_id;
} 

static int
af_init_action_get_subscriber_v2(DSSESSION *sess, char *p, char *pp, unsigned int *tid, Request **req, AFINSTANCE *instance, char *error)
{
    static char func[] = "af_init_action_get_subscriber_v2";
    char buff[1024];

    sprintf(buff, "%s,ds=SUBSCRIBER,o=AIS,dc=C-NTDB", pp+1);
     
    SDFLOG_DEBUG((B, "[ p ] ---->%s", p))
    SDFLOG_DEBUG((B, "[ PP ] ---->%s", pp))
    
    *req = new_Request();
    /* create Request */
    Req_set_BaseDn(*req, buff);                     //set basedn
    Req_set_Filter(*req, "");                       //set filter
    Req_set_Method(*req, GET);                      //set method
    Req_set_Scope(*req, Subtree);                   //set scope
    Req_set_Dn(*req, "dc=C-NTDB");                  //set Dn
    /*
    Entry *entry = Req_entry(req);                  //create entry
    EntryAttribute *attr = Req_add_attr(entry);     //create entry attribute
    Req_set_entry_dn(entry, "subdata=profile,ds=ds3,subdata=services,uid=000000000000001,ds=SUBSCRIBER,o=AIS,dc=C-NTDB");
    Req_set_attr_name(attr, "language");            //set attrbute value
    Req_set_attr_values(attr, 0, "eng");            //set attribute value
    */
    
    SDFLOG_DEBUG((B, "Prepare data to send RPC"))
    
    
    
    return 0;
}

//No used
static int
af_init_action(DSSESSION *sess, LDAPMessage_t *msg, unsigned int *tid, Request **req, AFINSTANCE **instance)
{
    static char func[] = "af_init_action";
    char err[MY_ERR_BUFFER_SIZE];
    char buff[MAX_URI_PATH_SIZE];
    char *p=NULL, *pp=NULL;

    *instance = (AFINSTANCE *) SDF_MALLOC (sizeof(**instance));
    (*instance)->state = AFSTATE_IDLE;

    sprintf((*instance)->refer_id, "%d:%d", sess->no, sess->tid);

    SDFLOG_DEBUG((B, "URI: %s", sess->request_uri))
    sess->format = d02global.conf_warm.sdfdb_format;
    pp = sess->request_uri;
    GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
    SDFLOG_DEBUG((B, "version[%s]" ,buff))
    if (strcmp(buff, "v1")==0)
    {
        GET_URI_STRING(buff, '/', MAX_URI_PATH_SIZE);
        SDFLOG_DEBUG((B, "relocation[%s]" ,buff))
        strcpy((*instance)->subsys, buff);
        if (strcmp(buff, "subscriber")==0) // GUP
        {
            switch (sess->http_method)
            {
                case HTTP_METHOD_GET:
                    (*instance)->state = AFSTATE_GET_QUERY;
                    if (af_init_action_get_subscriber_v1(sess, p, pp, tid, req, *instance,  err)!=0){
                        SDFLOG_ERROR((B,"af_init_action_get_subscriber_v1 : ERROR[%s]",err))
                        write_CDR2("SDF", (*instance)->refer_id, RECORD_GET, "%s,%s,failed,%s",(*instance)->subsys,sess->request_uri ,err);
                        return -1;
                    }
                    break;
                default:
                    break;
            }
        }else if ((strcmp(buff, "pts")==0)||
                 (strcmp(buff, "amf")==0)||
                 (strcmp(buff, "sbb")==0)||
                 (strcmp(buff, "aaa")==0)||
                 (strcmp(buff, "ds3")==0)||
                 (strcmp(buff, "aemf")==0)||
                 (strcmp(buff, "stb")==0) ||
                 (strcmp(buff, "slf")==0))
        {
            switch (sess->http_method)
            {
                case HTTP_METHOD_POST:
                    (*instance)->state = AFSTATE_POST;
                    if (af_init_action_post_subsystem_v1(sess, buff, p, pp, tid, req, *instance, err)!=0){
                        write_CDR2("SDF", (*instance)->refer_id, RECORD_POST, "%s,%s,failed,%s",(*instance)->subsys,sess->request_uri ,err);
                        return -1;
                    }
                    break;

                case HTTP_METHOD_GET:
                    (*instance)->state = AFSTATE_GET_QUERY;
                    if (af_init_action_get_subsystem_v1(sess, buff, p, pp, tid, req, *instance, err)!=0){
                        write_CDR2("SDF", (*instance)->refer_id, RECORD_GET, "%s,%s,failed,%s",(*instance)->subsys,sess->request_uri ,err);
                        return -1;
                    }
                    break;
                case HTTP_METHOD_PUT:
                    (*instance)->state = AFSTATE_PUT;
                    if (af_init_action_put_subsystem_v1(sess, buff, p, pp, tid, req, *instance, err)!=0){
                        write_CDR2("SDF", (*instance)->refer_id, RECORD_PUT, "%s,%s,failed,%s",(*instance)->subsys,sess->request_uri ,err);
                        return -1;
                    }
                    break;
            }
        }
    }
    return 0;    
}
#else
static int
af_init_proxy(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE **instance){
    static char func[] = "af_init_proxy";
    char error[MY_ERR_BUFFER_SIZE];
    char base_dn[LDAP_MAX_BASE_DN];
    char base_dn_srch[LDAP_MAX_BASE_DN];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char *b_string  = NULL;
    char *p_base_dn = NULL;
    BER *b_attrs    = NULL;
    Control *control=NULL;
    error[0]        = '\0';
    base_dn[0]      = '\0';
    scope[0]        = '\0';
    strcpy(object, "(objectClass=*)");
    int b_len       = 0;
    int alias_dn_flag = 0;

    if( *instance == NULL){
        *instance = (AFINSTANCE *) SDF_MALLOC (sizeof(**instance));
        (*instance)->state              = AFSTATE_IDLE;
        (*instance)->resolve_base_dn[0] = 0;
        (*instance)->default_base_dn[0] = 0;
        (*instance)->cluster_d21[0]     = 0;
        (*instance)->dn[0]              = 0;
        (*instance)->migration_mode     = d02global.conf_warm.migration_mode;
    }
    
    //Find DN from request
    switch(lmsg->choice){
        case LDAP_PROTOCOL_SEARCH_REQUEST:
            strcpy(base_dn, lmsg->alt.search_request.comps.base_object);
            (*instance)->state = AFSTATE_GET_QUERY;
            break;
        case LDAP_PROTOCOL_ADD_REQUEST:
            strcpy(base_dn, lmsg->alt.add_request.comps.entry);
            (*instance)->state = AFSTATE_POST;
            break;
        case LDAP_PROTOCOL_MODIFY_REQUEST:
            strcpy(base_dn, lmsg->alt.modify_request.comps.object);
            (*instance)->state = AFSTATE_PUT;
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
            strcpy(base_dn, lmsg->alt.mod_dn_request.comps.entry);
            (*instance)->state = AFSTATE_MODDN;
            break;
        case LDAP_PROTOCOL_DELETE_REQUEST:
            strcpy(base_dn, lmsg->alt.delete_request.ldap_dn);
            (*instance)->state = AFSTATE_DELETE;
            break;
        case LDAP_PROTOCOL_EXTENDED_REQUEST:
            {
                Control *ctl = lmsg->controls;
                while( ctl != NULL ){
                    //Get basedn from LDAP_CONTROL_IDENTITY
                    SDFLOG_DEBUG((B, "control type  [%s]", ctl->comps.control_type))
                    SDFLOG_DEBUG((B, "control value [%s]", ctl->comps.control_value.value))
                    //SDFLOG_DEBUG((B, "Request value [%s]", lmsg->alt.extended_request.comps.request_value->berval))

                    if( STRCASEEQ(ctl->comps.control_type, LDAP_CONTROL_IDENTITY) ){
                         get_baseDN("msisdn", ctl->comps.control_value.value, base_dn);
                         break;
                     }
                     ctl = ctl->next;
                     if( ctl == lmsg->controls){
                        break;
                     }
                }
                if( base_dn[0] == '\0' ){
                    get_baseDN("uid", "663333330070000", base_dn);
                }
                (*instance)->state = AFSTATE_EXTENDED;
            }
            break;
        default :
            SDFLOG_ERROR((B, "Invalid message choice[%d]", lmsg->choice))
            return -1;
    }

    SDFLOG_DEBUG((B, "Original Dn : %s", base_dn))
    GET_IDENTITY(NULL);
    SDFLOG_DEBUG((B, "Resolve Dn  : %s", p_base_dn))
    int r;
    r = af_common_check_rdn(base_dn);
    if ((alias_dn_flag ==  1) && (lmsg->choice == LDAP_PROTOCOL_ADD_REQUEST))
    {
        // char *p;
        // p = strchr(p_base_dn, ',');
        // strcpy(base_dn_srch, p+1);
        BER_ATTRLIST *alist;
        BER_ATTRLIST *alist_tmp;
        alist_tmp = alist = lmsg->alt.add_request.comps.attributes;
        while(alist_tmp)
        {
            if(STRCASEEQ(alist_tmp->name,"aliasedObjectName"))
            {
                strcpy(base_dn_srch,alist_tmp->vals->value);
                break;
            }
            alist_tmp = alist_tmp->next;
            if(alist_tmp == alist)
            {
                break;
            }
        }
    }
    else
    {
        strcpy(base_dn_srch, p_base_dn);
    }
    SDFLOG_DEBUG((B, "Search dn[%s] on DS3", base_dn))
    LDAP_CREATE_CONTROL();
    SDFLOG_DEBUG((B, "base_dn search: %s", base_dn_srch))
    if(af_common_check_rdn(base_dn_srch) == 2)
    {
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, (BER**)req, base_dn_srch, "base", \
                                        object, b_string, b_len, LDAP_DEREF_NEVER, control, error);
    }
    else
    {
        *tid = LDAP_gen_search_request(LDAP_LIST_HANDLE, (BER**)req, base_dn_srch, "base", \
                                        object, b_string, b_len, LDAP_DEREF_ALWAYS, control, error);
    }

    if (*tid == 0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return -1;
    }

    if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    if (control != NULL) SDF_FREE(control);

    return 0;
}

static int
af_process_proxy(LDAP_CLNT *lc, DSSESSION **sess){
#define DELETE_INSTANCE                             \
{                                                   \
HASH_REMOVE(&(d02global.htable), mw)                \
LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist))    \
if (mw->instance != NULL)                           \
{                                                   \
    (void) FREE_BER_ATTRLIST(mw->instance->alist);  \
    if(mw->instance->amf != NULL){                  \
        crt_pkg_amf_free(mw->instance->amf);        \
        mw->instance->amf = NULL;                   \
    }                                               \
    if(mw->instance->result_data != NULL){          \
        SDF_FREE(mw->instance->result_data)         \
        mw->instance->result_data = NULL;           \
    }                                               \
    SDF_FREE(mw->instance)                          \
    mw->instance = NULL;                            \
}                                                   \
if(mw->lmsg != NULL){                               \
    SDF_FREE(mw->lmsg);                             \
    mw->lmsg = NULL;                                \
}                                                   \
if (mw != NULL)                                     \
{                                                   \
    SDF_FREE(mw);                                   \
    mw = NULL;                                      \
}                                                   \
--(d02global.sdfdb_count);                          \
}

    static char func[] = "af_process_proxy";
    MWRAPPER *mw=NULL;
    void *req;
    char error[MY_ERR_BUFFER_SIZE];
    char hash[MAX_HASH_KEY_SIZE];
    int hlen    = 0;
    int tid     = 0;
    int r       = 0;
    /* generate hash key, socket+id */
    hlen = sprintf(hash, "tx:%d", lc->tid);
    /* match the received message */
    HASH_LOCATE(&(d02global.htable),hash,hlen,mw)
    if (mw == NULL)
    {
        SDFLOG_WARN((B,"Message MID[%d] gone", lc->tid))
        return 1;
    }
    if (sess!=NULL) *sess = mw->ref;

    SDFLOG_DEBUG((B,"lc->result_code [%d]", lc->result_code))
    if(mw->instance->tim != NULL)
    {
        SDFLOG_DEBUG((B,"mw->instance->tim->state [%d]", mw->instance->tim->state))
    }

    switch (lc->result_code)
    {
        case LDAP_RESULT_SUCCESS:
        {
            BER *req = NULL;
            if(mw->instance->tim != NULL)
            {
                if(mw->instance->tim->state == TRANSACTION_STATE_RESOLVING)
                {
                    if (af_init_action_extended_start_transaction_v2(mw->ref, mw->lmsg, &tid, (void **)&req, mw->instance, error) != 0)
                    {
                        SDFLOG_ERROR((B, "af_init_action_extended_start_transaction_v2 return error"))
                        // HASH_REMOVE(&(d02global.trans_id_map), mw->instance->tim)
                        l_sess_send_error(mw->ref, mw->lmsg, LDAP_RESULT_UNAVAILABLE, error);
                        HASH_REMOVE(&(d02global.htable), mw);
                        LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                        SDF_FREE(mw);
                        return -1;
                    }

                    if (l_clnt_send_msg(req) != 0){
                        SDFLOG_ERROR((B, "l_clnt_send_msg return error"))
                        HASH_REMOVE(&(d02global.htable), mw);
                        LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                        SDF_FREE(mw);
                        return -1;
                    }
                    mw->instance->tim->dest = TRANSACTION_DESTINATION_DS3;
                    mw->instance->tim->state = TRANSACTION_STATE_SENDING_START_BE;
                    break;
                }
                else if(mw->instance->tim->state == TRANSACTION_STATE_SENDING_START_BE)
                {
                    af_action_process_extended_start_transaction_v2(lc, mw, error);
                    mw->instance->migration_mode = DS3_MODE;
                    mw->instance->tim->state = TRANSACTION_STATE_RESOLVED;
                }
            }
            mw->instance->migration_mode = DS3_MODE;
            if( af_init_action(mw->ref, mw->lmsg, &tid, (void**)&req, &(mw->instance)) != 0 ){
                SDFLOG_ERROR((B, "af_init_action return error"))
                HASH_REMOVE(&(d02global.htable), mw);
                LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                SDF_FREE(mw);
                return -1;
            }
            

            if (mw->instance->tim == NULL)
            {
                r = l_clnt_send_msg(req);
            }
            else
            {
                r = l_clnt_send_msg_lc(req, mw->instance->tim->lc);
            }
            if (r != 0){
                SDFLOG_ERROR((B, "l_clnt_send_msg return error"))
                HASH_REMOVE(&(d02global.htable), mw);
                LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                SDF_FREE(mw);
                return -1;
            }
            break;
        }
        case LDAP_RESULT_NO_SUCH_OBJECT:
        {
            HTTP2_BUFFER *req = NULL;
            mw->instance->migration_mode = DS4_MODE;
            if(mw->instance->tim != NULL)
            {
                mw->instance->tim->dest = TRANSACTION_DESTINATION_DS4;
                mw->instance->tim->state = TRANSACTION_STATE_RESOLVED;
            }
            if( af_init_action_v2(mw->ref, mw->lmsg, &tid, (void**)&req, &(mw->instance)) != 0 ){
                SDFLOG_ERROR((B, "af_init_action_v2 return error"))
                HASH_REMOVE(&(d02global.htable), mw);
                LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                SDF_FREE(mw);
                return -1;
            }
            if( http2_send_msg_to_queue(mw->instance, req) != 0 ){
                SDFLOG_ERROR((B, "http2_send_msg_to_queue return error"))
                HASH_REMOVE(&(d02global.htable), mw);
                LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                SDF_FREE(mw);
                return -1;
            }
            break;
        }
        default:
            SDFLOG_ERROR((B, "Return error [%d : %s]", lc->result_code, lc->diagnosticMessage))
            l_sess_send_error(mw->ref, mw->lmsg, lc->result_code, lc->diagnosticMessage);
            return -1;
            //Send ldap connection error
        break;

    }

    /* Create new edb */
    MWRAPPER *nmw = NULL;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        strcpy(error, "Cannot allocate memory");
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        return -1;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;
    nmw->lmsg = mw->lmsg;
    nmw->tid = mw->tid;
    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);

    return 3;
}

int
af_init_action(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE **instance)
{
    static char func[] = "af_init_action";
    char err[MY_ERR_BUFFER_SIZE];
    int r   = 0;
    err[0]  = '\0';
    
    if( *instance == NULL){
        *instance = (AFINSTANCE *) SDF_MALLOC (sizeof(**instance));
        (*instance)->state              = AFSTATE_IDLE;
        (*instance)->resolve_base_dn[0] = 0;
        (*instance)->default_base_dn[0] = 0;
        (*instance)->cluster_d21[0]     = 0;
        (*instance)->dn[0]              = 0;
        (*instance)->migration_mode     = DS3_MODE;
    }

    switch(lmsg->choice){
        case LDAP_PROTOCOL_SEARCH_REQUEST:
            SDFLOG_DEBUG((B, "Received SEARCH Request"))
            (*instance)->state = AFSTATE_GET_QUERY;
            strcpy((*instance)->default_base_dn, lmsg->alt.search_request.comps.base_object);
            r = af_init_action_search(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_search return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_ADD_REQUEST:
            SDFLOG_DEBUG((B, "Received ADD Request"))
            (*instance)->state = AFSTATE_POST;
            strcpy((*instance)->default_base_dn, lmsg->alt.add_request.comps.entry);
            r = af_init_action_add(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_add return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFY_REQUEST:
            SDFLOG_DEBUG((B, "Received MODIFY Request"))
            (*instance)->state = AFSTATE_PUT;
            strcpy((*instance)->default_base_dn, lmsg->alt.modify_request.comps.object);
            r = af_init_action_modify(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_modify return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
            SDFLOG_DEBUG((B, "Received MODIFY RDN Request"))
            (*instance)->state = AFSTATE_MODDN;
            strcpy((*instance)->default_base_dn, lmsg->alt.modify_request.comps.object);
            r = af_init_action_modify_dn(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_modify return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_DELETE_REQUEST:
            SDFLOG_DEBUG((B, "Received DELETE Request"))
            (*instance)->state = AFSTATE_DELETE;
            strcpy((*instance)->default_base_dn, lmsg->alt.delete_request.ldap_dn);
            r = af_init_action_delete(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_delete return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_EXTENDED_REQUEST:
            SDFLOG_DEBUG((B, "Received EXTENDED Request"))
            (*instance)->state = AFSTATE_EXTENDED;
            r = af_init_action_extended(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_extended return error"))
                return r;
            }
            break;
        default:
            SDFLOG_DEBUG((B, "Received Unknown Request"))
            break;
    }
    
    return 0;
}
#endif

int FREE_BER_VALUELIST(BER_VALLIST *bv){
    BER_VALLIST *t_val;
    t_val = bv;
    while(t_val != NULL){
        LINKEDLIST_REMOVE(bv, t_val);
        SDF_FREE(t_val);
        t_val = bv;
    }
    return 0;
}

int FREE_BER_ATTRLIST(BER_ATTRLIST *ba){
    BER_ATTRLIST *t_attr;
    BER_VALLIST *t_val;
    t_attr = ba;
    while(t_attr != NULL){
        t_val = t_attr->vals;
        while(t_val != NULL){
            LINKEDLIST_REMOVE(t_attr->vals, t_val);
            SDF_FREE(t_val);
            t_val = t_attr->vals;
        }
        LINKEDLIST_REMOVE(ba,t_attr);
        SDF_FREE(t_attr);
        t_attr = ba;
    }
    return 0;
}


int FREE_BER_MODLIST(BER_MODLIST *bm){
    BER_MODLIST *t_attr;
    BER_VALLIST *t_val;
    t_attr = bm;
    while(t_attr != NULL){
        t_val = t_attr->vals;
        while(t_val != NULL){
            LINKEDLIST_REMOVE(t_attr->vals, t_val);
            SDF_FREE(t_val);
            t_val = t_attr->vals;
        }
        LINKEDLIST_REMOVE(bm,t_attr);
        SDF_FREE(t_attr);
        t_attr = bm;
    }
    return 0;
}

static int
af_action_process(LDAP_CLNT *lc, DSSESSION **sess)
{
#define DELETE_INSTANCE                             \
{                                                   \
HASH_REMOVE(&(d02global.htable), mw)                \
LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist))    \
if (mw->instance != NULL)                           \
{                                                   \
    (void) FREE_BER_ATTRLIST(mw->instance->alist);  \
    if(mw->instance->amf != NULL){                  \
        crt_pkg_amf_free(mw->instance->amf);        \
        mw->instance->amf = NULL;                   \
    }                                               \
    if(mw->instance->result_data != NULL){          \
        SDF_FREE(mw->instance->result_data)         \
        mw->instance->result_data = NULL;           \
    }                                               \
    SDF_FREE(mw->instance)                          \
    mw->instance = NULL;                            \
}                                                   \
if(mw->lmsg != NULL){                               \
    SDF_FREE(mw->lmsg);                             \
    mw->lmsg = NULL;                                \
}                                                   \
if (mw != NULL)                                     \
{                                                   \
    SDF_FREE(mw);                                   \
    mw = NULL;                                      \
}                                                   \
--(d02global.sdfdb_count);                          \
}
    static char func[] = "af_action_process";
    MWRAPPER *mw=NULL;
    HSDATA *wbuff=NULL;
    BER *ber    = NULL;
    char err[MY_ERR_BUFFER_SIZE];
    char hash[MAX_HASH_KEY_SIZE];
    int hlen = 0, blen = 0, len = 0, i = 0, r = 0, n = 0;
    err[0] = 0;
    
    /* generate hash key, socket+id */
    hlen = sprintf(hash, "tx:%d", lc->tid);
    /* match the received message */
    HASH_LOCATE(&(d02global.htable),hash,hlen,mw)
    if (mw == NULL)
    {
        SDFLOG_WARN((B,"Message MID[%d] gone", lc->tid))
        return 1;
    }

    if( mw->ref == NULL || mw->ref->sock < 0){
        SDFLOG_WARN((B,"Socket had been closed"))
        return 1;
    }

    if (sess!=NULL) *sess = mw->ref;

    if( lc != NULL){
        SDFLOG_DEBUG((B, "ResultCode : [%d]", lc->result_code))
        SDFLOG_DEBUG((B, "MatchedDN  : [%s]", lc->matchedDN))
        SDFLOG_DEBUG((B, "Diag       : [%s]", lc->diagnosticMessage))
        SDFLOG_DEBUG((B, "tid        : [%lu]", lc->tid))
    }
     
        
    if( mw->instance->state == AFSTATE_GET_QUERY ){
        LDAP_OBJECT *obj    = NULL;
        LDAP_OBJECT *tmp    = NULL;
        BER *b_attrs        = NULL;
        BER_VALLIST *vlist  = NULL;
        BER_ATTRLIST *alist = NULL;

        LBER_object_decode(lc, &obj, err);

        tmp = obj;
        while(tmp){
            ber = NULL;
            b_attrs = NULL;
            vlist = NULL;
            alist = NULL;
            if (tmp->object_class[0] != '\0')
            {
                LBER_valuelist_add(&vlist, tmp->object_class, NULL);
                LBER_attrlist_add(&tmp->alist, "objectClass", vlist, NULL);
            }
            LDAP_gen_ber_attrlist(tmp->alist, &b_attrs, 1, err);  
            SDFLOG_DEBUG((B, "entry     [%s]", tmp->name))
            LDAP_gen_search_entry (d02global.ldapd, &ber, mw->tid,  tmp->name, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, err);
            l_sess_send_response(mw->ref, ber);
            tmp = tmp->next;
            if( tmp == obj){
                break;
            }
        }
        //ldap_object_free(obj);
        ber = NULL;
        SDFLOG_DEBUG((B, "return ldap response msgID[%d]", mw->tid))
        r = LDAP_gen_search_done(d02global.ldapd, &ber, mw->tid, lc->result_code, lc->matchedDN, NULL, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_done return error [%s]", err))
            DELETE_INSTANCE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_POST ){
        r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", err))
            DELETE_INSTANCE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_PUT ){
        r = LDAP_gen_modify_response (d02global.ldapd, &ber, mw->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_response return error [%s]", err))
            
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_MODDN ){
        r = LDAP_gen_moddn_response (d02global.ldapd, &ber, mw->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", err))
            
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }
    else if( mw->instance->state == AFSTATE_DELETE ){
        r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_response return error [%s]", err))
            DELETE_INSTANCE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_TRANSACTION){
        SDFLOG_DEBUG((B, "Removing transaction id from list [%d]", mw->instance->tim->l_sess_tid))
        HASH_REMOVE(&(d02global.trans_id_map), mw->instance->tim);
        LINKEDLIST_REMOVE(d02global.tim_dbl, &(mw->instance->tim->tim_dbl));
        SDF_FREE(mw->instance->tim);
        SDFLOG_DEBUG((B, "Send transaction extended response"))
        r = LDAP_gen_extended_common_response(d02global.ldapd, &ber,
            mw->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage,
            NULL, NULL, 0, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_extended_common_response return error [%s]", err))
            return -1;
        }

        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
        // if (l_sess_send_response(sess,(BER*)req) != 0){
        //     LINKEDLIST_REMOVE(sess->rdata, lmsg);
        //     SDF_FREE(lmsg);
        //     SDF_FREE(mw);
        //     continue;
        // }
        // continue;
    }else if( mw->instance->state == AFSTATE_EXTENDED){
        switch( mw->instance->method )
        {
            /*
            case METHOD_INQUIRY_SESSION:
                r = af_action_process_inquiry_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_PUSH_SESSION:
                r = af_action_process_push_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_PULL_SESSION:
                r = af_action_process_pull_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_MODIFY_SESSION:
                r = af_action_process_modify_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_INQUIRY_SUBSCRIBER:
                r = af_action_process_inquiry_subscriber(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_INQUIRY_PCF_VAS:
                r = af_action_process_inquiry_pcf_vas(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
                */
            case METHOD_START_TRANSACTION:
                r = af_action_process_extended_start_transaction(lc, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_END_TRANSACTION:
                r = af_action_process_extended_end_transaction(lc, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            default:
                DELETE_INSTANCE
                break;
        }
        
    }else{
        SDFLOG_ERROR((B, "Unknown instance state"))
        DELETE_INSTANCE
        return -1;
    }

    return 0;
}




static int
l_svr_open()
{
	static char func[] = "l_svr_open";
    char err[MY_ERR_BUFFER_SIZE];
	int sk;

    if (LDAP_svr_open(d02global.ldapd, &sk, err)!=LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_svr_open return error[%s]", err))
        return -1;
    }

	epoll_event_element_t* epoll_event_elem = NULL;
	if (epoll_event_add(d02global.base_epoll, sk, EPOLLIN | EPOLLOUT | EPOLLET, &epoll_event_elem) == 0)
	{
		epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void*)NULL);
		epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void*)l_sess_write_callback );
		epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void*)l_sess_read_callback );
		epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void*)l_sess_close_callback );
	}

	return 0;
}

int
l_sess_close(DSSESSION *sess)
{
	static char func[] = "l_sess_close";
    char err[MY_ERR_BUFFER_SIZE];

    if (sess==NULL) return -1;
    int sk = sess->sock;
    
	if (sk >= 0)
	{
        SDFLOG_WARN((B, "Session(%d) socket[%d] from ip[%s] port[%d] version[%d] closed", sess->no, sk, sess->remote_ip, sess->remote_port, sess->version))
        fd_clear(sk);
	}
    
    if (LDAP_sess_close(d02global.ldapd, sess->no, fd_clear, err)!=LDAP_RET_OK)
    {
        SDFLOG_FATAL((B,"Cannot close ldap connection for socket %d", sk))
		return -1;
    }

	return 0;
}

static int
l_sess_write_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	static char func[] = "l_sess_write_callback";
    char err[MY_ERR_BUFFER_SIZE];
    struct timeval stoptime, dtime;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
	//SDFLOG_DEBUG((B,"FD %d ", fd ))

	//!--Skip FD listener 
	if (fd == LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_LISTENER, NULL))
	{
        (void)fd_set_write(fd);
		return 0;
	}

	DSSESSION *sess = user_data;
	if (sess != NULL)
	{
        int ret = LDAP_sess_write(d02global.ldapd, sess, fd_set_write, err);
		if (ret < 0)
		{
            SDFLOG_ERROR((B, "LDAP_sess_write return error [%s]", err))
			l_sess_close(sess);
			return -1;
		}
        gettimeofday(&stoptime, NULL);
        if( ret == LDAP_RET_SENT)
        {
            DS_t* ds = d02global.ldapd;
            struct timeval overall_time;
            /* Find Max, Min, Avg response time for Overall */
            timeval_subtract(&overall_time, &stoptime, &(sess->timestamp_read));
            unsigned long process_time = overall_time.tv_sec*1000000+overall_time.tv_usec;
            ds->total_response_time += process_time;
            ds->max_response_time = (process_time > ds->max_response_time)?process_time:ds->max_response_time;
            ds->min_response_time = (ds->sent_msg_count > 1 )?((process_time < ds->min_response_time)?process_time:ds->min_response_time):process_time;
            ds->avg_response_time = (ds->sent_msg_count > 0)?(ds->total_response_time/ds->sent_msg_count):0;
        }

        if (SDF_log_level() & SDFLOG_LEVEL_INFO & (ret!=LDAP_RET_OK))
        {
            timeval_subtract(&dtime, &stoptime, &(sess->timestamp_write));
            long long tv_usec = (dtime.tv_sec * 1000000) + dtime.tv_usec;
            sess->total_wait_write_io += tv_usec;
            if (ret==LDAP_RET_SENT)
            {
                SDFLOG_INFO((B, "Session(%d), Write completed : wait IO %lld us : total wait IO %lld us",
                              sess->no, tv_usec, sess->total_wait_write_io))
            }
            else if (ret==LDAP_RET_SENT_FRAGMENT)
            {
                SDFLOG_DEBUG((B, "Session(%d), Write fragment %d completed %d/%lu : wait IO %lld us",
                              sess->no, sess->write_count, sess->w_curr, sess->w_len, tv_usec ))
            }
        }
	}

	return 0;
}

static int
l_sess_read_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	static char func[] = "l_sess_read_callback";
    char err[MY_ERR_BUFFER_SIZE];
    err[0] = '\0';
    DSSESSION *sess=NULL;
    int sk;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    SDFLOG_DEBUG((B,"user_data address[%p] ", user_data ))

    sk = LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_LISTENER, NULL);
	if(fd == sk)
	{
        epoll_event_element_t* epoll_event_elem = NULL;
        if (LDAP_sess_open(d02global.ldapd, d02global.authen, &sess, err)==LDAP_RET_OK)
        {
            if (epoll_event_add(d02global.base_epoll, sess->sock, EPOLLIN | EPOLLET, &epoll_event_elem) == 0)
            {
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void *)sess );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void *)l_sess_write_callback );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void *)l_sess_read_callback );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void *)l_sess_close_callback );

                if (SDF_log_level() & SDFLOG_LEVEL_INFO)
                {
                    gettimeofday(&(sess->timestamp_read),0);
                    gettimeofday(&(sess->timestamp_process), 0);
                }
            }
            sess->version = get_tid();
            SDFLOG_INFO((B, "Session(%d) sock[%d] from ip[%s] port[%d] version[%d] opened", sess->no, sess->sock, sess->remote_ip, sess->remote_port, sess->version))
        }
        else
        {
            SDFLOG_ERROR((B, "LDAP_sess_open return error[%s]", err))
            return -1;
        }

        if (epoll_event_add(d02global.base_epoll, sk, EPOLLIN | EPOLLOUT | EPOLLET, &epoll_event_elem) == 0)
        {
            epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void *)NULL );
            epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void *)l_sess_write_callback );
            epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void *)l_sess_read_callback );
            epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void *)l_sess_close_callback );
        }

        //(void)fd_set_read(fd);
		return 0;
	}

	sess = user_data;
	if (sess != NULL)
	{
        err[0] = '\0';
        int ret = LDAP_sess_read(d02global.ldapd, sess, err);
        if (ret == LDAP_RET_ERR_CLOSED)
        {
            SDFLOG_ERROR((B, "LDAP_sess_read return closed [%s]", err))
            l_sess_close(sess);
            return -1;
        }
        else if (ret == LDAP_RET_READY)
        {
            SDFLOG_INFO((B, "Directory Server accepted request for user [%s] on session [%d]", sess->user.name, sess->no))
            return 0; // immediately return for ldap bind request
        }
        else if (ret < 0)
        {
            SDFLOG_ERROR((B, "LDAP_sess_read return error [%s]", err))
			l_sess_close(sess);
			return -1;
        }

        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            if (sess->read_time == 0)
            {
                gettimeofday(&(sess->timestamp_read), 0);
                gettimeofday(&(sess->timestamp_process), 0);
                sess->recv_count = sess->total_wait_read_io = 0;

                //!--First read not calculate wait IO; may client create connection pool.
                SDFLOG_DEBUG((B, "Session(%d), Read fragment_num %lu  ", sess->no, sess->recv_count))
            }
            else
            {
                struct timeval stoptime, dtime;
                gettimeofday(&stoptime, NULL);
                timeval_subtract(&dtime, &stoptime, &(sess->timestamp_read));
                long long tv_usec = (dtime.tv_sec * 1000000) + dtime.tv_usec;
                sess->total_wait_read_io += tv_usec;
                SDFLOG_INFO((B, "Session(%d), Read fragment_num %lu : wait IO %lld us ", sess->no, sess->recv_count, tv_usec))
            }
        }

        ret = LDAP_sess_decode(d02global.ldapd, sess, err);
        if (ret == LDAP_RET_RECV_UNBIND)
        {
            l_sess_close(sess);
            return 0; // close connection for ldap unbind request
        }
        else if (ret == LDAP_RET_ERR_UNEXPECTED_RECEIVE)
        {
            ++(d02global.ldapd->busy_msg_count);
            SDFLOG_ERROR((B, "LDAP_sess_decode return error while processing request [%s]", err))
            if (sess->concurrent_count == 0) l_sess_close(sess);
            return 0;
        }
		else if (ret < 0)
		{
            SDFLOG_ERROR((B, "LDAP_sess_decode return error [%s]", err))
			l_sess_close(sess);
			return -1;
		}
		else if (ret==LDAP_RET_DATA_AVAILABLE)
		{
            gettimeofday(&(sess->timestamp_read), 0);
            gettimeofday(&(sess->timestamp_process), 0);
			if (l_sess_recv_msg(sess) != 0)
			{
				l_sess_close(sess);
				return -1;
			}
            SDFLOG_DEBUG((B, "Session(%d),Read completed : total wait IO %lld us", sess->no, sess->total_wait_read_io))
		}
        else if(ret==LDAP_RET_WAIT_MORE_DATA)
        {
            if (SDF_log_level() & SDFLOG_LEVEL_INFO)
            {
                gettimeofday(&(sess->timestamp_read),0);
                gettimeofday(&(sess->timestamp_process), 0);
            }
        }

        if (fd_set_read(sess->sock) != 0)
        {
            SDFLOG_ERROR((B,"fd_set_read error for socket (%d)", sess->sock ))
            return -1;
        }
	}

	return 0;
}

static int
l_sess_close_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	//static char func[] = "l_sess_close_callback";

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
    UNUSED(user_data);
	//SDFLOG_DEBUG((B,"FD %d ", fd ))

	//Do nothing when use edge trigger.

	return 0;
}


#ifdef GRPC

static char * scope_to_string(int scope){
    switch(scope){
        case BASE_OBJECT:
            return "base";
        case SINGLE_LEVEL:
            return "one";
        case WHOLE_SUBTREE:
            return "sub";
        default:
            return "unknown scope";
    }
}

int af_init_action_search(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_search";
    char format[16];
    URILIST *plist=NULL, *path=NULL;
    char base_dn[LDAP_MAX_BASE_DN];
    char buff[MAX_URI_PATH_SIZE];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char attrs[MAX_SEARCH_ATTRS][128];
    char *b_string  = NULL;
    BER *b_attrs    = NULL;
    int i           = 0;
    int b_len       = 0;
    char *str_res;
    int ret         = 0;
    Control *control=NULL;

    object[0] = 0;
    //strcpy(object, "(objectClass=*)");
    strcpy(attrs[0], "*");
    attrs[1][0] = 0;
    
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        SDFLOG_DEBUG((B, "default_base_dn[%s]", instance->default_base_dn))
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        SDFLOG_DEBUG((B, "dn[%s] resolve_base_dn[%s]", instance->dn, instance->resolve_base_dn))
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         SDFLOG_DEBUG((B, "resolve_base_dn[%s]", instance->resolve_base_dn))
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }
    SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
    SDFLOG_DEBUG((B, "deref_aliases[%d]", lmsg->alt.search_request.comps.deref_aliases))
    if( instance->migration_mode == DS4_MODE ){
        ret = af_common_check_rdn(base_dn);
        SDFLOG_DEBUG((B, "af_common_check_rdn[%d]", ret))
        if ((ret == 0) || (ret == 4) || (((ret == 1)||(ret == 2)||(ret == 5)) && (lmsg->alt.search_request.comps.deref_aliases == DEREF_ALWAYS)))
        {
            if((ret == 4) ||(ret == 5))
            {
                sprintf(base_dn, "%s", instance->default_base_dn);
            }
            else if(instance->dn[0] == '\0')
            {
                sprintf(base_dn, "%s", instance->resolve_base_dn);
            }
            else
            {
                sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
            }
            SDFLOG_DEBUG((B, "@D21 Search DN[%s]", base_dn))
            USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
        }
        else
        {
            SDFLOG_DEBUG((B, "@D20 Search DN[%s]", base_dn))
            USE_RPC_SERVICE(instance, "D20", GRPC_RESOLVE_ALIASE, RESTFUL_COMMAND_SEARCH);
        }

//------------------------------------------------------------------------------------
        if(lmsg->alt.search_request.comps.scope == BASE_OBJECT)
        {
            char dn[LDAP_MAX_BASE_DN];
            char newdn[LDAP_MAX_BASE_DN];

            strcpy(dn, instance->dn);
            lower_string(dn);

            alias_replace_value(dn, NULL, newdn);

            TUPLE *ptr_tuple = NULL;
            BER_ATTRLIST_OBJ *result_list;
            BER_ATTRLIST_OBJ *tmp_list;
            PAIR_VALUE_LIST *pairlist;
            PAIR_VALUE_LIST *tmp_pair;
            char s_temp[MAX_FILTER_SIZE];
            int result;
            char attrs[MAX_SEARCH_ATTRS][128];
            int i;

            if(newdn[0] == '\0')
            {
                strcat(newdn,"$root");
            }
            else
            {
                strcat(newdn,",$root");
            }
            SDFLOG_DEBUG((B, "Search variant hamp with DN[%s]", newdn));
            ret = hmap_search(d02global.global_conf.variant_db, newdn, strlen(newdn), &ptr_tuple);
            SDFLOG_DEBUG((B, "Search result[%d]", ret))
            i = 0;
            if( ret == HMAP_SUCCESS )
            {
                result_list = ptr_tuple->vals.val_custom;
                SDFLOG_DEBUG((B, "variantDN [%s]", ptr_tuple->key ))

                object[0] = 0;
                strcat(object, "(|");
                tmp_list = result_list;
                while(tmp_list)
                {
                    SDFLOG_DEBUG((B, "variantSpec [%s]", tmp_list->name ))
                    SDFLOG_DEBUG((B, "   objClass [%s]", tmp_list->vals->value ))

                    sprintf(s_temp, "(objectClass=%s)", tmp_list->vals->value);
                    strcat(object, s_temp);

                    pairlist = (PAIR_VALUE_LIST*)tmp_list->obj;
                    tmp_pair = pairlist;
                    while(tmp_pair)
                    {
                        SDFLOG_DEBUG((B, "  attr pair [%s] [%s]", tmp_pair->value_1, tmp_pair->value_2 ))
                        strcpy(attrs[i++], tmp_pair->value_1);
                        tmp_pair = tmp_pair->next;
                        if(tmp_pair == pairlist)
                        {
                            break;
                        }
                    }

                    tmp_list = tmp_list->next;
                    if(tmp_list == result_list)
                    {
                        break;
                    }
                }
                strcat(object, ")");
                strcpy(attrs[i++], "objectClass");

                GEN_GRPC_ATTRS(attrs, i);
                instance->flags.bit.variant = 1;
                instance->variant_obj = result_list;

                *tid = grpc_tid_gen();
                SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
                SDFLOG_DEBUG((B, "scope  : %s", scope_to_string(lmsg->alt.search_request.comps.scope)))
                SDFLOG_DEBUG((B, "filter : %s", object))
                ret = GRPC_gen_search_request(instance->gid, *tid, 
                                            (HTTP2_BUFFER**)req, 
                                            instance->resolve_base_dn, 
                                            "sub", 
                                            object, 
                                            d02global.global_search_attributes, 
                                            i, 
                                            SET_GET_METHOD(instance, 0x00), 
                                            LDAP_DEREF_ALWAYS, 
                                            error); 
                if (ret != GRPC_RET_OK ){
                    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                    return -1;
                }
                return 0;
            }
        }
        // else
//------------------------------------------------------------------------------------
        {
            GEN_GRPC_ATTRS_FROM_BER_VAL(lmsg->alt.search_request.comps.attributes, i);
            LDAP_filter_to_string(&lmsg->alt.search_request.comps.filter, object, af_process_adaptive_naming_inbound_with_string, d02global.global_conf.invert_adaptive_naming);
            *tid = grpc_tid_gen();
            SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
            SDFLOG_DEBUG((B, "scope  : %s", scope_to_string(lmsg->alt.search_request.comps.scope)))
            SDFLOG_DEBUG((B, "filter : %s", object))
            if( GRPC_gen_search_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, scope_to_string(lmsg->alt.search_request.comps.scope), object, d02global.global_search_attributes, i, SET_GET_METHOD(instance, 0x00), lmsg->alt.search_request.comps.deref_aliases, error) != GRPC_RET_OK ){
                SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                return -1;
            }
        }
    }else if( instance->migration_mode == DS3_MODE ){
        control = NULL;
        af_gen_control_transaction(instance->tim, lmsg, &control);
        // Make a request to LDAP server
        LDAP_filter_to_string(&lmsg->alt.search_request.comps.filter, object, NULL, NULL);
        LDAP_gen_ber_valist(lmsg->alt.search_request.comps.attributes, &b_attrs, 0, error);
        SDFLOG_DEBUG((B, "filter : %s", object))
        SDFLOG_DEBUG((B, "scope  : %s", scope_to_string(lmsg->alt.search_request.comps.scope)))
        *tid = LDAP_gen_search_request( LDAP_LIST_HANDLE, 
                                        (BER**)req,
                                        base_dn, 
                                        scope_to_string(lmsg->alt.search_request.comps.scope),
                                        object,
                                        (b_attrs!=NULL)?b_attrs->berval:NULL,
                                        (b_attrs!=NULL)?b_attrs->len:0, 
                                        lmsg->alt.search_request.comps.deref_aliases,
                                        control,
                                        error);

        SDFLOG_DEBUG((B, "tid[%u]", *tid))
        // Return error if any
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

int af_init_action_add(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_add";
    char base_dn[LDAP_MAX_BASE_DN];
    BER *b_attrs        = NULL;
    Control *control=NULL;
    
    // Form base dn
     if( instance->default_base_dn[0] != 0 ){
        SDFLOG_DEBUG((B, "default_base_dn[%s]", instance->default_base_dn))
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        SDFLOG_DEBUG((B, "dn[%s] resolve_base_dn[%s]", instance->dn, instance->resolve_base_dn))
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
        SDFLOG_DEBUG((B, "resolve_base_dn[%s]", instance->resolve_base_dn))
        strcpy(base_dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }

 //   if( instance->dn[0] != 0 ){
 //       sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
 //   }else{
 //        strcpy(base_dn, instance->resolve_base_dn);
 //   }
 //   sprintf(instance->default_base_dn, "%s", base_dn);
    SDFLOG_DEBUG((B, "add_request.comps.entry DN[%s]", lmsg->alt.add_request.comps.entry))
    SDFLOG_DEBUG((B, "base_dn DN[%s]", base_dn))
    if( instance->migration_mode == DS4_MODE ){
        if(base_dn[0] == '\0')
        {
            strcpy(base_dn, lmsg->alt.add_request.comps.entry);
        }
        SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
        switch(af_common_check_rdn(base_dn))
        {
            case 1:
            case 2:
                    USE_RPC_SERVICE(instance, "D20", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);
                    break;
            default:
                    USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);
                break;
        }
        *tid = grpc_tid_gen();
        SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
        
        BER_ATTRLIST *tattr = lmsg->alt.add_request.comps.attributes;
        af_process_adaptive_naming_inbound_with_attrlist(&lmsg->alt.add_request.comps.attributes, d02global.global_conf.attributevalue_mapping, d02global.global_conf.invert_adaptive_naming);
        while( tattr ){
            SDFLOG_DEBUG((B, "attr[%s]", tattr->name))
            if(tattr->vals != NULL)
            {
                SDFLOG_DEBUG((B, "attr value[%s]", tattr->vals->value))
            }
            tattr = tattr->next;
            
            if( tattr == lmsg->alt.add_request.comps.attributes){
                break;
            }
        }
        
        Pb__Entry *entry = NULL;
        if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)(lmsg->alt.add_request.comps.attributes), error) != GRPC_RET_OK ){
            return -1;
        }
        if( GRPC_gen_add_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, entry, 0, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_add_request return error [%s]", error))
            return -1;
        }
    }else if( instance->migration_mode == DS3_MODE ){
        SDFLOG_DEBUG((B, "Add DN[%s]", lmsg->alt.add_request.comps.entry))
        LDAP_gen_ber_attrlist(lmsg->alt.add_request.comps.attributes, &b_attrs, 1, error);
        control = NULL;
        af_gen_control_transaction(instance->tim, lmsg, &control);

        *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, 
                                    (BER**)req, 
                                    base_dn, 
                                    (b_attrs != NULL) ? b_attrs->berval : NULL, 
                                    (b_attrs != NULL) ? b_attrs->len : 0,
                                    control, 
                                    error);
        if (*tid==0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

int af_init_action_modify(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_modify";
    char base_dn[LDAP_MAX_BASE_DN];
    BER_MODLIST *mlist  = NULL;
    BER *b_attrs        = NULL;
    Control *control    = NULL;
    
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }

    SDFLOG_DEBUG((B, "Modify DN[%s]", base_dn))
    if( instance->migration_mode == DS4_MODE ){
        if(af_common_check_rdn(base_dn) == 2)
        {
            USE_RPC_SERVICE(instance, "D20", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);
        }
        else
        {
            USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);
        }
        *tid = grpc_tid_gen();
        SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))

        ChangeType *tmp_change_type = lmsg->alt.modify_request.comps.changes;
        while( tmp_change_type ){
            BER_ATTRLIST *alist = tmp_change_type->comps.modification;
            int mod_type  = 0;
            // map operation
            switch( tmp_change_type->comps.operation ){
                case ADD:   
                    mod_type = LDAP_MODIFY_ADD;
                    break;
                case DELETE:
                    mod_type = LDAP_MODIFY_DELETE;
                    break;
                case REPLACE:
                    mod_type = LDAP_MODIFY_REPLACE;
                    break;
                default:
                    break;
            }
            af_process_adaptive_naming_inbound_with_attrlist(&alist, d02global.global_conf.attributevalue_mapping, d02global.global_conf.invert_adaptive_naming);
            while( alist ){
                SDFLOG_DEBUG((B, "mod attr  : [%s] mod type :[%d]", alist->name, mod_type))
                LBER_modlist_add(&mlist, mod_type, alist->name, alist->vals, NULL);
                alist->vals = NULL; //release value list
                alist = alist->next;
                if( alist == tmp_change_type->comps.modification ){
                    break;
                }
            }

            FREE_BER_ATTRLIST(alist);
            tmp_change_type = tmp_change_type->next;
            if( tmp_change_type == lmsg->alt.modify_request.comps.changes){
                break;
            }
        }

        Pb__Entry *entry = NULL;
        if( GRPC_gen_mod_entry_ldap(&entry, base_dn, "", (MODLIST*)mlist, error) != GRPC_RET_OK ){
            return -1;
        }

        if( GRPC_gen_modify_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, entry, 0, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_modify_request return error [%s]", error))
            return -1;
        }
    }else if( instance->migration_mode == DS3_MODE ){
        ChangeType *tmp_change_type = lmsg->alt.modify_request.comps.changes;
        while( tmp_change_type ){
            BER_ATTRLIST *alist = tmp_change_type->comps.modification;
            while( alist ){
                SDFLOG_DEBUG((B, "mod attr  : [%s] mod type :[%d]", alist->name,  tmp_change_type->comps.operation))
                LBER_modlist_add(&mlist,  tmp_change_type->comps.operation, alist->name, alist->vals, NULL);
                alist->vals = NULL; //release value list
                alist = alist->next;
                if( alist == tmp_change_type->comps.modification ){
                    break;
                }
            }

            FREE_BER_ATTRLIST(alist);
            tmp_change_type = tmp_change_type->next;
            if( tmp_change_type == lmsg->alt.modify_request.comps.changes){
                break;
            }
        }
        LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
        control = NULL;
        af_gen_control_transaction(instance->tim, lmsg, &control);

        *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, (BER**)req, base_dn, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, control, error);
        if (*tid==0)
        {   
            SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (control != NULL) SDF_FREE(control);
            return -1;
        }
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
    }
    return 0;
}

int af_init_action_modify_dn(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_modify_dn";
    char base_dn[LDAP_MAX_BASE_DN];
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_MODLIST *mlist  = NULL;
    BER *b_attrs        = NULL;
    Control *control    = NULL;
    
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }

    SDFLOG_DEBUG((B, "BaseDN[%s]", base_dn))
    if( instance->migration_mode == DS4_MODE ){
        vlist = NULL;
        alist = NULL;
        LBER_valuelist_add(&vlist, lmsg->alt.mod_dn_request.comps.new_rdn, NULL);
        LBER_attrlist_add(&alist, "newrdn", vlist, NULL);
        vlist = NULL;
        // if(lmsg->alt.mod_dn_request.comps.delete_old_rdn == 0)
        // {
        //     LBER_valuelist_add(&vlist, "false", NULL);
        // }
        // else
        // {
            LBER_valuelist_add(&vlist, "true", NULL);   
        // }
        LBER_attrlist_add(&alist, "deleteoldrdn", vlist, NULL);

        if(af_common_check_rdn(base_dn) == 2)
        {
            USE_RPC_SERVICE(instance, "D20", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);
        }
        else
        {
            USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);
        }
        
        *tid = grpc_tid_gen();
        SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
        
        Pb__Entry *entry = NULL;
        if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)alist, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_entry_ldap return error [%s]", error))
            return -1;
        }
        entry->has_moddn = 1;
        entry->moddn = 1;

        if( GRPC_gen_modify_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, entry, 0, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_modify_request return error [%s]", error))
            return -1;
        }
    }else if( instance->migration_mode == DS3_MODE ){
        SDFLOG_DEBUG((B, "oldDN[%s]", lmsg->alt.mod_dn_request.comps.entry))
        SDFLOG_DEBUG((B, "newDN[%s]", lmsg->alt.mod_dn_request.comps.new_rdn))
        // SDFLOG_DEBUG((B, "deleteoldrdn[%d]", lmsg->alt.mod_dn_request.comps.delete_old_rdn))

        control = NULL;
        af_gen_control_transaction(instance->tim, lmsg, &control);

        *tid = LDAP_gen_moddn_request(LDAP_LIST_HANDLE, (BER**)req, lmsg->alt.mod_dn_request.comps.entry, \
            lmsg->alt.mod_dn_request.comps.new_rdn, 1/*(lmsg->alt.mod_dn_request.comps.delete_old_rdn > 0)?1:0*/, \
            NULL, control, error);
        if (*tid == 0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_moddn_request return error [%s]", error))
            return -1;
        }
    }
    return 0;
}

int af_init_action_delete(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_delete";
    
    char base_dn[LDAP_MAX_BASE_DN];
    char *nattr         = NULL;
    char *vattr         = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_MODLIST *mlist  = NULL;
    BER *b_attrs        = NULL;
    BER *ber            = NULL;
    Control *control    = NULL;
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }

    SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
    if( instance->migration_mode == DS4_MODE ){
        if (af_common_check_rdn(base_dn) ==  2)
        {
            USE_RPC_SERVICE(instance, "D20", GRPC_SERVICE_DO, RESTFUL_COMMAND_DELETE);
        }
        else
        {
            USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_DELETE);
        }
        *tid = grpc_tid_gen();
        SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
        if( GRPC_gen_delete_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, 3, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_delete_request return error [%s]", error))
            return -1;
        }
    }else if( instance->migration_mode == DS3_MODE ){
        control = NULL;
        af_gen_control_transaction(instance->tim, lmsg, &control);
        *tid = LDAP_gen_delete_request(LDAP_LIST_HANDLE, (BER**)req, base_dn, control, error);
        if (control != NULL) SDF_FREE(control);
        if (*tid == 0)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
            return -1;
        }
    }

   return 0;
}


int af_init_action_subrelative_add(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_subrelative_add";
    char base_dn[LDAP_MAX_BASE_DN];
    BER *b_attrs        = NULL;
    Control *control    = NULL;

    SDFLOG_DEBUG((B, "Add DN @D21[%s] ", lmsg->alt.add_request.comps.entry))
#ifdef GRPC
    USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);

    *tid = grpc_tid_gen();
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
    
    BER_ATTRLIST *tattr = lmsg->alt.add_request.comps.attributes;
    af_process_adaptive_naming_inbound_with_attrlist(&lmsg->alt.add_request.comps.attributes, d02global.global_conf.attributevalue_mapping, d02global.global_conf.invert_adaptive_naming);
    while( tattr ){
        SDFLOG_DEBUG((B, "attr[%s]", tattr->name))
        SDFLOG_DEBUG((B, "attr value[%s]", tattr->vals->value))
        tattr = tattr->next;
        
        if( tattr == lmsg->alt.add_request.comps.attributes){
            break;
        }
    }
    
    Pb__Entry *entry = NULL;
    if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)(lmsg->alt.add_request.comps.attributes), error) != GRPC_RET_OK ){
        return -1;
    }
    if( GRPC_gen_add_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, entry, 0, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_add_request return error [%s]", error))
        return -1;
    }
#else
    LDAP_gen_ber_attrlist(lmsg->alt.add_request.comps.attributes, &b_attrs, 1, error);
    control = NULL;
    af_gen_control_transaction(instance->tim, lmsg, &control);
    *tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, 
                                (BER**)req, 
                                base_dn, 
                                (b_attrs != NULL) ? b_attrs->berval : NULL, 
                                (b_attrs != NULL) ? b_attrs->len : 0,
                                LDAP_CTRL_ENABLE, 
                                error);
    if (*tid==0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        return -1;
    }
    if (b_attrs != NULL) LDAdP_ber_free(b_attrs);
#endif
    SDFLOG_DEBUG((B, "mw->intance->state        : [%d]", instance->state))
    SDFLOG_DEBUG((B, "Use MID                   : [%u]", *tid))

    return 0;
}

int af_init_action_subrelative_modify_dn(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_subrelative_modify_dn";
    char base_dn[LDAP_MAX_BASE_DN];
    BER_ATTRLIST *alist = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_MODLIST *mlist  = NULL;
    BER *b_attrs        = NULL;
    
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }

    SDFLOG_DEBUG((B, "BaseDN[%s]", base_dn))
#ifdef GRPC
    vlist = NULL;
    alist = NULL;
    LBER_valuelist_add(&vlist, lmsg->alt.mod_dn_request.comps.new_rdn, NULL);
    LBER_attrlist_add(&alist, "newrdn", vlist, NULL);
    vlist = NULL;
    if(lmsg->alt.mod_dn_request.comps.delete_old_rdn == 0)
    {
        LBER_valuelist_add(&vlist, "false", NULL);
    }
    else
    {
        LBER_valuelist_add(&vlist, "true", NULL);   
    }
    LBER_attrlist_add(&alist, "deleteoldrdn", vlist, NULL);

    USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);

    *tid = grpc_tid_gen();
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
    
    Pb__Entry *entry = NULL;
    if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)alist, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_entry_ldap return error [%s]", error))
        return -1;
    }
    entry->has_moddn = 1;
    entry->moddn = 1;

    if( GRPC_gen_modify_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, entry, 0, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_modify_request return error [%s]", error))
        return -1;
    }
#else
    // LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
    // control = NULL;
    // af_gen_control_transaction(instance->tim, lmsg, &control);
    // *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, (BER**)req, base_dn, b_attrs->berval, b_attrs->len, LDAP_CTRL_ENABLE, error);
    // if (*tid==0)
    // {
    //     SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
    //     if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    //     return -1;
    // }
    // if (b_attrs != NULL) LDAP_ber_free(b_attrs);
#endif
    SDFLOG_DEBUG((B, "mw->intance->state        : [%d]", instance->state))
    SDFLOG_DEBUG((B, "Use MID                   : [%u]", *tid))    
    return 0;
}

int af_init_action_subrelative_delete(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_subrelative_delete";
    
    char base_dn[LDAP_MAX_BASE_DN];
    char *nattr         = NULL;
    char *vattr         = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_MODLIST *mlist  = NULL;
    BER *b_attrs        = NULL;
    BER *ber            = NULL;
    Control *control    = NULL;
    
    // Form base dn
    if( instance->default_base_dn[0] != 0 ){
        strcpy(base_dn,  instance->default_base_dn);
    }else if( instance->dn[0] != 0 ){
        sprintf(base_dn, "%s,%s", instance->dn, instance->resolve_base_dn);
        sprintf(instance->default_base_dn, "%s", base_dn);
    }else{
         strcpy(base_dn, instance->resolve_base_dn);
         sprintf(instance->default_base_dn, "%s", base_dn);
    }

    SDFLOG_DEBUG((B, "Delete DN[%s]", base_dn))
#ifdef GRPC
    USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_DELETE);
    *tid = grpc_tid_gen();
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
    if( GRPC_gen_delete_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, 3, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_delete_request return error [%s]", error))
        return -1;
    }
#else
    control = NULL;
    af_gen_control_transaction(instance->tim, lmsg, &control);
    LDAP_GEN_DELETE_REQUEST();
    if (*tid==0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
        return -1;
    }
#endif
    SDFLOG_DEBUG((B, "mw->intance->state        : [%d]", instance->state))
    SDFLOG_DEBUG((B, "Use MID                   : [%u]", *tid))
    return 0;
}

#define DS2C_CONF_TIME_SIZE     10  /* 10 digits */
#define MAX_SESSION_INFO        25  /* Max session per a SYSTEM Type */
#define SYSTEM_ID_GX            0
#define SYSTEM_ID_GY            1
#define SYSTEM_ID_FBB           2
#define MAX_SIZE_SESSION_INFO   512 /* sessionInfo format: "time[10]|sessionInfo[500]" */
#define MAX_SIZE_TIME_FORMAT    11  /* time format: "time[10]|" */

void HEXDUMP(unsigned char *buff, int size){
    static char func[] = "HEXDUMP";
    static char hex[] = {'0','1','2','3','4','5','6','7',
                                '8','9','a','b','c','d','e','f'};
    int i = 0;
    int len = 0;
    char buffer[size*2];
    for( i = 0;i < size; i++){
        unsigned char ch = buff[i];
        len += sprintf(&buffer[len], "(%u)%c", ch,hex[(ch>>4)]);
        len += sprintf(&buffer[len], "%c ", hex[(ch&0x0f)]);
    }

    len += sprintf(&buffer[len], "\n");
    buffer[len] = 0;
    SDFLOG_DEBUG((B, "[%s]", buffer))
}

#define GENERIC_RESOLVE_DN(__BASE){                                                 \
    USE_RPC_SERVICE(instance, "D20", GRPC_RESOLVE_ALIASE, RESTFUL_COMMAND_SEARCH);  \
    *tid = grpc_tid_gen();                                                          \
    instance->gid = d02global.gid_prefix + (*tid);                                  \
    SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))                                     \
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))                                              \
    if( GRPC_gen_search_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn, "base", "(objectClass=*)", NULL, 0, SET_GET_METHOD(instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){\
        SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))       \
        return -1;                                                                  \
    }                                                                               \
}

#define GENERIC_PROCESS_METHOD(){                                                   \
    if (h_data != NULL && http2_send_msg_to_queue(mw->instance, h_data) != 0 )      \
    {                                                                               \
        SDFLOG_ERROR((B, "Cannot send HTTP2 request."));                            \
        return METHOD_STATE_IDLE;                                                   \
    }                                                                               \
    if(mw->instance->main_state == METHOD_STATE_IDLE){                                            \
        return METHOD_STATE_IDLE;                                                          \
    }                                                                               \
    MWRAPPER *nmw = NULL;                                                           \
    nmw = SDF_MALLOC(sizeof(*nmw));                                                 \
    if(nmw == NULL){                                                                \
        strcpy(error, "Can not allocate memory");                                   \
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));\
        return METHOD_STATE_IDLE;                                                   \
    }                                                                               \
    memset (nmw, 0, sizeof(*nmw));                                                  \
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);                       \
    nmw->dbllist.node   = nmw;                                                      \
    nmw->dbllist.time   = time (NULL);                                              \
    nmw->dbllist.retry  = 0;                                                        \
    nmw->ref            = mw->ref;                                                  \
    nmw->lmsg           = mw->lmsg;                                                 \
    nmw->tid            = mw->tid;                                                  \
    HASH_ADD(&(d02global.htable), nmw);                                             \
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));                              \
    nmw->instance       = mw->instance;                                             \
    mw->instance        = NULL;                                                     \
    HASH_REMOVE(&(d02global.htable), mw);                                           \
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));                               \
    SDF_FREE(mw);                                                                   \
}

#define DS2C_FACK_DATA(){       \
    BER_VALLIST *vlist  = NULL; \
    BER_ATTRLIST *alist = NULL; \
                                \
    vlist = NULL;               \
    LBER_valuelist_add(&vlist, "1", NULL);                         \
    LBER_attrlist_add(&alist, "methodVersion", vlist, NULL);        \
    instance->index_list[DS2C_FIELD_METHOD_VERSION] = alist->prev;  \
    instance->index_list[DS2A_FIELD_METHOD_VERSION] = alist->prev;  \
    vlist = NULL;                                                   \
    LBER_valuelist_add(&vlist, "769600000000000022", NULL);         \
    LBER_attrlist_add(&alist, "msisdnInfo", vlist, NULL);           \
    instance->index_list[DS2C_FIELD_MSISDN_INFO] = alist->prev;     \
    instance->index_list[DS2A_FIELD_MSISDN_INFO] = alist->prev;     \
    vlist = NULL;                                                   \
    LBER_valuelist_add(&vlist, "0", NULL);                         \
    LBER_attrlist_add(&alist, "sessionType", vlist, NULL);          \
    instance->index_list[DS2C_FIELD_SESSION_TYPE] = alist->prev;    \
    vlist = NULL;                                                   \
    LBER_valuelist_add(&vlist, "mobileinternet,b20.SUK2N.ais.com;1348307710;2781583214,sessionInfo", NULL);     \
    LBER_attrlist_add(&alist, "sessionInfo", vlist, NULL);                                                      \
    instance->index_list[DS2C_FIELD_SESSION_INFO] = alist->prev;                                                \
    vlist = NULL;                                                                                               \
    LBER_valuelist_add(&vlist, "mobileinternet,b20.SUK2N.ais.com;1348307710;2781583214,sessionInfo", NULL);  \
    LBER_attrlist_add(&alist, "OldSessionInfo", vlist, NULL);                                                   \
    instance->index_list[DS2C_FIELD_OLD_SESSION_INFO] = alist->prev;                                            \
    vlist = NULL;                                                                                               \
    LBER_valuelist_add(&vlist, "mobileinternet,b20.SUK2N.ais.com;1348307710;2781583214,NewSessionInfo", NULL);  \
    LBER_attrlist_add(&alist, "NewSessionInfo", vlist, NULL);                                                   \
    instance->index_list[DS2C_FIELD_NEW_SESSION_INFO] = alist->prev;                                            \
    instance->alist = alist;                                                                                    \
}
#define GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(_RESULT_CODE, _MATCH_DN, _RESULT_DES, _VAL, _VAL_LEN){                                       \
    BER *__ber = NULL;                                                                                                                          \
    int r = LDAP_gen_extended_response(d02global.ldapd, &__ber, lmsg->message_id, _RESULT_CODE, _MATCH_DN, _RESULT_DES, instance->oid, _VAL, _VAL_LEN, error);\
    if (r != LDAP_RET_OK)                                                                                                                       \
    {                                                                                                                                           \
        SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))                                                                \
        return -1;                                                                                                                              \
    }                                                                                                                                           \
    SDFLOG_DEBUG((B, "response resultcode  : [%d]", _RESULT_CODE))                                                                              \
    l_sess_send_response(sess, __ber);                                                                                                          \
}

#define GENERIC_LDAP_EXTENDED_RESPONE() GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_SUCCESS, NULL, NULL, NULL, 0)

#define GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(_RESULT_CODE, _MATCH_DN, _RESULT_DES, _VAL, _VAL_LEN){                                \
    BER *__ber = NULL;                                                                                                              \
    r = LDAP_gen_extended_response(d02global.ldapd, &__ber, mw->tid, _RESULT_CODE, _MATCH_DN, _RESULT_DES, mw->instance->oid, _VAL, _VAL_LEN, error);  \
    if (r != LDAP_RET_OK)                                                                                                           \
    {                                                                                                                               \
        SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))\
        return -1;                                                              \
    }                                                                           \
    SDFLOG_DEBUG((B, "response resultcode  : [%d]", _RESULT_CODE))              \
    l_sess_send_response(mw->ref, __ber);                                       \
}

#define GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(_RESULT_CODE, _MATCH_DN, _RESULT_DES, _VAL, _VAL_LEN){                                \
    BER *__ber = NULL;                                                                                                              \
    r = LDAP_gen_extended_common_response(d02global.ldapd, &__ber, mw->tid, _RESULT_CODE, _MATCH_DN, _RESULT_DES, mw->instance->oid, _VAL, _VAL_LEN, error);  \
    if (r != LDAP_RET_OK)                                                                                                           \
    {                                                                                                                               \
        SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))\
        return -1;                                                              \
    }                                                                           \
    SDFLOG_DEBUG((B, "response resultcode  : [%d]", _RESULT_CODE))              \
    l_sess_send_response(mw->ref, __ber);                                       \
}

#define GENERIC_LDAP_SEARCH_DEFAULT_RESPONE(_RESULT_CODE, _MATCH_DN, _RESULT_DES){                          \
    BER *__ber = NULL;                                                                                      \
    r = LDAP_gen_search_done(d02global.ldapd, &__ber, mw->tid, _RESULT_CODE, _MATCH_DN, _RESULT_DES, error);\
    if (r != LDAP_RET_OK)                                                                                   \
    {                                                                                                       \
        SDFLOG_ERROR((B, "LDAP_gen_search_done return error [%s]", error))                                  \
        return -1;                                                                                          \
    }                                                                                                       \
    l_sess_send_response(mw->ref, __ber);                                                                   \
}

#define INQUIRY_SUBSCIRBER_CMP_ATTR(_FND_STR) STRCASEEQ(res->entries[i_entry]->attributes[i_alist]->name, _FND_STR) 
#define INQUIRY_SUBSCRIBER_CREATE_ATTR(){                                                       \
    SDFLOG_DEBUG((B, "store :[%s]", res->entries[i_entry]->attributes[i_alist]->values[0]))     \
    vlist = NULL;                                                                               \
    LBER_valuelist_add(&vlist, res->entries[i_entry]->attributes[i_alist]->values[0], NULL);    \
    LBER_attrlist_add(&alist, res->entries[i_entry]->attributes[i_alist]->name, vlist, NULL);   \
}
#define INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR(_ATTR){                                          \
    SDFLOG_DEBUG((B, "store :[%s:default]", _ATTR))                                             \
    vlist = NULL;                                                                               \
    LBER_valuelist_add(&vlist, "default", NULL);                                                \
    LBER_attrlist_add(&alist, _ATTR, vlist, NULL);                                              \
}

#define DS2A_GET_RESUTLINFO(_instance, _buffer, _n_attrs, ...) compose_attribute_to_string(_instance, _buffer, _n_attrs, __VA_ARGS__)
#define DS2A_GET_ACCOUNTINGINFO(_instance, _buffer, _n_attrs, ...) compose_attribute_to_string(_instance, _buffer, _n_attrs, __VA_ARGS__)

int compose_attribute_to_string(AFINSTANCE *instance, char *buffer, int n_attributes, ...){
    static char func[]  = "compose_attribute_to_string";
    va_list valist;
    TUPLE *ptr_tuple    = NULL;
    int at      = 0;
    int len     = 0;    
    int j       = 0;
    int r       = 0;
    int key_len = 0;

    char key[128];
    va_start(valist, n_attributes);
    for(j = 0; j < n_attributes; j++){
        at = va_arg(valist, int);
        if( instance->index_res_alist[at] != NULL ){
            key_len = sprintf(key, "%s:%s", instance->index_res_alist[at]->name, instance->index_res_alist[at]->vals->value);
            SDFLOG_DEBUG((B, "Search attribute  : [%s]", key))
            r = hmap_search(d02global.app_conf.ds2a.map, key, key_len, &ptr_tuple);
            //if( r == HMAP_TUPLE_NOT_FOUND){
                // Search agains by default value
                //key_len = sprintf(key, "%s:%s", instance->index_res_alist[at]->name, "default");
                //SDFLOG_DEBUG((B, "Search attribute  : [%s]", key))
                //r = hmap_search(d02global.app_conf.ds2a.map, key, key_len, &ptr_tuple);
            //}
            if( r == HMAP_SUCCESS) {
                SDFLOG_DEBUG((B, "Found mapped data!"))
                switch( ptr_tuple->data_type ){
                    case HMAP_DATA_TYPE_INT:
                        SDFLOG_DEBUG((B, "map to -->   : %d", ptr_tuple->vals.val_int))
                        len += sprintf(&buffer[len], "%d", ptr_tuple->vals.val_int);
                     break;
                    case HMAP_DATA_TYPE_CHARS:
                        SDFLOG_DEBUG((B, "map to -->   : %s", ptr_tuple->vals.val_chars))
                        len += sprintf(&buffer[len], "%s", ptr_tuple->vals.val_chars);
                     break;
                    default:
                        SDFLOG_DEBUG((B, "map to -->   : %s", instance->index_res_alist[at]->vals->value))
                        len += sprintf(&buffer[len], "%s", instance->index_res_alist[at]->vals->value);
                     break;
                }
            }else{
                r = hmap_search(d02global.global_conf.attributevalue_mapping, 
                                instance->index_res_alist[at]->name, 
                                strlen(instance->index_res_alist[at]->name),
                                &ptr_tuple);
                if( r == HMAP_SUCCESS)
                {
                    SDFLOG_DEBUG((B, "Found formatted data!"))
                    if (HMAP_IS_HEX_DISPLAY(ptr_tuple->data_type))
                    {
                        unsigned long int hints;
                        int tmp_len;
                        char bstr[11];
                        char *tmp_buffer;

                        SDFLOG_DEBUG((B, "attribute name : [%s]", instance->index_res_alist[at]->name))
                        SDFLOG_DEBUG((B, "original value : [%s]", instance->index_res_alist[at]->vals->value))
                        tmp_len = strlen(instance->index_res_alist[at]->vals->value);
                        if(tmp_len > 0)
                        {
                            if(tmp_len>10)
                            {
                                strncpy(bstr, instance->index_res_alist[at]->vals->value+tmp_len-10, 10);
                                bstr[10] = '\0';
                            }
                            else
                            {
                                strncpy(bstr, instance->index_res_alist[at]->vals->value, tmp_len);
                                bstr[tmp_len] = '\0';
                            }
                            SDFLOG_DEBUG((B, "bstr : [%s]", bstr))
                            hints = strtol(bstr, &tmp_buffer, 2);
                            SDFLOG_DEBUG((B, "Formatted to : [%.3xh]", hints))
                            len += sprintf(&buffer[len], "%.3x", hints);
                        }
                    }
                    else
                    {
                        len += sprintf(&buffer[len], "%s", (instance->index_res_alist[at] != NULL)? instance->index_res_alist[at]->vals->value:"");
                    }
                }
                else
                {
                    len += sprintf(&buffer[len], "%s", (instance->index_res_alist[at] != NULL)? instance->index_res_alist[at]->vals->value:"");
                }
            }
        }
        if(j < (n_attributes-1))
        {
            len += sprintf(&buffer[len], ",");
        }
    }
    va_end(valist);
    return 0;
}

#define DS2C_GEN_RESULT_RESPONSE(){                                                                     \
    vlist = NULL;                                                                                       \
    LBER_valuelist_add(&vlist, "1", NULL);                                                              \
    LBER_attrlist_add(&alist, "methodVersion", vlist, NULL);                                            \
    vlist = NULL;                                                                                       \
    LBER_valuelist_add(&vlist, mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, NULL);    \
    LBER_attrlist_add(&alist, "msisdnInfo", vlist, NULL);                                               \
    b_attrs = NULL;                                                                                     \
    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);                                                   \
    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(res->resultcode, res->matcheddn, res->resultdescription, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0);  \
}

typedef int (*FUNC_PTR)( char * );

int ds2c_verify_session_info(char *value){
    static char func[] = "ds2c_verify_session_info";
    int v_len   = 0;
    char split  = '\0';
    v_len = strlen(value);
    if( v_len <= MAX_SIZE_TIME_FORMAT) {
        return -1; //too small
    }else if( v_len > MAX_SIZE_SESSION_INFO){
        return -2; //More than MAX_SIZE_SESSION_INFO
    }

    //Verify time
    if( value[MAX_SIZE_TIME_FORMAT-1] != '|' ){
        return -4;
    }
    split                           = value[MAX_SIZE_TIME_FORMAT];
    value[MAX_SIZE_TIME_FORMAT]     = '\0';
    long curr_time = atol(value);
    SDFLOG_DEBUG((B, "curr_time 	: %ld", curr_time))
    if( MIN_TIME_STAMP >= curr_time || curr_time >=  MAX_TIME_STAMP){
        return -3;
    }

    value[MAX_SIZE_TIME_FORMAT]   = split;

    return 0; //Correct
}


int entry_get_vallist_by_attribute(Pb__Response *res, char *find, BER_VALLIST **vallist, int voffset, ...){
    static char func[] = "entry_get_vallist_by_attribute";
    int i = 0,
        r = 0,
        v = 0;
    Pb__Entry *entry    = NULL;
    int *f();
    int result = 0;
    va_list ap;
    va_start(ap, voffset);
    FUNC_PTR func_pointer = va_arg(ap, FUNC_PTR);
    SDFLOG_DEBUG((B, "offset: [%d]", voffset))
    if( res->n_entries == 0 ) return -2; // No entry
    for( i = 0; i < res->n_entries; i++ ){
        entry = res->entries[i];
        SDFLOG_DEBUG((B, "entry : [%s]", entry->dn))
        for( r = 0; r < entry->n_attributes ; r++ ){
            SDFLOG_DEBUG((B, "attr  : [%s]", entry->attributes[r]->name))
            if( strcasecmp(find, entry->attributes[r]->name) == 0 ){
                for( v = 0; v < entry->attributes[r]->n_values; v++ ){
                    SDFLOG_DEBUG((B, "value : [%s]", entry->attributes[r]->values[v]))
                    LBER_valuelist_add(vallist, entry->attributes[r]->values[v]+voffset, NULL);
                    if(func_pointer != NULL) {
                        if(func_pointer(entry->attributes[r]->values[v]) != 0 ){
                            SDFLOG_ERROR((B, "Invalid value format"))
                            //return -3; //Invalid format
                            result = -3;
                        }
                    }
                }
                if (result != 0)
                {
                    return result;
                }
                else
                {
                    return entry->attributes[r]->n_values;
                }
            }
        }
    }
    return -1; //No attribute 
}

void entry_print_all(Pb__Response *res){
    static char func[] = "entry_print_all";
    int i = 0,
        r = 0,
        v = 0;
    Pb__Entry *entry = NULL;
    for( i = 0; i < res->n_entries; i++ ){
        entry = res->entries[i];
        SDFLOG_DEBUG((B, "entry : [%s]", entry->dn))
        for( r = 0; r < entry->n_attributes ; r++ ){
            SDFLOG_DEBUG((B, "attr  : [%s]", entry->attributes[r]->name))
            for( v = 0; v < entry->attributes[r]->n_values; v++){
                SDFLOG_DEBUG((B, "value : [%s]", entry->attributes[r]->values[v]))
            }
        }
    }
}

char * ds2c_map_system_type( char *system_type_str ){
    if(STRCASEEQ( system_type_str, "0")) {
        return "Gx";
    }else if(STRCASEEQ( system_type_str, "1")){
        return "Gy";
    }else if(STRCASEEQ( system_type_str, "2")){
        return "FBB";
    }
    return "Unknown";
}


int ds2a_setup_default(){
    static char func[] = "ds2a_setup_default";
#define DS2A_STORE_INT(__NAME__, __VALUE__){                                                            \
    if( hmap_add(&my_hmap_db, (__NAME__), strlen((__NAME__)), 1, HMAP_DATA_TYPE_INT, __VALUE__, 0) < 0 ){\
        SDFLOG_ERROR((B, "Cannot store  : [%s]", __NAME__))                                             \
        return -1;                                                                                      \
    }                                                                                                   \
}

    /* initialize database */
    HMAP_DB *my_hmap_db = NULL;  
    hmap_init(1024, &my_hmap_db);
    DS2A_STORE_INT("subscriptionState:default", 0);
    DS2A_STORE_INT("subscriptionState:idle", 0);
    DS2A_STORE_INT("subscriptionState:active",1);
    DS2A_STORE_INT("subscriptionState:suspendFraud",2);
    DS2A_STORE_INT("subscriptionState:suspendDebt",3);
    DS2A_STORE_INT("subscriptionState:barredLeasing",4);
    DS2A_STORE_INT("subscriptionState:creditLimitted",5);
    DS2A_STORE_INT("subscriptionState:barredRequest",6);
    DS2A_STORE_INT("subscriptionState:terminated",7);
    DS2A_STORE_INT("subscriptionState:barredDisconnect",8);
    DS2A_STORE_INT("subscriptionState:barredPending",9);
    DS2A_STORE_INT("subscriptionState:prep",10);
    DS2A_STORE_INT("subscriptionState:test",11);
    DS2A_STORE_INT("subscriptionState:freeze",12);
    DS2A_STORE_INT("subscriptionState:barredDebtOut",14);
    DS2A_STORE_INT("subscriptionState:suspendDebt1way",13);
    DS2A_STORE_INT("subscriptionState:creditLimitted1way",15);
    DS2A_STORE_INT("subscriptionState:barredDisconnectOver30",18);
    DS2A_STORE_INT("subscriptionState:barredCredit",16);
    DS2A_STORE_INT("subscriptionState:barredCreditOut",17);
    DS2A_STORE_INT("subscriptionState:terminatedOver30",19);
    DS2A_STORE_INT("subscriptionState:prepaidSuspend",20);
    DS2A_STORE_INT("subscriptionState:prepaidDisable",21);
    DS2A_STORE_INT("subscriptionState:pool",22);
    DS2A_STORE_INT("subscriptionState:registered", 23);
    DS2A_STORE_INT("subscriptionState:unregistered", 24);

    DS2A_STORE_INT("language:default", 2);
    DS2A_STORE_INT("language:tha", 1);
    DS2A_STORE_INT("language:eng", 2);
    DS2A_STORE_INT("language:mya", 3);
    DS2A_STORE_INT("language:chn", 4);
    DS2A_STORE_INT("language:khm", 5);
    DS2A_STORE_INT("language:lao", 6);
    DS2A_STORE_INT("language:jpa", 7);
    DS2A_STORE_INT("language:kor", 8);

    DS2A_STORE_INT("emailLanguage:tha", 1);
    DS2A_STORE_INT("emailLanguage:eng", 2);
    DS2A_STORE_INT("emailLanguage:mya", 3);
    DS2A_STORE_INT("emailLanguage:chn", 4);
    DS2A_STORE_INT("emailLanguage:khm", 5);
    DS2A_STORE_INT("emailLanguage:lao", 6);
    DS2A_STORE_INT("emailLanguage:jpa", 7);
    DS2A_STORE_INT("emailLanguage:kor", 8);

    DS2A_STORE_INT("ds3hackTime:default", 0);

    DS2A_STORE_INT("ivrLanguage:tha", 1);
    DS2A_STORE_INT("ivrLanguage:eng", 2);
    DS2A_STORE_INT("ivrLanguage:mya", 3);
    DS2A_STORE_INT("ivrLanguage:chn", 4);
    DS2A_STORE_INT("ivrLanguage:khm", 5);
    DS2A_STORE_INT("ivrLanguage:lao", 6);
    DS2A_STORE_INT("ivrLanguage:jpa", 7);
    DS2A_STORE_INT("ivrLanguage:kor", 8);
    
    DS2A_STORE_INT("ussdLanguage:tha", 1);
    DS2A_STORE_INT("ussdLanguage:eng", 2);
    DS2A_STORE_INT("ussdLanguage:mya", 3);
    DS2A_STORE_INT("ussdLanguage:chn", 4);
    DS2A_STORE_INT("ussdLanguage:khm", 5);
    DS2A_STORE_INT("ussdLanguage:lao", 6);
    DS2A_STORE_INT("ussdLanguage:jpa", 7);
    DS2A_STORE_INT("ussdLanguage:kor", 8);

    DS2A_STORE_INT("smsLanguage:tha", 1);
    DS2A_STORE_INT("smsLanguage:eng", 2);
    DS2A_STORE_INT("smsLanguage:mya", 3);
    DS2A_STORE_INT("smsLanguage:chn", 4);
    DS2A_STORE_INT("smsLanguage:khm", 5);
    DS2A_STORE_INT("smsLanguage:lao", 6);
    DS2A_STORE_INT("smsLanguage:jpa", 7);
    DS2A_STORE_INT("smsLanguage:kor", 8);

    DS2A_STORE_INT("meteringmethod:default", 1);
    DS2A_STORE_INT("meteringMethod:duration", 1);
    DS2A_STORE_INT("meteringMethod:volume", 0);
    DS2A_STORE_INT("meteringMethod:duration_volume", 2);
    DS2A_STORE_INT("meteringMethod:attempt", 3);

    DS2A_STORE_INT("ds3brandId:gsm", 0);
    DS2A_STORE_INT("ds3brandId:one2call", 1);
    DS2A_STORE_INT("ds3brandId:sawassdee", 2);
    DS2A_STORE_INT("ds3brandId:gsm1800", 3);
    DS2A_STORE_INT("ds3brandId:3g-postpaid", 4);
    DS2A_STORE_INT("ds3brandId:3g-prepaid", 5);
    DS2A_STORE_INT("ds3brandId:uknown", 99);

    DS2A_STORE_INT("ds3customerCategory:residential", 0);
    DS2A_STORE_INT("ds3customerCategory:business", 1);
    DS2A_STORE_INT("ds3customerCategory:exclusive", 2);
    DS2A_STORE_INT("ds3customerCategory:governmentAndNonProfit", 3);
    DS2A_STORE_INT("ds3customerCategory:inHouse", 4);

    DS2A_STORE_INT("ds3customerSubCategory:keyAccount", 0);
    DS2A_STORE_INT("ds3customerSubCategory:sme",1);
    DS2A_STORE_INT("ds3customerSubCategory:royal",2);
    DS2A_STORE_INT("ds3customerSubCategory:tot",3);
    DS2A_STORE_INT("ds3customerSubCategory:government",4);
    DS2A_STORE_INT("ds3customerSubCategory:stateEnterprise",5);
    DS2A_STORE_INT("ds3customerSubCategory:embassy",6);
    DS2A_STORE_INT("ds3customerSubCategory:nonProfit",7);
    DS2A_STORE_INT("ds3customerSubCategory:ais",8);
    DS2A_STORE_INT("ds3customerSubCategory:prepaid",9);
    DS2A_STORE_INT("ds3customerSubCategory:foreigner",10);
    DS2A_STORE_INT("ds3customerSubCategory:thaiCitizen",11);


    DS2A_STORE_INT("gupDataServLifestyle:speedy",1);
    DS2A_STORE_INT("gupDataServLifestyle:business",2);
    DS2A_STORE_INT("gupDataServLifestyle:decent",3);
    DS2A_STORE_INT("gupDataServLifestyle:pennyPicker",4);


    DS2A_STORE_INT("ds3customerSegment:standard", 99);
    DS2A_STORE_INT("ds3customerSegment:classic",1);
    DS2A_STORE_INT("ds3customerSegment:gold",2);
    DS2A_STORE_INT("ds3customerSegment:platinum",3);
    DS2A_STORE_INT("ds3customerSegment:platinumPlus",4);
    DS2A_STORE_INT("ds3customerSegment:serenadeCeo",5);
    DS2A_STORE_INT("ds3customerSegment:serenadePrestige",6);
    DS2A_STORE_INT("ds3customerSegment:emerald",7);

    d02global.global_configuration = my_hmap_db;
    return 0;
}

int af_action_process_generic_resolve_dn(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_generic_resolve_dn";
    
    SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
    SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
    SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))
    
    switch ( res->resultcode ){
        case LDAP_RESULT_SUCCESS:
        case LDAP_RESULT_ALIAS_PROBLEM:
            SDFLOG_DEBUG((B, "DN         : [%s]", mw->instance->default_base_dn))
            strcpy(mw->instance->resolve_base_dn, mw->instance->default_base_dn);
            SDFLOG_DEBUG((B, "Resolve DN : [%s]", mw->instance->resolve_base_dn))
            break;
        case LDAP_RESULT_REFERRAL:
            if( res->n_referrals > 0)
            {
                SDFLOG_DEBUG((B, "Referrals  : [%s]", res->referrals[0]))
                strcpy(mw->instance->cluster_d21, res->referrals[0]);
                strcpy(mw->instance->resolve_base_dn, res->matcheddn);
            }else{
                SDFLOG_ERROR((B, "Cannot get Referrals [return LDAP_RESULT_NO_SUCH_OBJECT]"))
                res->resultcode = LDAP_RESULT_NO_SUCH_OBJECT;
                return -2;
            }
            SDFLOG_DEBUG((B, "Resolve DN : [%s]", mw->instance->resolve_base_dn))
            break;
        case LDAP_RESULT_NO_SUCH_OBJECT:
        default:
            SDFLOG_ERROR((B, "Cannot resolve identity"));
            return -1;
            break;
    }
    return 0;
}

//Start transaction ID
int af_init_action_extended_start_transaction(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[]  = "af_init_action_extended_start_transaction";
    int r               = 0;
    char base_dn[LDAP_MAX_BASE_DN];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char *b_string      = NULL;
    BER *b_attrs        = NULL;
    Control *control    = NULL;
    error[0]            = '\0';
    strcpy(object, "(objectClass=*)");
    //strcpy(scope, "base");
    //get_baseDN("msisdn", "000000000000001", base_dn);
    //SDFLOG_DEBUG((B, "interim Search dn[%s] on DS3", base_dn))


    control = (Control *) SDF_MALLOC(sizeof(Control));                             
    if(control != NULL)                                                                     
    {                   
        control->next = control->prev = control;                                                                    
        sprintf(control->comps.control_type, "%s", LDAP_CONTROL_USE_ALIAS_ON_UPDATE);       
        control->comps.control_value.len = sprintf(control->comps.control_value.value, "%s", "663333330070000");                                          
        //control->comps.control_value.len = 0;
        control->comps.criticality = -1;                                               
    }    
     SDFLOG_DEBUG((B, "Start transaction with identity[%s]", control->comps.control_value.value))
    *tid = LDAP_gen_extended_request(LDAP_EXT_HANDLE,
                              (BER**)req,
                              LDAP_EXTENDED_START_TRANSACTION,
                              NULL,
                              0,
                              lmsg->controls,
                              error
                              );
    if (*tid == 0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_extended_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return -1;
    }
    SDFLOG_DEBUG((B, "tid   [%d]", *tid))
    if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    if (control != NULL) SDF_FREE(control);
    
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_START_TRANSACTION;
    return 0;
}

int af_init_action_extended_start_transaction_v2(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[]  = "af_init_action_extended_start_transaction_v2";
    int r               = 0;
    char base_dn[LDAP_MAX_BASE_DN];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char *b_string      = NULL;
    BER *b_attrs        = NULL;
    Control *control    = NULL;
    error[0]            = '\0';
    strcpy(object, "(objectClass=*)");
   
    SDFLOG_DEBUG((B, "Sending start transaction to backend"))
    *tid = LDAP_gen_extended_common_request(LDAP_EXT_HANDLE,
                              (BER**)req,
                              LDAP_EXTENDED_START_TRANSACTION,
                              NULL,
                              0,
                              NULL, //lmsg->controls,
                              error
                              );
    if (*tid == 0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_extended_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (control != NULL) SDF_FREE(control);
        return -1;
    }
    SDFLOG_DEBUG((B, "tid   [%d]", *tid))
    if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    if (control != NULL) SDF_FREE(control);
    return 0;
}

int af_action_process_extended_start_transaction(void *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_extended_start_transaction";
    int r = 0;
    BER *ber            = NULL;
    BER *b_attrs        = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_ATTRLIST *alist = NULL;
    LDAP_OBJECT *obj    = NULL;

    if( mw->instance->migration_mode == DS4_MODE){
        SDFLOG_ERROR((B, "Unsupported this ldap extended"))
        GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
        return 0;
    }else if( mw->instance->migration_mode == DS3_MODE){
        LDAP_CLNT *lc = (LDAP_CLNT *)res;
        if( LBER_object_decode(lc, &obj, error) != 0 ){
            SDFLOG_ERROR((B, "LBER_object_decode return error[%s]", error))
            GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
            return 0;
        }

        if(obj->ber == NULL){
            SDFLOG_ERROR((B, "No any ldap extended response"))
            GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
            return 0;
        }

        SDFLOG_DEBUG((B, "ldap extended : [%s]", obj->name))
        SDFLOG_DEBUG((B, "berlen        : [%d]", obj->ber->len))

        r = LDAP_gen_extended_common_response(d02global.ldapd, &ber, mw->tid, LDAP_RESULT_SUCCESS, NULL, NULL, \
            mw->instance->oid, (obj->ber!=NULL)?obj->ber->berval:NULL, (obj->ber!=NULL)?obj->ber->len:0, error);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            if (obj != NULL) LDAP_object_free(obj);
            return -1;
        }
        l_sess_send_response(mw->ref, ber); 
        mw->instance->main_state = METHOD_STATE_IDLE;
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        if (obj != NULL) LDAP_object_free(obj);
    }

    return 0;
}

int af_action_process_extended_start_transaction_v2(void *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_extended_start_transaction_v2";
    int r = 0;
    BER *ber            = NULL;
    BER *b_attrs        = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_ATTRLIST *alist = NULL;
    LDAP_OBJECT *obj    = NULL;
    TRANS_PRIVATE *trans_private;

    if( mw->instance->migration_mode == DS4_MODE){
        SDFLOG_ERROR((B, "Unsupported this ldap extended"))
        GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
        return 0;
    }else if( mw->instance->migration_mode == MIG_MODE){
        LDAP_CLNT *lc = (LDAP_CLNT *)res;

        if( LBER_object_decode(lc, &obj, error) != 0 ){
            SDFLOG_ERROR((B, "LBER_object_decode return error[%s]", error))
            // GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
            return 0;
        }

        if(obj->ber == NULL){
            SDFLOG_ERROR((B, "No any ldap extended response"))
            // GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE_WITH_EXEARG(LDAP_RESULT_OPERATION_ERROR, NULL, NULL, NULL, 0);
            return 0;
        }

        ldap_print_object(obj);

        SDFLOG_DEBUG((B, "ldap extended : [%s]", obj->name))

        trans_private = NULL;
        r = LDAP_decode_private_id_response(obj->ber->berval, &trans_private);
        SDFLOG_DEBUG((B, "private id        [%X] ",trans_private->private_id))
        SDFLOG_DEBUG((B, "transaction id    [%d] ",trans_private->e3.trans_id))

        mw->instance->tim->DSx_tid = trans_private->e3.trans_id;

        SDFLOG_DEBUG((B, "Keep lc in transaction id mapping"))
        mw->instance->tim->lc = lc;

        if (obj != NULL) LDAP_object_free(obj);
        if (trans_private != NULL) free(trans_private);
    }

    return 0;
}

//End transaction ID
int af_init_action_extended_end_transaction(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_extended_end_transaction";
    char base_dn[LDAP_MAX_BASE_DN];
    char scope[MAX_SCOPE_SIZE], object[MAX_FILTER_SIZE];
    char *b_string      = NULL;
    BER *b_attrs        = NULL;
    error[0]            = '\0';
    strcpy(object, "(objectClass=*)");
 
    //SDFLOG_DEBUG((B, "End transaction with identity[%s]", control->comps.control_value.value))
    *tid = LDAP_gen_extended_common_request(LDAP_EXT_HANDLE,
                              (BER**)req,
                              LDAP_EXTENDED_END_TRANSACTION,
                              lmsg->alt.extended_request.comps.request_value->berval,
                              lmsg->alt.extended_request.comps.request_value->len,
                              lmsg->controls,
                              error
                              );
    if (*tid == 0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_extended_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        return -1;
    }
    SDFLOG_DEBUG((B, "tid   [%d]", *tid))
    if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_END_TRANSACTION;

    return 0;
}

int af_init_action_extended_end_transaction_v2(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE **instance, TRANS_PRIVATE *trans_private, char *error){
    static char func[] = "af_init_action_extended_end_transaction";
    Control *control    = NULL;
    char *b_string      = NULL;
    BER *b_attrs        = NULL;
    BER *ber            = NULL;
    error[0]            = '\0';
    BER_ATTRLIST *alist=NULL;
    BER_VALLIST *vlist=NULL;
    char c_temp[32];

    if( *instance == NULL){
        *instance = (AFINSTANCE *) SDF_MALLOC (sizeof(**instance));
        (*instance)->state              = AFSTATE_IDLE;
        (*instance)->resolve_base_dn[0] = 0;
        (*instance)->default_base_dn[0] = 0;
        (*instance)->cluster_d21[0]     = 0;
        (*instance)->dn[0]              = 0;
        (*instance)->migration_mode     = d02global.conf_warm.migration_mode;
    }

    // strcpy(object, "(objectClass=*)");
 
    SDFLOG_DEBUG((B, "trans_private->e4.action   [%d]", trans_private->e4.action))
    alist=NULL;
    vlist=NULL;
    sprintf(c_temp, "%d", trans_private->e4.trans_id);
    LBER_valuelist_add(&vlist, c_temp, NULL);
    c_temp[0] = trans_private->e4.action;
    
    LBER_valuelist_add_binary(&vlist, c_temp, 1, NULL);
    SDFLOG_DEBUG((B, "vlist len   [%d]", vlist->len))
    LBER_attrlist_add(&alist, "private", vlist, NULL);

    LDAP_gen_private_by_attrlist(LDAP_PRIVATE_ID_END_TRANS_ARGUMENT, alist, (BER**)&ber, 0, NULL);
    af_gen_control_transaction(NULL, lmsg, &control);
    *tid = LDAP_gen_extended_common_request(LDAP_EXT_HANDLE,
                              (BER**)req,
                              LDAP_EXTENDED_END_TRANSACTION,
                              ber->berval,
                              ber->len,
                              control,
                              error
                              );
    if (*tid == 0)
    {
        SDFLOG_ERROR((B, "LDAP_gen_extended_request return error [%s]", error))
        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        return -1;
    }
    SDFLOG_DEBUG((B, "tid   [%d]", *tid))
    if (b_attrs != NULL) LDAP_ber_free(b_attrs);
    
    // instance->main_state = 1;
    // instance->state = AFSTATE_EXTENDED;
    // instance->method = METHOD_END_TRANSACTION;

    return 0;
}

int af_action_process_extended_end_transaction(void *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_extended_end_transaction";
    int r = 0;
    if( mw->instance->migration_mode == DS3_MODE ){
        LDAP_CLNT *lc = (LDAP_CLNT *)res;
        GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(lc->result_code, lc->matchedDN, lc->diagnosticMessage, NULL, 0);
    }else{
        GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_UNWILLING_TO_PERFORM, NULL, NULL, NULL, 0);
    }
    SDFLOG_DEBUG((B, "ldap exended response"))
    return 0;
}

/* ds2a */
int af_init_action_inquiry_subscriber(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_inquiry_subscriber";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    
    if( (instance->index_list[DS2A_FIELD_METHOD_VERSION] == NULL) ||
        !STRCASEEQ( instance->index_list[DS2A_FIELD_METHOD_VERSION]->vals->value, "7") ) 
    {
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "Invalid Method Version", NULL, 0);
        SDFLOG_ERROR((B, "Protocol: Invalid Method Version"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_MSISDN_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "Invalid Msisdn", NULL, 0);
        SDFLOG_ERROR((B, "Protocol: Invalid Msisdn"))
        return -2;
    } 
    else
    { 
        SDFLOG_DEBUG((B, "DS2A_FIELD_MSISDN_INFO [%s]", instance->index_list[DS2A_FIELD_MSISDN_INFO]->vals->value))
        if (check_numeric_valid(instance->index_list[DS2A_FIELD_MSISDN_INFO]->vals->value, 15))
        {
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "Invalid Msisdn", NULL, 0);
            SDFLOG_ERROR((B, "Protocol: Invalid Msisdn"))
            return -2;
        }
    }

    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_INQUIRY_SUBSCRIBER;
    
    return 0;
}

int af_init_action_inquiry_pcf_vas(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_inquiry_pcf_vas";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    
    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_INQUIRY_PCF_VAS;
    
    return 0;
}

int af_action_process_inquiry_subscriber(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_inquiry_subscriber";

#define INQUIRY_SUBSCIRBER_GENERIC_SEARCH(_SERVICE_){                               \
    USE_RPC_SERVICE(mw->instance, _SERVICE_, GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);\
    tid = grpc_tid_gen();                                                           \
    SDFLOG_DEBUG((B, "Search Dn     :[%s]", base_dn))                               \
    SDFLOG_DEBUG((B, "tid           :[%u]", tid))                                   \
    SDFLOG_DEBUG((B, "GID           :[%lu]", mw->instance->gid))                    \
    GEN_GRPC_ATTRS(attrs, i);                                                       \
    if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, scope, object_class, d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){\
    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))           \
    return -1;                                                                      \
    }                                                                               \
}

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    char scope[32];
    char base_dn[1024];
    char object_class[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    strcpy(scope, "base");
    strcpy(object_class, "(objectClass=*)");
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    switch( mw->instance->main_state ){
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_GUPSUBPROFILE: //Query gupSubProfile
        {
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = NULL;
                BER *b_attrs        = NULL;

                LBER_valuelist_add(&vlist, "221 Key Unknown", NULL);
                LBER_attrlist_add(&alist, "resultInfo", vlist, NULL); 
                SDFLOG_DEBUG((B, "Response AVP : type  [%s]", alist->name))
                SDFLOG_DEBUG((B, "             : value [%s]", alist->vals->value))
                if (LDAP_gen_ber_attrlist(alist, &b_attrs, 1, NULL) != 0)
                {
                    SDFLOG_ERROR((B, "Cannot LDAP_gen_ber_attrlist"));
                }
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_SUCCESS, NULL, NULL, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }else{
                // Get UID
                char buffer[MAX_SIZE_BASE_DN];
                char *ptr = mw->instance->resolve_base_dn;
                if( (ptr = strstr(ptr,"uid=")) == NULL ){
                    SDFLOG_WARN((B, "Cannot get uid from resolve base dn"));
                }else{
                    i = 0;
                    ptr += 4; //size of "uid="
                    /* Copy UID */
                    while ( (ptr[i]) && (i < 256) ){
                        if( ptr[i] == ',' )
                        {
                            buffer[i] = '\0';
                            break;
                        }
                        buffer[i] = ptr[i];
                        ++i;
                    }

                    BER_VALLIST *vlist = NULL;
                    BER_ATTRLIST *alist = mw->instance->res_alist;
                    LBER_valuelist_add(&vlist, buffer, NULL);
                    LBER_attrlist_add(&alist, "uid", vlist, NULL); 
                    mw->instance->index_res_alist[DS2A_FIELD_UID] = alist->prev;
                }

                sprintf(base_dn, "msisdn=%s,subdata=profile,ds=gup,subdata=services,%s", mw->instance->index_list[DS2A_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                i = 0;
                strcpy(attrs[i++], "baId");
                strcpy(attrs[i++], "caId");
                strcpy(attrs[i++], "serviceProfileId");
                strcpy(attrs[i++], "homeLocation");
                strcpy(attrs[i++], "DPmode");
                strcpy(attrs[i++], "gupdataServLifeStyle");
                attrs[i][0] = 0;
                INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");                        
                mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_AMFSUBPROFILE;
            }
            break;
        }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_AMFSUBPROFILE: //Query amfSubProfile
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                mw->instance->res_alist = NULL;
                int i_entry, i_alist, i_vlist;
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = mw->instance->res_alist;
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("baId")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_BAID] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("caId")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_CAID] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("serviceProfileId")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_SERVICEPROFILEID] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("homeLocation")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_HOMELOCATION] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("DPmode")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DPMODE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("gupdataServLifeStyle")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_GUPDATASERVLIFESTYLE] = alist->prev;
                            }
                        }
                    }
                }

                // 2) Send next request
                sprintf(base_dn, "subdata=amfProfile,subdata=profile,ds=amf,subdata=services,%s", mw->instance->resolve_base_dn);
                i = 0;
                strcpy(attrs[i++], "subscriptionstate"); 
                strcpy(attrs[i++], "meteringmethod");
                attrs[i][0] = 0;
                INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");
                mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_AMFACCOUNT;
            }else{
                SDFLOG_DEBUG((B, "Could not find gupSubProfile. "))
                SDFLOG_ERROR((B, "LDAP Exteneded Response [Operation Error : Inquiry subscriber failed]"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "Inquiry subscriber failed", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }
            break;
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_AMFACCOUNT: //Query amfAccount
        {
            int i_entry, i_alist, i_vlist;
            BER_VALLIST *vlist  = NULL;
            BER_ATTRLIST *alist = mw->instance->res_alist;
            // 1) collect all data
            for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                    SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                    if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                        if(INQUIRY_SUBSCIRBER_CMP_ATTR("subscriptionstate")){
                            INQUIRY_SUBSCRIBER_CREATE_ATTR();
                            mw->instance->index_res_alist[DS2A_FIELD_SUBSCRIPTIONSTATE] = alist->prev;
                        }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("meteringmethod")){
                            INQUIRY_SUBSCRIBER_CREATE_ATTR();
                            mw->instance->index_res_alist[DS2A_FIELD_METERINGMETHOD] = alist->prev;
                        }
                    }
                }
            }
            // 2) Send next request
            sprintf(base_dn, "accountId=%s,subdata=profile,ds=amf,subdata=services,%s", mw->instance->index_list[DS2A_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
            i = 0;
            //strcpy(attrs[i++], "slfSessionInfo");
            attrs[i][0] = 0;
            INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");

            // Verify default value
            if( mw->instance->index_res_alist[DS2A_FIELD_METERINGMETHOD] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("meteringMethod");
                mw->instance->index_res_alist[DS2A_FIELD_METERINGMETHOD] = alist->prev;
            }
            // Verify default value
            if( mw->instance->index_res_alist[DS2A_FIELD_SUBSCRIPTIONSTATE] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("subscriptionState");
                mw->instance->index_res_alist[DS2A_FIELD_SUBSCRIPTIONSTATE] = alist->prev;
            }
            mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_DS3SUBPROFILE;
            break;
        }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_DS3SUBPROFILE: //Query ds3SubProfile
        {
            int i_entry, i_alist, i_vlist;
            BER_VALLIST *vlist  = NULL;
            BER_ATTRLIST *alist = mw->instance->res_alist;
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("registrationDate")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_REGISTRATIONDATE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("timeDrivenState")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_TIMEDRIVENSTATE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("fraudFlag")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_FRAUDFLAG] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("pinFraudFlag")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_PINFRAUDFLAG] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("userReqSuspend")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_USERREQSUSPEND] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("activeStopTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_ACTIVESTOPTIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("suspendStopTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_SUSPENDSTOPTIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("disableStopTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DISABLESTOPTIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("terminateStopTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_TERMINATESTOPTIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3classOfservice")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3CLASSOFSERVICE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3shareAccSwitch")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3SHAREACCSWITCH] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3notificationPolicyControl")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3NOTIFICATIONPOLICYCONTROL] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3recurringPolicyControl")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3RECURRINGPOLICYCONTROL] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3deselectPolicyControl")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3DESELECTPOLICYCONTROL] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3offlineNotifPolicyControl")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3OFFLINENOTIFPOLICYCONTROL] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("amf1stTopupRewardLifeTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_AMF1STTOPUPREWARDLIFETIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("amf1stTopupRewardPromo")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_AMF1STTOPUPREWARDPROMO] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3NotifPolicyControlAS")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3NOTIFPOLICYCONTROLAS] = alist->prev;
                            }
                        }
                    }
                }
            }
            // 2) Send next request
            sprintf(base_dn, "subdata=ds3profile,subdata=profile,ds=ds3,subdata=services,%s", mw->instance->resolve_base_dn);
            i = 0;                                                                          
            //strcpy(attrs[i++], "slfSessionInfo");                                         
            attrs[i][0] = 0;                        
            INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");                        
            mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_DS3SECURITY;
            break;
        }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_DS3SECURITY: //Query ds3security
        {
            int i_entry, i_alist, i_vlist;
            BER_VALLIST *vlist  = NULL;
            BER_ATTRLIST *alist = mw->instance->res_alist;
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("language")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_LANGUAGE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3brandId")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3BRANDID] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3spName")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3SPNAME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3customerCategory")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERCATEGORY] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3customerSubCategory")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSUBCATEGORY] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("emailLanguage")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_EMAILLANGUAGE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ivrLanguage")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_IVRLANGUAGE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ussdLanguage")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_USSDLANGUAGE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("smsLanguage")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_SMSLANGUAGE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3customerSegment")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSEGMENT] = alist->prev;
                            }
                        }
                    }
                }

            }

            // Verify default value
            if( mw->instance->index_res_alist[DS2A_FIELD_LANGUAGE] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("language");
                mw->instance->index_res_alist[DS2A_FIELD_LANGUAGE] = alist->prev;
            }
            if( mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERCATEGORY] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("ds3customerCategory");
                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERCATEGORY] = alist->prev;
            }
            if( mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSUBCATEGORY] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("ds3customerSubCategory");
                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSUBCATEGORY] = alist->prev;
            }
            if( mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSEGMENT] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("ds3customerSegment");
                mw->instance->index_res_alist[DS2A_FIELD_DS3CUSTOMERSEGMENT] = alist->prev;
            }

            // 2) Send next request
            sprintf(base_dn, "subdata=security,subdata=profile,ds=ds3,subdata=services,%s", mw->instance->resolve_base_dn);
            i = 0;                                                                          
            //strcpy(attrs[i++], "slfSessionInfo");                                         
            attrs[i][0] = 0;                        
            INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");                        
            mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION;
            break;
        }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION: //Query SlfServiceLocation
        {
            int i_entry, i_alist, i_vlist;
            BER_VALLIST *vlist  = NULL;
            BER_ATTRLIST *alist = mw->instance->res_alist;
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3pin")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3PIN] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3hackTime")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3HACKTIME] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3hints")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("ds3pin2")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_DS3PIN2] = alist->prev;
                            }
                        }
                    }
                }
            }

            // Verify default value
            if( mw->instance->index_res_alist[DS2A_FIELD_DS3HACKTIME] == NULL ){
                INQUIRY_SUBSCRIBER_CREATE_DEFAULT_ATTR("ds3hackTime");
                mw->instance->index_res_alist[DS2A_FIELD_DS3HACKTIME] = alist->prev;
            }

            // 2) Send next request
            sprintf(base_dn, "subdata=profile,ds=slf,subdata=services,%s", mw->instance->resolve_base_dn);
            i = 0;                                                                          
            strcpy(attrs[i++], "servicelocation");
            attrs[i][0] = 0;                 
            strcpy(scope, "one");
            strcpy(object_class, "(objectClass=SlfServiceLocation)");       
            INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");
            mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_RESOLVE_SLFSERVICELOCATION_ELEMENT;
            break;
        }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_RESOLVE_SLFSERVICELOCATION_ELEMENT:
            {
                int i_entry, i_alist, i_vlist;
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = mw->instance->res_alist;
                // 1) collect all data
                if( res->resultcode == LDAP_RESULT_SUCCESS){
                    for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                        SDFLOG_DEBUG((B, "dn: %s", res->entries[i_entry]->dn))
                        SDFLOG_DEBUG((B, "res->n_entries %d", res->n_entries))
                        for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                            SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                            if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                                if(INQUIRY_SUBSCIRBER_CMP_ATTR("servicelocation") && memcmp("systemId=ocf", res->entries[i_entry]->dn, 12) == 0){
                                    INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                    mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF] = alist->prev;
                                    SDFLOG_DEBUG((B, "Adding OCF"))
                                }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("servicelocation") && memcmp("systemId=bcf", res->entries[i_entry]->dn, 12) == 0){
                                    INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                    mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_BCF] = alist->prev;
                                    SDFLOG_DEBUG((B, "Adding BCF"))
                                }
                            }
                        }
                    }
                }

                if((mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_BCF] != NULL) ||
                   (mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF] != NULL))
                {
                    sprintf(base_dn, "o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB");
                }
                else
                {
                    SDFLOG_ERROR((B, "There is neither systemId BCF nor OCF. Straight away responses back to client"))
                    res->resultcode = LDAP_RESULT_SUCCESS;
                    res->matcheddn = "";
                    goto _ds2a_response;
                }
                strcpy(scope, "base");
                strcpy(object_class, "(objectClass=*)");
                INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D20");
                mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT;
            }
            break;
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT:
            // 1) Resolve 
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                SDFLOG_ERROR((B, "Cannot get Service Location"))
                SDFLOG_ERROR((B, "LDAP Exteneded Response [Operation Error :  Missing ServiceLocation Configuration]"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "Missing ServiceLocation Configuration", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
                break;
            }else{
                if( mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_BCF] != NULL ){
                    i = 0;                                                                          
                    strcpy(attrs[i++], "globaltitle");
                    strcpy(attrs[i++], "pointcode");
                    attrs[i][0] = 0;                 
                    strcpy(scope, "base");
                    sprintf(base_dn, "serviceLocation=%s,o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB", mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_BCF]->vals->value);
                    mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT_BCF;
                }else if( mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF] != NULL ){
                    i = 0;                                                                          
                    strcpy(attrs[i++], "ipv4Address");
                    strcpy(attrs[i++], "port");
                    attrs[i][0] = 0;                 
                    strcpy(scope, "base");
                    sprintf(base_dn, "serviceLocation=%s,o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB", mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF]->vals->value);
                    mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT_OCF;
                }

                // 2) Send next request
                INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");
                break;                        
            }
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT_BCF:
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                int i_entry, i_alist, i_vlist;
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = mw->instance->res_alist;
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("globaltitle")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_GLOBALTITLE] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("pointcode")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_POINTCODE] = alist->prev;
                            }
                        }
                    }
                }
                // 2) Send next request
            }else{
                if ( strcasecmp(res->matcheddn,"o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB") != 0)
                {
                    SDFLOG_ERROR((B, "Cannot find RDN [o=locatorElements]"))
                    SDFLOG_ERROR((B, "LDAP Exteneded Response [Operation Error : Missing ServiceLocation Configuration]"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "Missing ServiceLocation Configuration", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }
                else
                {
                    SDFLOG_DEBUG((B, "Cannot get slfservice location(BCF)"))
                }
            }
            if(  mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF] == NULL )
            {
                    //TODO: goto last state
                    SDFLOG_DEBUG((B, "No systemId OCF. Straight away responses back to client"))
                    mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_RESPONSE;
                    res->resultcode = LDAP_RESULT_SUCCESS;
                    res->matcheddn = "";
                    goto _ds2a_response;
            }
            SDFLOG_DEBUG((B, "Continue searching for slfservice location OCF"))
            i = 0;                                                                          
            strcpy(attrs[i++], "ipv4Address");
            strcpy(attrs[i++], "port");
            attrs[i][0] = 0;                 
            strcpy(scope, "base");
            sprintf(base_dn, "serviceLocation=%s,o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB", mw->instance->index_res_alist[DS2A_FIELD_SERVICELOCATION_OCF]->vals->value);
            mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT_OCF;
            INQUIRY_SUBSCIRBER_GENERIC_SEARCH("D21");
            break;  
        case DS2A_INQUIRY_SUBSCRIBER_STATE_QUERY_SLFSERVICELOCATION_ELEMENT_OCF:
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                // 1) collect all data
                int i_entry, i_alist, i_vlist;
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = mw->instance->res_alist;
                for(i_entry = 0 ; i_entry < res->n_entries ;i_entry++){
                    for(i_alist = 0; i_alist < res->entries[i_entry]->n_attributes; i_alist++){
                        SDFLOG_DEBUG((B, "attr  :[%s]", res->entries[i_entry]->attributes[i_alist]->name))
                        if( res->entries[i_entry]->attributes[i_alist]->n_values > 0 ){
                            if(INQUIRY_SUBSCIRBER_CMP_ATTR("ipv4Address")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_IPV4ADDRESS] = alist->prev;
                            }else if(INQUIRY_SUBSCIRBER_CMP_ATTR("port")){
                                INQUIRY_SUBSCRIBER_CREATE_ATTR();
                                mw->instance->index_res_alist[DS2A_FIELD_PORT] = alist->prev;
                            }
                        }
                    }
                }
                mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_RESPONSE;
            }else{
                if ( strcasecmp(res->matcheddn,"o=locatorElements,o=slf,o=nss,o=services,o=AIS,dc=C-NTDB") != 0)
                {
                    SDFLOG_ERROR((B, "Cannot find RDN [o=locatorElements]"))
                    SDFLOG_ERROR((B, "LDAP Exteneded Response [Operation Error : Missing ServiceLocation Configuration]"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "Missing ServiceLocation Configuration", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }
                else
                {
                    mw->instance->main_state = DS2A_INQUIRY_SUBSCRIBER_STATE_RESPONSE;
                    res->resultcode = LDAP_RESULT_SUCCESS;
                    res->matcheddn = "";
                    SDFLOG_ERROR((B, "Cannot get slfservice location(BCF)"))
                }
            }       
        case DS2A_INQUIRY_SUBSCRIBER_STATE_RESPONSE: //Query SlfServiceLocation
_ds2a_response:            
            if( res->resultcode == LDAP_RESULT_SUCCESS){
                int i_entry, i_alist, i_vlist;
                BER_VALLIST *vlist  = NULL;
                BER_ATTRLIST *alist = mw->instance->res_alist;
                BER_ATTRLIST *alist_temp = NULL;

                SDFLOG_DEBUG((B, "Response oid : [%s]", mw->instance->oid))
                vlist               = NULL;
                alist               = NULL;
                BER *b_attrs        = NULL;
                BER *ber            = NULL;
                char buffer[MAX_SIZE_SESSION_INFO];
                int i = 0;
                buffer[0] = 0;

                vlist = NULL;
                LBER_valuelist_add(&vlist, "7", NULL);
                LBER_attrlist_add(&alist, "methodVersion", vlist, NULL); 
                
                vlist = NULL;
                LBER_valuelist_add(&vlist, mw->instance->index_list[DS2A_FIELD_MSISDN_INFO]->vals->value, NULL);
                alist_temp = NULL;
                LBER_attrlist_add(&alist_temp, "msisdnInfo", vlist, NULL); 
                mw->instance->index_res_alist[DS2A_FIELD_MSISDN_INFO] = alist_temp;

                /*if((mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS] != NULL) && 
                   (mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value != NULL))
                {
                    unsigned long int hints;
                    int len;
                    char bstr[11];
                    SDFLOG_DEBUG((B, "DS2A_FIELD_DS3HINTS before       : [%s]", mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value))
                    len = strlen(mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value);
                    if(len>10)
                    {
                        strncpy(bstr, mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value+len-10, 10);
                    }
                    else
                    {
                        strncpy(bstr, mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value, len);
                    }
                    hints = strtol(bstr, buffer, 2);
                    sprintf(mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value,"%X", hints);
                    SDFLOG_DEBUG((B, "DS2A_FIELD_DS3HINTS converted to : [%s]", mw->instance->index_res_alist[DS2A_FIELD_DS3HINTS]->vals->value))
                }
*/
                vlist = NULL;
                buffer[0] = 0;
                if( DS2A_GET_RESUTLINFO(mw->instance, buffer, 15,
                    DS2A_FIELD_MSISDN_INFO,
                    DS2A_FIELD_UID,
                    DS2A_FIELD_SUBSCRIPTIONSTATE,
                    DS2A_FIELD_LANGUAGE,
                    DS2A_FIELD_DS3PIN,
                    DS2A_FIELD_DS3HACKTIME,
                    DS2A_FIELD_DS3HINTS,
                    DS2A_FIELD_METERINGMETHOD,
                    DS2A_FIELD_SERVICEPROFILEID,
                    DS2A_FIELD_DS3PIN2,
                    DS2A_FIELD_DS3BRANDID,
                    DS2A_FIELD_DS3SPNAME,
                    DS2A_FIELD_DS3CUSTOMERCATEGORY,
                    DS2A_FIELD_DS3CUSTOMERSUBCATEGORY,
                    DS2A_FIELD_DS3CUSTOMERSEGMENT) != 0 )
                {
                    SDFLOG_ERROR((B, "DS2A_GET_RESUTLINFO return error"))
                    return -1;
                }
                SDFLOG_DEBUG((B, "ds2a resultInfo   : [%s]", buffer))
                LBER_valuelist_add(&vlist, buffer, NULL);
                LBER_attrlist_add(&alist, "resultInfo", vlist, NULL); 

                vlist = NULL;
                buffer[0] = 0;
                if( DS2A_GET_ACCOUNTINGINFO(mw->instance, buffer, 12,
                    DS2A_FIELD_DS3CLASSOFSERVICE,
                    DS2A_FIELD_SERVICELOCATION_BCF,
                    DS2A_FIELD_GLOBALTITLE,
                    DS2A_FIELD_POINTCODE,
                    DS2A_FIELD_DS3SHAREACCSWITCH,
                    DS2A_FIELD_SERVICELOCATION_OCF,
                    DS2A_FIELD_IPV4ADDRESS,
                    DS2A_FIELD_PORT,
                    DS2A_FIELD_GUPDATASERVLIFESTYLE,
                    DS2A_FIELD_DS3NOTIFICATIONPOLICYCONTROL,
                    DS2A_FIELD_DS3RECURRINGPOLICYCONTROL,
                    DS2A_FIELD_DS3DESELECTPOLICYCONTROL) != 0 )
                {
                    SDFLOG_ERROR((B, "DS2A_GET_ACCOUNTINGINFO return error"))
                    return -1;
                }
                SDFLOG_DEBUG((B, "ds2a AccountInfo  : [%s]", buffer))
                LBER_valuelist_add(&vlist, buffer, NULL);
                LBER_attrlist_add(&alist, "accountingInfo", vlist, NULL); 
                
                vlist = NULL;
                LBER_valuelist_add(&vlist, ",,,,,,,,,", NULL);
                LBER_attrlist_add(&alist, "toggledAccountingInfo", vlist, NULL); 
                
                vlist = NULL;
                LBER_valuelist_add(&vlist, ",,,,,,,,", NULL);
                LBER_attrlist_add(&alist, "prefixAccountingInfo", vlist, NULL); 
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                int r = LDAP_gen_extended_response(d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, NULL, mw->instance->oid, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, error);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))
                    return -1;
                }
                l_sess_send_response(mw->ref, ber); 
                mw->instance->main_state = METHOD_STATE_IDLE;
            }else{
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(res->resultcode, res->matcheddn, res->resultdescription, NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }
            break;
        default:
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_inquiry_pcf_vas(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_inquiry_pcf_vas";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    char base_dn[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    switch( mw->instance->main_state ){
        case 1:
        {
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                mw->instance->main_state = METHOD_STATE_IDLE;
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(res->resultcode, res->matcheddn, res->resultdescription, NULL, 0);
            }else{
                sprintf(base_dn, "systemId=gx,subdata=profile,ds=slf,subdata=services,%s", mw->instance->resolve_base_dn);
                USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
                tid = grpc_tid_gen();
                SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
                SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                i = 0;
                strcpy(attrs[i++], "slfSessionInfo");
                attrs[1][0] = 0;
                GEN_GRPC_ATTRS(attrs, i);
                if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, "base", "(objectClass=*)", d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                    return -1;
                }
                mw->instance->main_state = 2;
            }
            break;
        }
        case 2:
        default:
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

/* ds2c */
int af_init_action_inquiry_sessioninfo(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_inquiry_sessioninfo";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    

    if( (instance->index_list[DS2C_FIELD_METHOD_VERSION] == NULL) || 
        !STRCASEEQ( instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value, "1") ) 
    {
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "InquirySessionInfo:001:Invalid Method Version", NULL, 0);
        SDFLOG_ERROR((B, "InquirySessionInfo:001:Invalid Method Version"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_MSISDN_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "InquirySessionInfo:001:Invalid msisdn", NULL, 0);
        SDFLOG_ERROR((B, "InquirySessionInfo:001:Invalid msisdn"))
        return -2;
    }
    else
    {
        SDFLOG_DEBUG((B, "DS2C_FIELD_MSISDN_INFO [%s]", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))
        if (check_numeric_valid(instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 15))
        {
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "InquirySessionInfo:001:Invalid msisdn", NULL, 0);
            SDFLOG_ERROR((B, "InquirySessionInfo:001:Invalid msisdn"))
            return -2;
        }
    }   
    if( instance->index_list[DS2C_FIELD_SESSION_TYPE] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "InquirySessionInfo:001:Invalid SessionType", NULL, 0);
        SDFLOG_ERROR((B, "InquirySessionInfo:001:Invalid SessionType"))
        return -2;
    }else{
        if( STRCASEEQ( ds2c_map_system_type(instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), "Unknown") ){
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "InquirySessionInfo:001:Invalid SessionType", NULL, 0);
            SDFLOG_ERROR((B, "InquirySessionInfo:001:Invalid SessionType"))
            return -2;
        }
    }

    //DS2A,<TIMESTAMP>,TX,SESSIONINFO,inquirySessionInfo,<ldapmessage>,<methodVersion>,<msisdn>,<sessionType>
    //SDFLOG_DEBUG((B, "DS2A,<TIMESTAMP>,TX,inquirySessionInfo,<ldapmessage>,%s,%s,%s", 
    //                instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value,
    //                instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value,
    //                instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value ))
    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = PUSH_SESSION_RESOLVE_ALIAS;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_INQUIRY_SESSION;
    
    return 0;
}

int af_init_action_push_sessioninfo(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_push_sessioninfo";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;

    if( (instance->index_list[DS2C_FIELD_METHOD_VERSION] == NULL) || 
        !STRCASEEQ( instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value, "1"))
    {
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid Method Version", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid Method Version"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_MSISDN_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid msisdn", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid msisdn"))
        return -2;
    } 
    else
    { 
        SDFLOG_DEBUG((B, "DS2C_FIELD_MSISDN_INFO [%s]", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))
        if (check_numeric_valid(instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 15))
        {
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid msisdn", NULL, 0);
            SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid msisdn"))
            return -2;
        }   
    }
    if( instance->index_list[DS2C_FIELD_SESSION_TYPE] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid SessionType", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid SessionType"))
        return -2;
    }else{
        if( STRCASEEQ( ds2c_map_system_type(instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), "Unknown") ){
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid SessionType", NULL, 0);
            SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid SessionType"))
            return -2;
        }
    }
    if( instance->index_list[DS2C_FIELD_SESSION_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:Invalid SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:001:Invalid SessionInfo"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->next != instance->index_list[DS2C_FIELD_SESSION_INFO]->vals ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:008:Badly formatted SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:008:Badly formatted SessionInfo"))
        return -2;
    }    
    if( strlen(instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value) >= (MAX_SIZE_SESSION_INFO - MAX_SIZE_TIME_FORMAT) ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PushSessionInfo:001:SessionInfo too large", NULL, 0);
        SDFLOG_ERROR((B, "PushSessionInfo:001:SessionInfo too large"))
        return -2;
    }

    //DS2A,<TIMESTAMP>,TX,SESSIONINFO,PushSessionInfo,<ldapmessage>,<methodVersion>,<msisdn>
    //SDFLOG_DEBUG((B, "DS2A,<TIMESTAMP>,TX,%s,PushSessionInfo,<ldapmessage>,%s,%s", 
    //                instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value,
    //                instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value,
    //                instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))

    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_PUSH_SESSION;
    
    return 0;
}

int af_init_action_pull_sessioninfo(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_pull_sessioninfo";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    
    if( (instance->index_list[DS2C_FIELD_METHOD_VERSION] == NULL) || 
        !STRCASEEQ( instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value, "1") ) 
    {
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid Method Version", NULL, 0);
        SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid Method Version"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_MSISDN_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid msisdn", NULL, 0);
        SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid msisdn"))
        return -2;
    }
    else
    {
        SDFLOG_DEBUG((B, "DS2C_FIELD_MSISDN_INFO [%s]", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))
        if (check_numeric_valid(instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 15))
        {
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid msisdn", NULL, 0);
            SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid msisdn"))
            return -2;
        }
    } 
    if( instance->index_list[DS2C_FIELD_SESSION_TYPE] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid SessionType", NULL, 0);
        SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid SessionType"))
        return -2;
    }else{
        if( STRCASEEQ( ds2c_map_system_type(instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), "Unknown") ){
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid SessionType", NULL, 0);
            SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid SessionType"))
            return -2;
        }
    }
    if( instance->index_list[DS2C_FIELD_SESSION_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:001:Invalid SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "PullSessionInfo:001:Invalid SessionInfo"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->next != instance->index_list[DS2C_FIELD_SESSION_INFO]->vals ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "PullSessionInfo:008:Badly formatted SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "PullSessionInfo:008:Badly formatted SessionInfo"))
        return -2;
    }
    //DS2A,<TIMESTAMP>,TX,SESSIONINFO,pullSessionInfo,<ldapmessage>,<methodVersion>,<msisdn>
    //SDFLOG_DEBUG((B, "DS2A,<TIMESTAMP>,TX,%s,pullSessionInfo,<ldapmessage>,%s,%s", 
    //                instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value,
    //                instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value,
    //                instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))

    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_PULL_SESSION;
    
    return 0;
}

int af_init_action_modify_sessioninfo(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_modify_sessioninfo";
    char base_dn[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    

    if( (instance->index_list[DS2C_FIELD_METHOD_VERSION] == NULL) || 
        !STRCASEEQ( instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value, "1") ) 
    {
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid Method Version", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid Method Version"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_MSISDN_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid msisdn", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid msisdn"))
        return -2;
    }
    else
    {
        SDFLOG_DEBUG((B, "DS2C_FIELD_MSISDN_INFO [%s]", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))
        if (check_numeric_valid(instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 15))
        {
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid msisdn", NULL, 0);
            SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid msisdn"))
            return -2;
        }
    } 
    if( instance->index_list[DS2C_FIELD_SESSION_TYPE] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid SessionType", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid SessionType"))
        return -2;
    }else{
        if( STRCASEEQ( ds2c_map_system_type(instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), "Unknown") ){
            GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid SessionType", NULL, 0);
            SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid SessionType"))
            return -2;
        }
    }
    if( instance->index_list[DS2C_FIELD_OLD_SESSION_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid SessionInfo"))
        return -2;
    }
    if( instance->index_list[DS2C_FIELD_NEW_SESSION_INFO] == NULL ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:Invalid SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:Invalid SessionInfo"))
        return -2;
    }
    if( (instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->next != instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals) ||
        (instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals->next != instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals)){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:008:Badly formatted SessionInfo", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:008:Badly formatted SessionInfo"))
        return -2;
    }
    if( strlen(instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals->value) >= (MAX_SIZE_SESSION_INFO - MAX_SIZE_TIME_FORMAT) || 
        strlen(instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->value) >= (MAX_SIZE_SESSION_INFO - MAX_SIZE_TIME_FORMAT) ){
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ModifySessionInfo:001:SessionInfo too large", NULL, 0);
        SDFLOG_ERROR((B, "ModifySessionInfo:001:SessionInfo too large"))
        return -2;
    }
    //DS2A,<TIMESTAMP>,TX,SESSIONINFO,modifySessionInfo,<ldapmessage>,<methodVersion>,<msisdn>
    //SDFLOG_DEBUG((B, "DS2A,<TIMESTAMP>,TX,%s,modifySessionInfo,%s,<ldapmessage>,%s,%s", 
    //            instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->value,
    //            instance->index_list[DS2C_FIELD_METHOD_VERSION]->vals->value,
    //            instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value))

    get_baseDN("msisdn", instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, base_dn);
    GENERIC_RESOLVE_DN(base_dn);
    instance->main_state = 1;
    instance->state = AFSTATE_EXTENDED;
    instance->method = METHOD_MODIFY_SESSION;
    
    return 0;
}

int af_action_process_inquiry_sessioninfo(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_inquiry_sessioninfo";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    char base_dn[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    switch( mw->instance->main_state ){
        case 1:
        {
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                mw->instance->main_state = METHOD_STATE_IDLE;
                SDFLOG_ERROR((B, "InquirySessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:002:Cannot read Damocles2", NULL, 0);
            }else{
                sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
                tid = grpc_tid_gen();
                SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
                SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                i = 0;
                strcpy(attrs[i++], "slfCacheData");
                attrs[1][0] = 0;
                GEN_GRPC_ATTRS(attrs, i);
                if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, "base", "(objectClass=*)", d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                    return -1;
                }
                mw->instance->main_state = 2;
            }
            break;
        }
        case 2:
        {
            BER *ber            = NULL;
            BER *b_attrs        = NULL;
            BER_ATTRLIST *alist = NULL;
            BER_VALLIST *vlist  = NULL;

            if( res->resultcode == LDAP_RESULT_SUCCESS){
                entry_print_all(res);
                
                vlist = NULL;
                LBER_valuelist_add(&vlist, "1", NULL);
                LBER_attrlist_add(&alist, "methodVersion", vlist, NULL); 

                vlist = NULL;
                LBER_valuelist_add(&vlist, mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, NULL);
                LBER_attrlist_add(&alist, "resultInfo", vlist, NULL); 
                
                vlist = NULL;
                LBER_valuelist_add(&vlist, mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value, NULL);
                LBER_attrlist_add(&alist, "sessionType", vlist, NULL); 
                
                vlist = NULL;
                //r = entry_get_vallist_by_attribute(res, "slfCacheData", &vlist, 11, ds2c_verify_session_info);
                r = entry_get_vallist_by_attribute(res, "slfCacheData", &vlist, 0, ds2c_verify_session_info);
                if( r == -3 ){
                   SDFLOG_ERROR((B, "InquirySessionInfo:008:Badly formatted InquirySessionInfo"))
                   GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:008:Badly formatted InquirySessionInfo", NULL, 0);
                }else if( r == -2){ // No such object
                    SDFLOG_ERROR((B, "InquirySessionInfo:002:Cannot read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:002:Cannot read Damocles2", NULL, 0);
                }else if( r == -1){ // No any attribute
                    SDFLOG_ERROR((B, "InquirySessionInfo:004:No SessionInfo"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:004:No SessionInfo", NULL, 0);
                }else if( vlist == NULL ){ // No any value
                    SDFLOG_ERROR((B, "InquirySessionInfo:004:No SessionInfo"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:004:No SessionInfo", NULL, 0);
                }else{
                    SDFLOG_DEBUG((B, "Total session info : [%d]", r))
                    SORTSTRUCT* sortStruct = malloc(sizeof(SORTSTRUCT)*r);
                    BER_VALLIST *t_vlist  = NULL;
                    int objCount = 0;
                    int current_time = 0;
                    t_vlist = vlist;
                    while( t_vlist )
                    {
                        SDFLOG_DEBUG((B, "Validaing exising session info [%s].", t_vlist->value))
                        // if (ds2c_verify_session_info(t_vlist->value) == 0)
                        {
                            // //Find existing session and Find old session
                            char str_time[12];
                            char str_session[501];
                            int len;
                            memcpy(str_time, t_vlist->value, 11);
                            str_time[11] = 0;
                            // len = strlen(t_vlist->value) - 11;
                            // SDFLOG_DEBUG((B, "len [%d]", len))
                            // SDFLOG_DEBUG((B, "t_vlist->value+11 [%s]", t_vlist->value+11))
                            // memcpy(str_session, t_vlist->value+11, len);
                            // str_session[len] = 0;
                            // SDFLOG_DEBUG((B, "str_session[%s]", str_session))
                            // strcpy(t_vlist->value,str_session);
                            strcpy(t_vlist->value, t_vlist->value+11);
                            current_time = atoi(str_time);
                            sortStruct[objCount].key = current_time;
                            sortStruct[objCount].obj = t_vlist;
                            objCount++;

                            SDFLOG_DEBUG((B, "The session info is valid."))
                        }

                        t_vlist = t_vlist->next;
                        if( t_vlist == vlist){
                            break;
                        }
                    }
                    SDFLOG_DEBUG((B, "Total [%d] Limit [%d]", objCount, d02global.app_conf.ds2c.max_sesssion_info))
                    if (objCount > d02global.app_conf.ds2c.max_sesssion_info)
                    {
                        qsort(sortStruct, objCount, sizeof(SORTSTRUCT), cmp_object);
                        r = 0;
                        while (objCount > d02global.app_conf.ds2c.max_sesssion_info)
                        {
                            //Find existing session and Find old session 
                            t_vlist = ((BER_VALLIST*)sortStruct[r].obj);
                            SDFLOG_DEBUG((B, "Removing the oldest session  [%s].", t_vlist->value))
                            LINKEDLIST_REMOVE(vlist, t_vlist)
                            objCount--;
                            r++;
                        }
                    }
                    LBER_attrlist_add(&alist, "sessionInfo", vlist, NULL); 
                    LDAP_gen_ber_attrlist(alist, &b_attrs, 1, error);

                    r = LDAP_gen_extended_response(d02global.ldapd, &ber, mw->tid, LDAP_RESULT_SUCCESS, NULL, NULL, mw->instance->oid, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, error);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", error))
                        return -1;
                    }
                    l_sess_send_response(mw->ref, ber);
                }
            }else{ // No such object
                SDFLOG_ERROR((B, "InquirySessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "InquirySessionInfo:002:Cannot read Damocles2", NULL, 0);
            }
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
        }
        default:
            GENERIC_LDAP_EXTENDED_RESPONE();
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_push_sessioninfo(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_push_sessioninfo";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    BER *ber                = NULL;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *b_attrs            = NULL;
    BER_MODLIST *mlist      = NULL;
    BER_ATTRLIST *alist     = NULL;
    BER_VALLIST *vlist      = NULL;
    BER_VALLIST *t_vlist    = NULL;
    BER_VALLIST *oldest_session = NULL;
    BER_VALLIST *remove_vlist = NULL;
    int oldest_time     = INT_MAX;
    int current_time    = 0;

    char base_dn[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    SDFLOG_DEBUG((B, "Entering state[%d : %d]", mw->instance->main_state, mw->instance->sub_state))

    if (mw->instance->main_state == PUSH_SESSION_RESOLVE_ALIAS)
    {
        if(( af_action_process_generic_resolve_dn(res, mw, error) != 0 ) || (res->resultcode == LDAP_RESULT_ALIAS_PROBLEM)){
            SDFLOG_ERROR((B, "PushSessionInfo:002:Cannot read Damocles2"))
            GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PushSessionInfo:002:Cannot read Damocles2", NULL, 0);
            mw->instance->main_state = METHOD_STATE_IDLE;
        }else{
            sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
            tid = grpc_tid_gen();
            USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
            SDFLOG_DEBUG((B, "Search DN :[%s]", base_dn))
            SDFLOG_DEBUG((B, "tid       :[%u]", tid))
            SDFLOG_DEBUG((B, "GID       :[%lu]", mw->instance->gid))
            i = 0;
            strcpy(attrs[i++], "slfCacheData");
            attrs[1][0] = 0;
            GEN_GRPC_ATTRS(attrs, i);
            if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, "base", "(objectClass=*)", d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                return -1;
            }
            mw->instance->main_state = PUSH_SESSION_SEARCH_CACHEDATA;
            mw->instance->sub_state = METHOD_STATE_IDLE;
        }
    }
    else if (mw->instance->main_state == PUSH_SESSION_SEARCH_CACHEDATA)
    {
        if( res->resultcode == LDAP_RESULT_SUCCESS )
        {
            if (mw->instance->sub_state == METHOD_STATE_IDLE)
            {
                mw->instance->main_state = PUSH_SESSION_MODIFY_SESSION;

                entry_print_all(res);

                vlist = NULL;
                r = entry_get_vallist_by_attribute(res, "slfCacheData", &vlist, 0, NULL);

                if( r == -2)
                {
                    SDFLOG_ERROR((B, "PushSessionInfo:003:Cannot read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PushSessionInfo:003:Cannot read Damocles2", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                }

                SDFLOG_DEBUG((B, "number of session info before validation : [%d]", r))

                SORTSTRUCT* sortStruct = malloc(sizeof(SORTSTRUCT)*r);
                int objCount = 0;
                t_vlist = vlist;
                remove_vlist = NULL;
                BER_VALLIST *t_vlist2;
                while( t_vlist ){

                    SDFLOG_DEBUG((B, "Validaing exising session info [%s].", t_vlist->value))
                    // t_vlist2 = NULL;
                    if (ds2c_verify_session_info(t_vlist->value) == 0)
                    {
                        // //Find existing session and Find old session
                        char str_time[12];
                        memcpy(str_time, t_vlist->value, 11);
                        str_time[11] = 0;
                        current_time = atoi(str_time);
                        sortStruct[objCount].key = current_time;
                        sortStruct[objCount].obj = t_vlist;
                        objCount++;

                        SDFLOG_DEBUG((B, "The session info is valid."))

                        if( STREQ(t_vlist->value+11, mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value ) ){
                            //No action, already added
                            SDFLOG_ERROR((B, "PushSessionInfo:004:SessionInfo Already Exist"))
                            GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PushSessionInfo:004:SessionInfo Already Exist", NULL, 0);
                            mw->instance->main_state = METHOD_STATE_IDLE;
                        }
                        t_vlist2 = t_vlist->next;
                    }
                    else
                    {
                        SDFLOG_DEBUG((B, "The seesion info is invalid, added to removing list."))
                        LBER_valuelist_add(&remove_vlist, t_vlist->value, NULL);
                        t_vlist2 = t_vlist->next;
                        LINKEDLIST_REMOVE(vlist, t_vlist)
                        //t_vlist = t_vlist2;
                        r--;
                    }
                    t_vlist = t_vlist2;
                    if( t_vlist == vlist){
                        break;
                    }
                }
                if (r >= d02global.app_conf.ds2c.max_sesssion_info)
                {
                    qsort(sortStruct, objCount, sizeof(SORTSTRUCT), cmp_object);
                }
                objCount = 0;
                while (r >= d02global.app_conf.ds2c.max_sesssion_info)
                {
                    //Find existing session and Find old session 
                    t_vlist = ((BER_VALLIST*)sortStruct[objCount].obj);
                    SDFLOG_DEBUG((B, "Removing the oldest session  [%s].", t_vlist->value))
                    LBER_valuelist_add(&remove_vlist, t_vlist->value, NULL);
                    r--;
                    objCount++;
                }
                if (remove_vlist != NULL)
                {
                    LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "slfCacheData", remove_vlist, NULL);
                    SDFLOG_DEBUG((B, "Setting up modify delete the sessions"))
                }
                SDFLOG_DEBUG((B, "number of session info after validation : [%d]", r))
            }
        }
        else if ((res->resultcode == LDAP_RESULT_NO_SUCH_OBJECT) && (res->matcheddn != NULL))
        {
            char *slf = NULL;
            SDFLOG_DEBUG((B, "LDAP_RESULT_NO_SUCH_OBJECT"))
            SDFLOG_DEBUG((B, "res->matcheddn[%s]", res->matcheddn))
            slf = strstr(res->matcheddn ,"ds=slf");
            SDFLOG_DEBUG((B, "slf[%s]", slf))
            if (slf != NULL)
            {
                mw->instance->main_state = PUSH_SESSION_ADD_SLF;
                mw->instance->sub_state = PUSH_SESSION_IDLE;

            }
            else
            {
                SDFLOG_ERROR((B, "PushSessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PushSessionInfo:002:Cannot read Damocles2", NULL, 0);   
                mw->instance->main_state = PUSH_SESSION_IDLE;
            }
        }
        else
        {
            SDFLOG_ERROR((B, "PushSessionInfo:002:Cannot read Damocles2"))
            GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PushSessionInfo:002:Cannot read Damocles2", NULL, 0);
            mw->instance->main_state = METHOD_STATE_IDLE;
        }//end if
    }

    if (mw->instance->main_state == PUSH_SESSION_ADD_SLF)
    {
        alist   = NULL;
        vlist   = NULL;
        mlist   = NULL;
        b_attrs = NULL;

        SDFLOG_DEBUG((B, "PUSH_SESSION_ADD_SLF"))
        if (mw->instance->sub_state == PUSH_SESSION_IDLE)
        {
            char *p = res->matcheddn;
            char *pp = strchr(p, '=');
            if (pp != NULL)
            {
                char res[1000];
                strncpy(res,p,pp-p);
                res[pp-p] = 0;
                SDFLOG_DEBUG((B, "RDN [%s]", res))
                if (STRCASEEQ(res, (char *)"ds")){
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_SUBDATA;
                }
                else if (STRCASEEQ(res, (char *)"subdata")){
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_MSISDN;
                }
                else if (STRCASEEQ(res, (char *)"msisdn")){
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_APPID;
                }
                else if (STRCASEEQ(res, (char *)"slfAppId")){
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_CACHETYPE;
                }
                else{
                    mw->instance->sub_state = PUSH_SESSION_IDLE;
                }
            }
        }
        else if (res->resultcode != LDAP_RESULT_SUCCESS)
        {
            mw->instance->sub_state = PUSH_SESSION_IDLE;
        }
        
        switch (mw->instance->sub_state)
        {
            char buffer[MAX_SIZE_SESSION_INFO];
            case PUSH_SESSION_ADD_SLF_SUBDATA:
                    alist = NULL;
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "profile", NULL);
                    LBER_attrlist_add(&alist, "subdata", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "v-slfCommon", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                    sprintf(base_dn, "subdata=profile,ds=slf,subdata=services,%s", mw->instance->resolve_base_dn);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_MSISDN;
                break;
            case PUSH_SESSION_ADD_SLF_MSISDN:
                    alist = NULL;
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, NULL);
                    LBER_attrlist_add(&alist, "msisdn", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfSessionCache", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                    sprintf(base_dn, 
                            "msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", 
                            mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value,
                            mw->instance->resolve_base_dn);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_APPID;
                break;
            case PUSH_SESSION_ADD_SLF_APPID:
                    alist = NULL;
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), NULL);
                    LBER_attrlist_add(&alist, "slfAppId", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfApplContext", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);

                    sprintf(base_dn, 
                            "slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", 
                            ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), 
                            mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 
                            mw->instance->resolve_base_dn);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
                    mw->instance->sub_state = PUSH_SESSION_ADD_SLF_CACHETYPE;
                break;
            case PUSH_SESSION_ADD_SLF_CACHETYPE:
                    // char buffer[MAX_SIZE_SESSION_INFO];
                    sprintf(buffer, "%.*d|%s", DS2C_CONF_TIME_SIZE, (int)time(NULL), mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value);
                    alist = NULL;
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "session", NULL);
                    LBER_attrlist_add(&alist, "slfCacheType", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "slfApplCacheContext", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, buffer, NULL);
                    LBER_attrlist_add(&alist, "slfCacheData", vlist, NULL);

                    sprintf(base_dn, 
                            "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", 
                            ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), 
                            mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, 
                            mw->instance->resolve_base_dn);
                    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
                    mw->instance->sub_state = PUSH_SESSION_END;
                    mw->instance->main_state = PUSH_SESSION_END;
                break;
            default:
                    mw->instance->sub_state = PUSH_SESSION_IDLE;
                    mw->instance->main_state = PUSH_SESSION_IDLE;
                break;
        }

        if (mw->instance->sub_state != PUSH_SESSION_IDLE)
        {
            USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);
            tid = grpc_tid_gen();
            SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
            Pb__Entry *entry = NULL;
            if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)alist, error) != GRPC_RET_OK ){
                return -1;
            }
            if( GRPC_gen_add_request(mw->instance->gid, tid, &h_data, base_dn, entry, 0, error) != GRPC_RET_OK ){
                SDFLOG_ERROR((B, "GRPC_gen_add_request return error [%s]", error))
                return -1;
            }
        }
    }
    else if (mw->instance->main_state == PUSH_SESSION_MODIFY_SESSION)
    {
        sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
        USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);
        tid = grpc_tid_gen();
        SDFLOG_DEBUG((B, "Modify DN :[%s]", base_dn))
        SDFLOG_DEBUG((B, "tid       :[%u]", tid))
        SDFLOG_DEBUG((B, "GID       :[%lu]", mw->instance->gid))

        char buffer[MAX_SIZE_SESSION_INFO];
        sprintf(buffer, "%.*d|%s", DS2C_CONF_TIME_SIZE, (int)time(NULL), mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value);


        vlist = NULL;
        LBER_valuelist_add(&vlist, buffer, NULL);     
        LBER_modlist_add(&mlist, LDAP_MODIFY_ADD, "slfCacheData", vlist, NULL); 

        Pb__Entry *entry = NULL;
        if( GRPC_gen_mod_entry_ldap(&entry, base_dn, "", (MODLIST*)mlist, error ) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_entry_ldap return error [%s]", error))
            return -1;
        }

        if( GRPC_gen_modify_request(mw->instance->gid, tid, &h_data, base_dn, entry, 0, error) != GRPC_RET_OK ){
            SDFLOG_ERROR((B, "GRPC_gen_modify_request return error [%s]", error))
            return -1;
        }
        mw->instance->main_state = PUSH_SESSION_END;
    }
    else if (mw->instance->main_state == PUSH_SESSION_END)
    {
        DS2C_GEN_RESULT_RESPONSE();
        mw->instance->main_state = METHOD_STATE_IDLE;
    }

    GENERIC_PROCESS_METHOD();
    return 3;
}


int af_action_process_pull_sessioninfo(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_pull_sessioninfo";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *ber                = NULL;
    BER *b_attrs            = NULL;
    BER_ATTRLIST *alist     = NULL;
    BER_VALLIST *vlist      = NULL;
    BER_VALLIST *tmp_vlist  = NULL;
    BER_MODLIST *mlist      = NULL;
    char base_dn[1024];
    char filter[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    switch( mw->instance->main_state ){
        case 1:
        {
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                SDFLOG_ERROR((B, "PullSessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PullSessionInfo:002:Cannot read Damocles2", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }else{
                sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                tid = grpc_tid_gen();
                USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
                SDFLOG_DEBUG((B, "Search DN :[%s]", base_dn))
                SDFLOG_DEBUG((B, "tid       :[%u]", tid))
                SDFLOG_DEBUG((B, "GID       :[%lu]", mw->instance->gid))
                i = 0;
                strcpy(attrs[i++], "slfCacheData");
                attrs[1][0] = 0;
                GEN_GRPC_ATTRS(attrs, i);
                
                //sprintf(filter, "(slfCacheData=%s)", mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value);
                if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, "base", "(objectClass=*)", d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                    return -1;
                }
                mw->instance->main_state = 2;
            }
            break;
        }
        case 2:
        {

            if( res->resultcode  == LDAP_RESULT_SUCCESS ){
                /* Find matched value and delete it*/
                vlist = NULL;
                r = entry_get_vallist_by_attribute(res, "slfCacheData", &vlist, 0, NULL);

                if( r == -2 ){
                    SDFLOG_ERROR((B, "PullSessionInfo:002: Cannot read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PullSessionInfo:002:Cannot read Damocles2", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }
                if( vlist == NULL ){
                    SDFLOG_WARN((B, "This sessionInfo[%s] dosen't exist", mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value))
                    SDFLOG_ERROR((B, "PullSessionInfo:003:Cannot read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PullSessionInfo:003:Cannot read Damocles2", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }
                tmp_vlist = vlist;
                while( tmp_vlist ){
                    if( STREQ(tmp_vlist->value+11, mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value) ){ //11 is DS2C_CONF_TIME_SIZE + '|'

                        Pb__Entry *entry = NULL;
                        tid = grpc_tid_gen();
                        sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                        SDFLOG_DEBUG((B, "Modify(delete) DN :[%s]", base_dn))
                        SDFLOG_DEBUG((B, "tid       :[%u]", tid))
                        SDFLOG_DEBUG((B, "GID       :[%lu]", mw->instance->gid))

                        BER_VALLIST *new_list = NULL;
                        LBER_valuelist_add(&new_list, tmp_vlist->value, NULL);
                        LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "slfCacheData", new_list, NULL);
                        GRPC_gen_mod_entry_ldap(&entry, base_dn, "", (MODLIST*)mlist, error);

                        if (GRPC_gen_modify_request(mw->instance->gid, tid, &h_data, base_dn, entry, 1, error)){
                            SDFLOG_ERROR((B, "GRPC_gen_delete_request return error [%s]", error))
                            FREE_BER_VALUELIST(vlist);
                            return -1;
                        }
                        FREE_BER_ATTRLIST(alist);
                        FREE_BER_VALUELIST(vlist);
                        mw->instance->main_state = 3;
                        break;
                    }
                    tmp_vlist = tmp_vlist->next;
                    if(tmp_vlist == vlist){
                        SDFLOG_WARN((B, "This sessionInfo[%s] dosen't exist", mw->instance->index_list[DS2C_FIELD_SESSION_INFO]->vals->value))
                        SDFLOG_ERROR((B, "PullSessionInfo:006:Unknown SessionInfo"))
                        GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PullSessionInfo:006:Unknown SessionInfo", NULL, 0);
                        mw->instance->main_state = METHOD_STATE_IDLE;
                        break;
                    }
                } //while
            }else{  //No such object
                SDFLOG_ERROR((B, "PullSessionInfo:002: Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "PullSessionInfo:002:Cannot read Damocles2", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }//else
            break;
        }
        case 3:
        default:
            DS2C_GEN_RESULT_RESPONSE();
            //TODO: write "DS2A,<TIMESTAMP>,RX,SESSIONINFO, pullSessionInfo,<ldapmessage>,<methodVersion>,<resultInfo>,<result>,<status>
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_modify_sessioninfo(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_modify_sessioninfo";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *b_attrs            = NULL;
    BER_ATTRLIST *alist     = NULL;
    BER_VALLIST *vlist      = NULL;
    BER_VALLIST *tmp_vlist  = NULL;
    BER_MODLIST *mlist      = NULL;
    char base_dn[1024];
    char attrs[MAX_SEARCH_ATTRS][128];
    int i = 0;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    switch( mw->instance->main_state ){
        case 1:
        {
            if( af_action_process_generic_resolve_dn(res, mw, error) != 0 ){
                SDFLOG_ERROR((B, "ModifySessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:002:Cannot read Damocles2", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }else{
                sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
                tid = grpc_tid_gen();
                SDFLOG_DEBUG((B, "Search DN[%s]", base_dn))
                SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                i = 0;
                strcpy(attrs[i++], "slfCacheData");
                attrs[1][0] = 0;
                GEN_GRPC_ATTRS(attrs, i);
                if( GRPC_gen_search_request(mw->instance->gid, tid, &h_data, base_dn, "base", "(objectClass=*)", d02global.global_search_attributes, i, SET_GET_METHOD(mw->instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
                    SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
                    return -1;
                }
                mw->instance->main_state = 2;
            }
            break;
        }
        case 2:
        {

            if( res->resultcode  == LDAP_RESULT_SUCCESS ){
                /* Find matched value and replace it*/
                vlist = NULL;
                r = entry_get_vallist_by_attribute(res, "slfCacheData", &vlist, 0, NULL);

                if( r == -2 ){
                    SDFLOG_ERROR((B, "ModifySessionInfo:002: Cannot read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:002:Cannot read Damocles2", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }

                if( vlist == NULL ){
                    SDFLOG_WARN((B, "No any sessionInfo has been stored"))
                    SDFLOG_ERROR((B, "ModifySessionInfo:003:Cannot Read Damocles2"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:003:Cannot read Damocles2", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }

                BER_VALLIST *old_vals = NULL;
                BER_VALLIST *invalid_vals = NULL;
                tmp_vlist = vlist;
                r = 0;

                while( tmp_vlist ){
                    if( tmp_vlist->len < MAX_SIZE_TIME_FORMAT || tmp_vlist->len > MAX_SIZE_SESSION_INFO || tmp_vlist->value[MAX_SIZE_TIME_FORMAT-1] != '|' ){
                        LBER_valuelist_add(&invalid_vals, tmp_vlist->value, error);
                        SDFLOG_WARN((B, "Remove invalid session : %s", tmp_vlist->value))
                    }else if( STREQ(tmp_vlist->value+11, mw->instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->value) ){ //11 is DS2C_CONF_TIME_SIZE + '|'
                        old_vals = tmp_vlist;
                    }else if( STREQ(tmp_vlist->value+11, mw->instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals->value) ){
                        r = -1;
                    }

                    tmp_vlist = tmp_vlist->next;
                    if(tmp_vlist == vlist){
                        break;
                    }
                } //while

                if ( mw->instance->main_state == METHOD_STATE_IDLE ){
                    break;
                }

                if( old_vals == NULL ){ // Not found old sessionInfo
                    SDFLOG_WARN((B, "This sessionInfo[%s] doesn't exist", mw->instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->value))
                    SDFLOG_ERROR((B, "ModifySessionInfo:004:Unknown SessionInfo"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:004:Unknown SessionInfo", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }

                if ((r == -1) || 
                    STREQ(mw->instance->index_list[DS2C_FIELD_OLD_SESSION_INFO]->vals->value, mw->instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals->value))
                {
                    SDFLOG_ERROR((B, "ModifySessionInfo:005:New SessionInfo Already Exists"))
                    GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:005:New SessionInfo Already Exists", NULL, 0);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    break;
                }

                Pb__Entry *entry = NULL;
                tid = grpc_tid_gen();
                sprintf(base_dn, "slfCacheType=session,slfAppId=%s,msisdn=%s,subdata=profile,ds=slf,subdata=services,%s", ds2c_map_system_type(mw->instance->index_list[DS2C_FIELD_SESSION_TYPE]->vals->value), mw->instance->index_list[DS2C_FIELD_MSISDN_INFO]->vals->value, mw->instance->resolve_base_dn);
                SDFLOG_DEBUG((B, "Modify DN :[%s]", base_dn))
                SDFLOG_DEBUG((B, "tid       :[%u]", tid))
                SDFLOG_DEBUG((B, "GID       :[%lu]", mw->instance->gid))

                if( invalid_vals != NULL ){
                    LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "slfCacheData", invalid_vals, NULL);
                }
                
                //Replace new session info
                char new_session[MAX_SIZE_SESSION_INFO];

                tmp_vlist = NULL;
                LBER_valuelist_add(&tmp_vlist, old_vals->value, error);
                LBER_modlist_add(&mlist, LDAP_MODIFY_DELETE, "slfCacheData", tmp_vlist, NULL);

                tmp_vlist = NULL;
                sprintf(new_session, "%.*d|%s", DS2C_CONF_TIME_SIZE, (int)time(NULL), mw->instance->index_list[DS2C_FIELD_NEW_SESSION_INFO]->vals->value);
                LBER_valuelist_add(&tmp_vlist, new_session, error);
                LBER_modlist_add(&mlist, LDAP_MODIFY_ADD, "slfCacheData", tmp_vlist, NULL);

                GRPC_gen_mod_entry_ldap(&entry, base_dn, "", (MODLIST*)mlist, error);

                if (GRPC_gen_modify_request(mw->instance->gid, tid, &h_data, base_dn, entry, 1, error)){
                    SDFLOG_ERROR((B, "GRPC_gen_delete_request return error [%s]", error))
                    FREE_BER_MODLIST(mlist);
                    return -1;
                }
                FREE_BER_MODLIST(mlist);
                mw->instance->main_state = 3;
                break;
            }else{
                SDFLOG_ERROR((B, "ModifySessionInfo:002:Cannot read Damocles2"))
                GENERIC_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_OPERATION_ERROR, NULL, "ModifySessionInfo:002:Cannot read Damocles2", NULL, 0);
                mw->instance->main_state = METHOD_STATE_IDLE;
            }//else
        }//case
        break;
        default:                
            DS2C_GEN_RESULT_RESPONSE();
            //TODO: write DS2A,<TIMESTAMP>,RX,SESSIONINFO, modifySessionInfo,<ldapmessage>,<methodVersion>,<resultInfo>,<result>,<status>
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_subrelative_add(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_subrelative_add";

    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *b_attrs            = NULL;
    BER_ATTRLIST *alist     = NULL;
    BER_VALLIST *vlist      = NULL;
    // BER_VALLIST *tmp_vlist  = NULL;
    // BER_MODLIST *mlist      = NULL;
    char base_dn[1024];
    // char attrs[MAX_SEARCH_ATTRS][128];
    // int i = 0;
    BER *ber = NULL;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    SDFLOG_DEBUG((B, "State <<<<<< %d >>>>>", mw->instance->main_state))
    SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
    SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
    SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))

    strcpy(base_dn,  mw->instance->default_base_dn);
    SDFLOG_DEBUG((B, "Add DN[%s]", base_dn))
    
    switch( mw->instance->main_state ){
        case SUBREL_SEARCH_BACKEND:
        {
            switch ( res->resultcode )
            {
                case LDAP_RESULT_NO_SUCH_OBJECT:
#ifdef GRPC 
                    SDFLOG_INFO((B, "This DN will be stored on cluster[%s]", mw->instance->cluster_d21))
                    USE_RPC_SERVICE(mw->instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);
                    tid = grpc_tid_gen();
                    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                    
                    BER_ATTRLIST *tattr = mw->lmsg->alt.add_request.comps.attributes;
                    af_process_adaptive_naming_inbound_with_attrlist(&mw->lmsg->alt.add_request.comps.attributes, d02global.global_conf.attributevalue_mapping, d02global.global_conf.invert_adaptive_naming);
                    while( tattr ){
                        SDFLOG_DEBUG((B, "attr[%s]", tattr->name))
                        SDFLOG_DEBUG((B, "attr value[%s]", tattr->vals->value))
                        tattr = tattr->next;
                        
                        if( tattr == mw->lmsg->alt.add_request.comps.attributes){
                            break;
                        }
                    }
                    
                    Pb__Entry *entry = NULL;
                    if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)(mw->lmsg->alt.add_request.comps.attributes), error) != GRPC_RET_OK ){
                        return -1;
                    }
                    if( GRPC_gen_add_request(mw->instance->gid, tid, &h_data, base_dn, entry, 0, error) != GRPC_RET_OK ){
                        SDFLOG_ERROR((B, "GRPC_gen_add_request return error [%s]", error))
                        return -1;
                    }
#else
                    LDAP_gen_ber_attrlist(mw->lmsg->alt.add_request.comps.attributes, &b_attrs, 1, error);
                    LDAP_CREATE_CONTROL();
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, 
                                               &h_data, 
                                               base_dn, 
                                               (b_attrs != NULL) ? b_attrs->berval : NULL, 
                                               (b_attrs != NULL) ? b_attrs->len : 0,
                                               control, 
                                               error);
                    if (tid==0)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
                        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        return -1;
                    }
                    if (b_attrs != NULL) LDAdP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
#endif
                    mw->instance->main_state = SUBREL_PROCESS_BACKEND;
                    break;
                case LDAP_RESULT_SUCCESS:
                    SDFLOG_ERROR((B, "The target DN already exists at D21"));
                    res->resultcode = LDAP_RESULT_ENTRY_ALREADY_EXISTS;
                default:
                    r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", error))
                        return -1;
                    }
                    l_sess_send_response(sess, ber);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_BACKEND:
        {
            switch ( res->resultcode )
            {
                case LDAP_RESULT_SUCCESS:
#ifdef GRPC 
                    USE_RPC_SERVICE(mw->instance, "D20", GRPC_SERVICE_DO, RESTFUL_COMMAND_ADD);
                    tid = grpc_tid_gen();
                    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))
                    
                    vlist = NULL;
                    alist = NULL;
                    BER_ATTRLIST *tattr = mw->lmsg->alt.add_request.comps.attributes;
                    af_process_adaptive_naming_inbound_with_attrlist(&mw->lmsg->alt.add_request.comps.attributes, d02global.global_conf.attributevalue_mapping, d02global.global_conf.invert_adaptive_naming);
                    while( tattr ){
                        SDFLOG_DEBUG((B, "attr[%s]", tattr->name))
                        // SDFLOG_DEBUG((B, "attr value[%s]", tattr->vals->value))
                        if (strcmp(tattr->name, "uid") == 0)
                        {
                            LBER_valuelist_add(&vlist,  tattr->vals->value, NULL);
                            LBER_attrlist_add(&alist, "uid", vlist, NULL);
                        }
                        tattr = tattr->next;
                        
                        if( tattr == mw->lmsg->alt.add_request.comps.attributes){
                            break;
                        }
                    }

                    vlist = NULL;
                    LBER_valuelist_add(&vlist, "extensibleObject", NULL);
                    LBER_valuelist_add(&vlist, "referral", NULL);
                    LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                    
                    vlist = NULL;
                    LBER_valuelist_add(&vlist, mw->instance->cluster_d21, NULL);
                    LBER_attrlist_add(&alist, "ref", vlist, NULL); 
                    
                    Pb__Entry *entry = NULL;
                    if( GRPC_gen_entry_ldap(&entry, base_dn, "", alist, error) != GRPC_RET_OK ){
                        return -1;
                    }
                    if( GRPC_gen_add_request(mw->instance->gid, tid, &h_data, base_dn, entry, 0, error) != GRPC_RET_OK ){
                        SDFLOG_ERROR((B, "GRPC_gen_add_request return error [%s]", error))
                        return -1;
                    }
                    LINKEDLIST_FREE_CHAIN_CHILD(alist,NULL,vals)
#else
                    LDAP_gen_ber_attrlist(mw->lmsg->alt.add_request.comps.attributes, &b_attrs, 1, error);
                    LDAP_CREATE_CONTROL();
                    tid = LDAP_gen_add_request(LDAP_LIST_HANDLE, 
                                               &h_data, 
                                               base_dn, 
                                               (b_attrs != NULL) ? b_attrs->berval : NULL, 
                                               (b_attrs != NULL) ? b_attrs->len : 0,
                                               control, 
                                               error);
                    if (tid==0)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_add_request return error [%s]", error))
                        if (b_attrs != NULL) LDAP_ber_free(b_attrs);
                        if (control != NULL) SDF_FREE(control);
                        return -1;
                    }
                    if (b_attrs != NULL) LDAdP_ber_free(b_attrs);
                    if (control != NULL) SDF_FREE(control);
#endif
                    mw->instance->main_state = SUBREL_PROCESS_ROOT;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    SDFLOG_ERROR((B, "Failed to add the DN at D21"));
                    r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", error))
                        return -1;
                    }
                    l_sess_send_response(sess, ber);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_ROOT:
        {
            if (res->resultcode == LDAP_RESULT_SUCCESS)
            {
                SDFLOG_DEBUG((B, "Add DN subrelative done"))
            }
            else
            {
                SDFLOG_ERROR((B, "Add DN subrelative comlete with errror"))   
            }
            r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", error))
                return -1;
            }
            l_sess_send_response(sess, ber);
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
        }
        default:
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_subrelative_delete(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_subrelative_delete";
#ifdef GRPC
#define DEL_REQ_SETUP(_Dx)                                                                            \
{                                                                                                       \
    USE_RPC_SERVICE(mw->instance, _Dx, GRPC_SERVICE_DO, RESTFUL_COMMAND_DELETE);                      \
    tid = grpc_tid_gen();                                                                               \
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))                                     \
    if( GRPC_gen_delete_request(mw->instance->gid, tid, &h_data, base_dn, 3, error) != GRPC_RET_OK )    \
    {                                                                                                   \
        SDFLOG_ERROR((B, "GRPC_gen_delete_request return error [%s]", error))                           \
        return -1;                                                                                      \
    }                                                                                                   \
}
#endif
    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *b_attrs            = NULL;
    char base_dn[1024];
    BER *ber = NULL;

    sess = (DSSESSION*)mw->ref;
    
    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    
    SDFLOG_DEBUG((B, "State <<<<<< %d >>>>>", mw->instance->main_state))
    SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
    SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
    SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))

    strcpy(base_dn,  mw->instance->default_base_dn);
    SDFLOG_DEBUG((B, "BaseDN[%s]", base_dn))
    
    switch( mw->instance->main_state ){
        case SUBREL_SEARCH_BACKEND:
        {
            switch ( res->resultcode )
            {
                case LDAP_RESULT_SUCCESS:
#ifdef GRPC
                    DEL_REQ_SETUP("D20")
#else
                    LDAP_CREATE_CONTROL();
                    LDAP_GEN_DELETE_REQUEST();
                    if (tid==0)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
                        return -1;
                    }
#endif
                    mw->instance->main_state = SUBREL_PROCESS_ROOT;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    SDFLOG_ERROR((B, "Error during search RDN at D21"));
                    r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                        return -1;
                    }
                    l_sess_send_response(sess, ber);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_ROOT:
        {
            switch ( res->resultcode )
            {
                case LDAP_RESULT_SUCCESS:
#ifdef GRPC
                    DEL_REQ_SETUP("D21")
#else
                    LDAP_CREATE_CONTROL();
                    LDAP_GEN_DELETE_REQUEST();
                    if (tid==0)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_delete_request return error [%s]", error))
                        return -1;
                    }
#endif
                    mw->instance->main_state = SUBREL_PROCESS_BACKEND;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    SDFLOG_ERROR((B, "Cannot find RDN at D21"));
                    r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                        return -1;
                    }
                    l_sess_send_response(sess, ber);
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_BACKEND:
        {
            if (res->resultcode == LDAP_RESULT_SUCCESS)
            {
                SDFLOG_DEBUG((B, "Delete DN subrelative done"))
            }
            else
            {
                SDFLOG_ERROR((B, "Delete DN subrelative comlete wiht errror"))   
            }
            r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                return -1;
            }
            l_sess_send_response(sess, ber);
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
        }
        default:
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}

int af_action_process_subrelative_modify_dn(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_action_process_subrelative_modify_dn";
#ifdef GRPC
#define MODDN_REQ_SETUP(_Dx)                                                                                     \
{                                                                                                                \
    USE_RPC_SERVICE(mw->instance, _Dx, GRPC_SERVICE_DO, RESTFUL_COMMAND_MODIFY);                                 \
    tid = grpc_tid_gen();                                                                                        \
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", tid, mw->instance->gid))                                              \
    Pb__Entry *entry = NULL;                                                                                     \
    if( GRPC_gen_entry_ldap(&entry, base_dn, "", (ATTRLIST*)alist, error) != GRPC_RET_OK ){                      \
        SDFLOG_ERROR((B, "GRPC_gen_entry_ldap return error [%s]", error))                                        \
        return -1;                                                                                               \
    }                                                                                                            \
    entry->has_moddn = 1;                                                                                        \
    entry->moddn = 1;                                                                                            \
    if( GRPC_gen_modify_request(mw->instance->gid, tid, &h_data, base_dn, entry, 2, error) != GRPC_RET_OK ){     \
        SDFLOG_ERROR((B, "GRPC_gen_modify_request return error [%s]", error))                                    \
        return -1;                                                                                               \
    }                                                                                                            \
}
#endif
    /* Declear local variable */
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    BER *b_attrs            = NULL;
    BER_ATTRLIST *alist     = NULL;
    BER_VALLIST *vlist      = NULL;
    BER_MODLIST *mlist      = NULL;
    char base_dn[1024];
    BER *ber = NULL;

    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }
    sess = (DSSESSION*)mw->ref;

    SDFLOG_DEBUG((B, "State <<<<<< %d >>>>>", mw->instance->main_state))
    SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
    SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
    SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))

    strcpy(base_dn,  mw->instance->default_base_dn);
    SDFLOG_DEBUG((B, "BaseDN[%s]", base_dn))
    
    switch( mw->instance->main_state ){
        case SUBREL_SEARCH_BACKEND:
        {
            switch ( res->resultcode ){
                case LDAP_RESULT_REFERRAL:
                case LDAP_RESULT_SUCCESS:
#ifdef GRPC
                    vlist = NULL;
                    alist = NULL;
                    LBER_valuelist_add(&vlist, mw->lmsg->alt.mod_dn_request.comps.new_rdn, NULL);
                    LBER_attrlist_add(&alist, "newrdn", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist,
                                       (mw->lmsg->alt.mod_dn_request.comps.delete_old_rdn == 0)?"false":"true",
                                       NULL);
                    // {
                    //     LBER_valuelist_add(&vlist, "false", NULL);
                    // }
                    // else
                    // {
                    //     LBER_valuelist_add(&vlist, "true", NULL);   
                    // }
                    LBER_attrlist_add(&alist, "deleteoldrdn", vlist, NULL);

                    MODDN_REQ_SETUP("D21")
#else
                    // LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    // tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, (BER**)req, base_dn, b_attrs->berval, b_attrs->len, LDAP_CTRL_ENABLE, error);
                    // if (tid==0)
                    // {
                    //     SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
                    //     if (b_attrs != NULL) LDAP_ber_free(b_attrs);
                    //     return -1;
                    // }
                    // if (b_attrs != NULL) LDAP_ber_free(b_attrs);
#endif
                    mw->instance->main_state = SUBREL_PROCESS_BACKEND;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    SDFLOG_ERROR((B, "Cannot find RDN at D21"));
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_BACKEND:
        {
            switch ( res->resultcode ){
                case LDAP_RESULT_SUCCESS:
#ifdef GRPC
                    vlist = NULL;
                    alist = NULL;
                    LBER_valuelist_add(&vlist, mw->lmsg->alt.mod_dn_request.comps.new_rdn, NULL);
                    LBER_attrlist_add(&alist, "newrdn", vlist, NULL);
                    vlist = NULL;
                    LBER_valuelist_add(&vlist,
                                       (mw->lmsg->alt.mod_dn_request.comps.delete_old_rdn == 0)?"false":"true",
                                       NULL);
                    LBER_attrlist_add(&alist, "deleteoldrdn", vlist, NULL);

                    MODDN_REQ_SETUP("D20")
#else
                    // LDAP_gen_ber_modlist(mlist, &b_attrs, 1, error);
                    // *tid = LDAP_gen_modify_request(LDAP_LIST_HANDLE, (BER**)req, base_dn, b_attrs->berval, b_attrs->len, LDAP_CTRL_ENABLE, error);
                    // if (*tid==0)
                    // {
                    //     SDFLOG_ERROR((B, "LDAP_gen_modify_request return error [%s]", error))
                    //     if (b_attrs != NULL) LDAP_ber_free(b_attrs);
                    //     return -1;
                    // }
                    // if (b_attrs != NULL) LDAP_ber_free(b_attrs);
#endif
                    mw->instance->main_state = SUBREL_PROCESS_ROOT;
                    break;
                case LDAP_RESULT_NO_SUCH_OBJECT:
                default:
                    mw->instance->main_state = METHOD_STATE_IDLE;
                    SDFLOG_ERROR((B, "Cannot modify DN at D21"));
                    return -1;
                    break;
            } //res->resultcode
            break;
        }
        case SUBREL_PROCESS_ROOT:
            if (res->resultcode == LDAP_RESULT_SUCCESS)
            {
                SDFLOG_DEBUG((B, "Modify DN subrelative done"))
            }
            else
            {
                SDFLOG_ERROR((B, "Modify DN subrelative complete with error"))   
            }
            r = LDAP_gen_moddn_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, error);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                return -1;
            }
            l_sess_send_response(sess, ber);
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
        default:                
            mw->instance->main_state = METHOD_STATE_IDLE;
            break;
    }
    GENERIC_PROCESS_METHOD();
    return 3;
}


int af_init_action_extended(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_extended";
    
    char base_dn[LDAP_MAX_BASE_DN];
    char *nattr         = NULL;
    char *vattr         = NULL;
    BER_VALLIST *vlist  = NULL;
    BER_MODLIST *mlist  = NULL;
    BER_ATTRLIST *alist = NULL;
    BER *b_attrs        = NULL;
    BER *ber            = NULL;
    int r               = 0;
    
/*#define INQUIRY_SUBSCRIBER  "0.0.17.1218.8.7.0"
#define INQUIRY_PCF_VAS     "0.0.17.1218.8.7.19"
#define PUSH_SESSION        "0.0.17.1218.8.7.20"
#define PULL_SESSION        "0.0.17.1218.8.7.21"
#define MODIFY_SESSION      "0.0.17.1218.8.7.22"
#define INQUIRY_SESSION     "0.0.17.1218.8.7.23"*/
    
    //DS2C_FACK_DATA();
    
    SDFLOG_DEBUG((B, "oid   : [%s]", lmsg->alt.extended_request.comps.request_name))
    //HEXDUMP(lmsg->alt.extended_request.comps.request_value->berval, lmsg->alt.extended_request.comps.request_value->len);
    
    if( lmsg->alt.extended_request.comps.request_value != NULL){
        if(ber_to_attrs(lmsg->alt.extended_request.comps.request_value, &alist, error) != 0 ){
            SDFLOG_ERROR((B, "ber_to_attrs return error[%s]", error))
            return -1;
        }
    }

    BER_ATTRLIST *t_alist = alist;
    BER_VALLIST *t_vlist  = NULL;
    int vcount;
    while( t_alist != NULL ) {
        SDFLOG_DEBUG((B, "Attrs : [%s]", t_alist->name))

        vcount = 0;
        t_vlist = t_alist->vals;
        while( t_vlist != NULL ) 
        {
            SDFLOG_DEBUG((B, "Value : [%s]", t_vlist->value))
            t_vlist = t_vlist->next;
            vcount++;
            if( t_vlist == t_alist->vals)
            {
                break;
            }
        }

        if( STRCASEEQ(t_alist->name, "methodVersion") ){
            if ((instance->index_list[DS2C_FIELD_METHOD_VERSION] != NULL) ||
                (instance->index_list[DS2A_FIELD_METHOD_VERSION] != NULL) ||
                (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_METHOD_VERSION] = t_alist;
            instance->index_list[DS2A_FIELD_METHOD_VERSION] = t_alist;
        }else if( IS_PARAM_VALID("msisdnInfo") ){
            if ((instance->index_list[DS2C_FIELD_MSISDN_INFO] != NULL) ||
                (instance->index_list[DS2A_FIELD_MSISDN_INFO] != NULL) ||
                (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_MSISDN_INFO] = t_alist;
            instance->index_list[DS2A_FIELD_MSISDN_INFO] = t_alist;
        }else if( IS_PARAM_VALID("sessionType") ){
            if ((instance->index_list[DS2C_FIELD_SESSION_TYPE] != NULL) || (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_SESSION_TYPE] = t_alist;
        }else if( IS_PARAM_VALID("OldSessionInfo") ){
            if ((instance->index_list[DS2C_FIELD_OLD_SESSION_INFO] != NULL) || (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_OLD_SESSION_INFO] = t_alist;
        }else if( IS_PARAM_VALID("NewSessionInfo") ){
            if ((instance->index_list[DS2C_FIELD_NEW_SESSION_INFO] != NULL) || (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_NEW_SESSION_INFO] = t_alist;
        }else if( IS_PARAM_VALID("sessionInfo") ){
            if ((instance->index_list[DS2C_FIELD_SESSION_INFO] != NULL) || (vcount > 1))
            {
                SDFLOG_ERROR((B, "ExtendedRequest:001:Badly formatted ExtendedRequest"))
                GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "ExtendedRequest:001:Badly formatted ExtendedRequest", NULL, 0);
                return -2;
            }
            instance->index_list[DS2C_FIELD_SESSION_INFO] = t_alist;
        }

        t_alist = t_alist->next;
        if( t_alist == alist){
            break;
        }
    }

    instance->alist = alist;
    strcpy(instance->oid, lmsg->alt.extended_request.comps.request_name);
    /*
    if( alist == NULL ){
        SDFLOG_WARN((B, "no any input data"))
        DS2C_FACK_DATA();
    }*/
    
#ifdef GRPC
    if( STREQ(INQUIRY_SUBSCRIBER, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call inquiry subscriber"))
        if( (r = af_init_action_inquiry_subscriber(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_inquiry_subscriber return error[%s]", error))
            return r;
        }
    }else if ( STREQ(INQUIRY_PCF_VAS, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call inquiry PCF_VAS"))
        if( (r = af_init_action_inquiry_pcf_vas(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_inquiry_pcf_vas return error[%s]", error))
            return r;
        }
    }else if ( STREQ(PUSH_SESSION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call push sessioninfo"))
        if( (r = af_init_action_push_sessioninfo(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_push_sessioninfo return error[%s]", error))
            return r;
        }
    }else if ( STREQ(PULL_SESSION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call pull sessioninfo"))
        if( (r = af_init_action_pull_sessioninfo(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_pull_sessioninfo return error[%s]", error))
            return r;
        }
    }else if ( STREQ(MODIFY_SESSION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call modify sessioninfo"))
        if( (r = af_init_action_modify_sessioninfo(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_modify_sessioninfo return error[%s]", error))
            return r;
        }
    }else if ( STREQ(INQUIRY_SESSION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call inquriy sessioninfo"))
        if( (r = af_init_action_inquiry_sessioninfo(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_inquiry_sessioninfo return error[%s]", error))
            return r;
        }
    }else if( STREQ(LDAP_EXTENDED_START_TRANSACTION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call start transaction"))
        if( (r = af_init_action_extended_start_transaction(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_extended_start_transaction return error[%s]", error))
            return r;
        }
    }else if( STREQ(LDAP_EXTENDED_END_TRANSACTION, lmsg->alt.extended_request.comps.request_name) ){
        SDFLOG_DEBUG((B, "call end transaction"))
        if( (r = af_init_action_extended_end_transaction(sess, lmsg, tid, req, instance, error)) != 0 ){
            SDFLOG_ERROR((B, "af_init_action_extended_end_transaction return error[%s]", error))
            return r;
        }
    }else{
        SDFLOG_ERROR((B, "Unknown:001:Invalid oid [%s]", lmsg->alt.extended_request.comps.request_name))
        GENERIC_INIT_LDAP_EXTENDED_DEFAULT_RESPONE(LDAP_RESULT_PROTOCOL_ERROR, NULL, "Unknown:001:Invalid oid", NULL, 0);
        return -2;
    }

#else
    return -1;
#endif

   return 0;
}

int af_init_action_resolve(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_resolve";
    char base_dn[LDAP_MAX_BASE_DN];
    char base_dn_srch[LDAP_MAX_BASE_DN];
    char *p_base_dn = NULL;
    base_dn[0]  = 0;
    int subrel_poss_flag = 0;
    int alias_dn_flag = 0;
    //GET_INDENTITY
    //..ds=gup,uid=66000000000001,ds=subscriber,o=ais,c=ntdb
    //        ^
    //expect: uid=66000000000001,ds=subscriber,o=ais,c=ntdb
    //
    //..ds=gup,msisdn=66000000000001,dc=msisdn,c=ntdb
    //        ^
    //expect: msisdn=66000000000001,dc=msisdn,c=ntdb

    //Find DN from request
    switch(lmsg->choice){
        case LDAP_PROTOCOL_SEARCH_REQUEST:
            strcpy(base_dn, lmsg->alt.search_request.comps.base_object);
            break;
        case LDAP_PROTOCOL_ADD_REQUEST:
            strcpy(base_dn, lmsg->alt.add_request.comps.entry);
            subrel_poss_flag = 1;
            break;
        case LDAP_PROTOCOL_MODIFY_REQUEST:
            strcpy(base_dn, lmsg->alt.modify_request.comps.object);
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
            strcpy(base_dn, lmsg->alt.mod_dn_request.comps.entry);
            subrel_poss_flag = 1;
            break;    
        case LDAP_PROTOCOL_DELETE_REQUEST:
            strcpy(base_dn, lmsg->alt.delete_request.ldap_dn);
            subrel_poss_flag = 1;
            break;
        case LDAP_PROTOCOL_EXTENDED_REQUEST:
            return 1;
        default :
            SDFLOG_ERROR((B, "Invalid message choice[%d]", lmsg->choice))
            return -1;
    }
    SDFLOG_DEBUG((B, "Original Dn : %s", base_dn))
    GET_IDENTITY(instance->default_base_dn);
    SDFLOG_DEBUG((B, "Resolve Dn  : %s", p_base_dn))

    if( instance != NULL && p_base_dn != &base_dn[0] ){

        strcpy(instance->dn, base_dn);
        SDFLOG_DEBUG((B, "keep dn[%s]", instance->dn))
    }

    int r;
    r = af_common_check_rdn(p_base_dn);
    // if((r == 2) && (lmsg->choice == LDAP_PROTOCOL_ADD_REQUEST))
    if ((alias_dn_flag ==  1) && (lmsg->choice == LDAP_PROTOCOL_ADD_REQUEST))
    {
        // char *p;
        // p = strchr(p_base_dn, ',');
        // strcpy(base_dn_srch, p+1);
        BER_ATTRLIST *alist;
        BER_ATTRLIST *alist_tmp;
        alist_tmp = alist = lmsg->alt.add_request.comps.attributes;
        while(alist_tmp)
        {
            if(STRCASEEQ(alist_tmp->name,"aliasedObjectName"))
            {
                strcpy(base_dn_srch,alist_tmp->vals->value);
                break;
            }
            alist_tmp = alist_tmp->next;
            if(alist_tmp == alist)
            {
                break;
            }
        }
    }
    else
    {
        strcpy(base_dn_srch, p_base_dn);
    }

    SDFLOG_DEBUG((B, "base_dn search: %s", base_dn_srch))
    USE_RPC_SERVICE(instance, "D20", GRPC_RESOLVE_ALIASE, RESTFUL_COMMAND_SEARCH);
    *tid = grpc_tid_gen();
    instance->gid = d02global.gid_prefix + (*tid);
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
    SDFLOG_DEBUG((B, "base_dn search: %s", base_dn_srch))
    struct timeval elap_tm;
    init_watch(TMR2, error);
    if( GRPC_gen_search_request(instance->gid, *tid, (HTTP2_BUFFER**)req, base_dn_srch, "base", "(objectClass=*)", NULL, 0, SET_GET_METHOD(instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
        //METHOD_GEN_HTTP_ERROR(sess, 500, 50001, "DB error");
        return -1;
    }
    stop_watch(TMR2, &elap_tm, error);
    SDFLOG_INFO((B, "-----> GRPC_gen_search_request ::  :%lu us", elap_tm.tv_sec*1000000+elap_tm.tv_usec))
    instance->main_state = 1;
    instance->state = AFSTATE_METHOD;
    if ((af_common_check_rdn(base_dn) == 1) && (subrel_poss_flag == 1))
    {
        SDFLOG_DEBUG((B, "This request is subrelative dn"))
        instance->method = METHOD_RESOLVE_ALIASE_SUBREL;
        instance->main_state = SUBREL_SEARCH_ROOT;
        strcpy(instance->default_base_dn, base_dn);
    }
    else
    {
        instance->method = METHOD_RESOLVE_ALIASE;
    }
    
    return 0;
}

int af_init_action_resolve_subrel(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE *instance, char *error){
    static char func[] = "af_init_action_resolve_subrel";
    char base_dn[LDAP_MAX_BASE_DN];

    SDFLOG_DEBUG((B, "Search Dn : %s", instance->default_base_dn))

    USE_RPC_SERVICE(instance, "D21", GRPC_SERVICE_DO, RESTFUL_COMMAND_SEARCH);
    *tid = grpc_tid_gen();
    SDFLOG_DEBUG((B, "tid[%u]   GID[%lu]", *tid, instance->gid))
    if( GRPC_gen_search_request(instance->gid, *tid, (HTTP2_BUFFER**)req, instance->default_base_dn, "base", "(objectClass=*)", NULL, 0, SET_GET_METHOD(instance, 1), LDAP_DEREF_ALWAYS, error) != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_gen_search_request return error [%s]", error))
        return -1;
    }

    instance->state = AFSTATE_SUBREL;
    instance->main_state = SUBREL_SEARCH_BACKEND;
    return 0;
}

int af_init_action_v2(DSSESSION *sess, LDAPMessage_t *lmsg, unsigned int *tid, void **req, AFINSTANCE **instance){
    static char func[] = "af_init_action_v2";
    char err[MY_ERR_BUFFER_SIZE];
    int r   = 0;
    err[0]  = '\0';
    struct timeval overall_time, stoptime;
    unsigned long process_time = 0;
    if( *instance == NULL){
        *instance = (AFINSTANCE *) SDF_MALLOC (sizeof(**instance));
        (*instance)->state              = AFSTATE_IDLE;
        (*instance)->resolve_base_dn[0] = 0;
        (*instance)->default_base_dn[0] = 0;
        (*instance)->cluster_d21[0]     = 0;
        (*instance)->dn[0]              = 0;
        (*instance)->migration_mode     = DS4_MODE;
        gettimeofday(&((*instance)->timestamp), 0);

    }
    
    SDFLOG_DEBUG((B,"default_base_dn p[%p]", (*instance)->default_base_dn))
    if((*instance)->default_base_dn != NULL)
    {
        SDFLOG_DEBUG((B,"default_base_dn =[%s]", (*instance)->default_base_dn))
    }

    if((*instance)->resolve_base_dn != NULL)
    {
        SDFLOG_DEBUG((B,"resolve_base_dn =[%s]", (*instance)->resolve_base_dn))
    }

    if((*instance)->cluster_d21 != NULL)
    {
        SDFLOG_DEBUG((B,"cluster_d21 =[%s]", (*instance)->cluster_d21))
    }

    if((((*instance)->resolve_base_dn[0] == 0) || ((*instance)->cluster_d21[0] == 0 ))
        && (af_common_check_rdn((*instance)->default_base_dn) < 2))
    {
            WATCH_WITH_START(((*instance)->timestamp), "-----> af_common_check_rdn :: ")
            SET_WATCH((*instance)->timestamp)

            r = af_init_action_resolve(sess, lmsg, tid, req, *instance, err);
            WATCH_WITH_START(((*instance)->timestamp), "-----> af_init_action_resolve :: ")
            SET_WATCH((*instance)->timestamp)
            if( r == 0 ){
                return 0;
            }else if( r < 0 ){
                SDFLOG_ERROR((B, "af_init_action_resolve return error"))
                // return -1;
                return r;
            }
    }

    WATCH_WITH_START(((*instance)->timestamp), "-----> af_init_action_resolve :: ")

    switch(lmsg->choice){
        case LDAP_PROTOCOL_SEARCH_REQUEST:
            SDFLOG_DEBUG((B, "Received SEARCH Request"))
            (*instance)->state = AFSTATE_GET_QUERY;
            SET_WATCH((*instance)->timestamp)
            r = af_init_action_search(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_search return error"))
                return -1;
            }
            WATCH_WITH_START(((*instance)->timestamp), "-----> af_init_action_search :: ")
            SET_WATCH((*instance)->timestamp)
            break;
        case LDAP_PROTOCOL_ADD_REQUEST:
            SDFLOG_DEBUG((B, "Received ADD Request"))
            (*instance)->state = AFSTATE_POST;
            r = af_init_action_add(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_add return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFY_REQUEST:
            SDFLOG_DEBUG((B, "Received MODIFY Request"))
            (*instance)->state = AFSTATE_PUT;
            r = af_init_action_modify(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_modify return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
            SDFLOG_DEBUG((B, "Received MODIFY DN Request"))
            (*instance)->state = AFSTATE_MODDN;
            SDFLOG_DEBUG((B, "Entry             : [%s]", lmsg->alt.mod_dn_request.comps.entry))
            SDFLOG_DEBUG((B, "newrdn            : [%s]", lmsg->alt.mod_dn_request.comps.new_rdn))
            // SDFLOG_DEBUG((B, "delete old rdn    : [%d]", lmsg->alt.mod_dn_request.comps.delete_old_rdn))
            r = af_init_action_modify_dn(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_modify return error"))
                return -1;
            }
            break;    
        case LDAP_PROTOCOL_DELETE_REQUEST:
            SDFLOG_DEBUG((B, "Received DELETE Request"))
            (*instance)->state = AFSTATE_DELETE;
            r = af_init_action_delete(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_delete return error"))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_EXTENDED_REQUEST:
            SDFLOG_DEBUG((B, "Received EXTENDED Request"))
            (*instance)->state = AFSTATE_EXTENDED;
            r = af_init_action_extended(sess, lmsg, tid, req, *instance, err);
            if( r != 0 ){
                SDFLOG_ERROR((B, "af_init_action_extended return error"))
                return r;
            }
            break;
        default:
            SDFLOG_DEBUG((B, "Received Unknown Request"))
            break;
    }
    
    return 0;
}

int af_process_resolve_alias(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_process_resolve_alias";

    /* Declear local variable */
    int main_state          = 0;
    int sub_state           = 0;
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    char *p,*pp;
    char base_dn[1024];
    int dn_type             = 0;
    int alias_found         = 0;
    int ext_found           = 0;
    BER_ATTRLIST *alist_DS4 = NULL;
    BER_VALLIST  *vlist_DS4 = NULL;
    
    sess = (DSSESSION*)mw->ref;

    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }

    SDFLOG_DEBUG((B, "mw->instance->migration_mode        : [%d] ",mw->instance->migration_mode))

    r = af_action_process_generic_resolve_dn(res, mw, error);

    if((mw->lmsg->choice == LDAP_PROTOCOL_ADD_REQUEST)  && (d02global.conf_warm.migration_mode == MIG_MODE))
    {
        SDFLOG_DEBUG((B, "Checkign DN type [%s] ", mw->lmsg->alt.add_request.comps.entry))
        dn_type = af_common_check_rdn(mw->lmsg->alt.add_request.comps.entry);
        SDFLOG_DEBUG((B, "dn_type : [%d] ",dn_type))
        if(dn_type == 2)
        {
            BER_ATTRLIST *alist;
            BER_ATTRLIST *alist_tmp;
            BER_VALLIST *vlist;
            BER_VALLIST *vlist_tmp;
            
            alist_DS4 = NULL;
            vlist_DS4 = NULL;
            alist_tmp = alist = mw->lmsg->alt.add_request.comps.attributes;
            while(alist_tmp)
            {
                SDFLOG_DEBUG((B, "alist_tmp->name        : [%s] ",alist_tmp->name))
                if(strcasecmp(alist_tmp->name,"masteredBy"))
                {
                    vlist_tmp = vlist = alist_tmp->vals;
                    vlist_DS4 = NULL;
                    while(vlist_tmp)
                    {
                        SDFLOG_DEBUG((B, "vlist_tmp->value        : [%s] ",vlist_tmp->value))
                        if(STRCASEEQ(vlist_tmp->value, "extensibleObject"))
                        {
                            ext_found = 1;
                        }
                        else if(STRCASEEQ(vlist_tmp->value, "alias"))
                        {
                            alias_found = 1;
                        }
                        LBER_valuelist_add(&vlist_DS4, vlist_tmp->value, NULL);
                        vlist_tmp = vlist_tmp->next;
                        if(vlist_tmp == vlist)
                        {
                            break;
                        }
                    }

                    if(STRCASEEQ(alist_tmp->name,"objectClass"))
                    {
                        SDFLOG_DEBUG((B, "ext_found : [%d] ",ext_found))
                        SDFLOG_DEBUG((B, "alias_found : [%d] ",alias_found))
                        if(ext_found == 0)
                        {
                            LBER_valuelist_add(&vlist_DS4, "extensibleObject", NULL);
                        }
                        if (alias_found == 0)
                        {
                            LBER_valuelist_add(&vlist_DS4, "alias", NULL);
                        }
                    }
                    LBER_attrlist_add(&alist_DS4, alist_tmp->name, vlist_DS4, NULL);
                }
                alist_tmp = alist_tmp->next;
                if(alist_tmp == alist)
                {
                    break;
                }
            }

            if((r == 0) || ((ext_found == 1)&&(alias_found == 1)) || (d02global.conf_warm.default_ident_add_target == DS4_MODE))
            {
                mw->lmsg->alt.add_request.comps.attributes = alist_DS4;
                mw->instance->migration_mode = DS4_MODE;
                r = 0;
            }
            else
            {
                mw->instance->migration_mode = DS3_MODE;
            }
        }
    }

    if( r == 0 )
    {
        mw->instance->migration_mode = DS4_MODE;
        r = af_init_action_v2(sess, mw->lmsg, &tid, (void**)&h_data, &(mw->instance));  
        SDFLOG_DEBUG((B, "af_init_action_v2 return  : [%d]", r))
        SDFLOG_DEBUG((B, "mw->intance->state        : [%d] ",mw->instance->state))
        SDFLOG_DEBUG((B, "Use MID                   : [%u]", tid))
        if( r < 0){
            // main_state = METHOD_STATE_IDLE;
            return METHOD_STATE_IDLE;
        }else{
            main_state = mw->instance->main_state;
        }


        if (h_data != NULL && http2_send_msg_to_queue(mw->instance, h_data) != 0 )
        {
            SDFLOG_ERROR((B, "Cannot send HTTP2 request."));
            return METHOD_STATE_IDLE;
        }
        struct timeval overall_time, stoptime;
        unsigned long process_time = 0;
        WATCH_WITH_START(mw->instance->timestamp, "-----> send queue :: ")
        SET_WATCH(mw->instance->timestamp)
    }
    else if(mw->instance->migration_mode == DS3_MODE)
    {
        SDFLOG_DEBUG((B, "Calling af_init_action"))
        mw->instance->migration_mode = DS3_MODE;
        main_state = mw->instance->main_state;
        r = af_init_action(sess, mw->lmsg, &tid, (void**)&h_data, &mw->instance);
        if(mw->instance->tim == NULL)
        {
            r = l_clnt_send_msg((BER*)h_data);
        }
        else
        {
            r = l_clnt_send_msg_lc((BER*)h_data, mw->instance->tim->lc);
        }
    }
    else
    {
        GENERIC_LDAP_SEARCH_DEFAULT_RESPONE(res->resultcode, res->matcheddn, res->resultdescription);
        main_state = METHOD_STATE_IDLE;
        return main_state;
    }

    
    /* Clear instance */
    if(main_state == METHOD_STATE_IDLE){
        return main_state;
    }

    /* Update Instance */
    //mw->instance->main_state = main_state;
    //mw->instance->sub_state = sub_state;

    /* Create new edb */
    SDFLOG_DEBUG((B, "Create new edb"))
    MWRAPPER *nmw = NULL;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        strcpy(error, "Can not allocate memory");
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        return METHOD_STATE_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;
    nmw->lmsg = mw->lmsg;
    nmw->tid = mw->tid;
    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);

    return 0;
}

int af_process_resolve_alias_subrel(Pb__Response *res, MWRAPPER *mw, char *error){
    static char func[] = "af_process_resolve_alias_subrel";
    /* Declear local variable */
    int main_state          = 0;
    int sub_state           = 0;
    int tid                 = 0;
    int r                   = 0;
    HTTP2_BUFFER *h_data    = NULL;
    DSSESSION *sess         = NULL;
    char *p,*pp;
    char base_dn[1024];
    char resp_msg[1024];
    BER *ber = NULL;
    
    sess = (DSSESSION*)mw->ref;

    /* Verify instance */
    if( mw == NULL || mw->instance == NULL ){
        return -1;
    }

    SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
    SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
    SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))

    strcpy(resp_msg, res->resultdescription);

    switch ( res->resultcode ){
        case LDAP_RESULT_REFERRAL:
        case LDAP_RESULT_SUCCESS:
                       
            if( res->n_referrals > 0 ){
                SDFLOG_DEBUG((B, "Referrals  : [%s]", res->referrals[0]))
                strcpy(mw->instance->cluster_d21, res->referrals[0]);
                strcpy(mw->instance->resolve_base_dn, res->matcheddn);
                r = 0;
            }else{
                SDFLOG_ERROR((B, "Cannot get Referrals [return LDAP_RESULT_NO_SUCH_OBJECT]"))
                res->resultcode = LDAP_RESULT_NO_SUCH_OBJECT;
                r = -1;
            }
            SDFLOG_DEBUG((B, "Resolve DN : [%s]", mw->instance->resolve_base_dn))
            break;
        case LDAP_RESULT_NO_SUCH_OBJECT:
        default:
            SDFLOG_ERROR((B, "Cannot resolve identity"));
            r = -2;
            break;
    }

    main_state = mw->instance->main_state;
    mw->instance->state = AFSTATE_SUBREL;
    switch(mw->lmsg->choice)
    {
        case LDAP_PROTOCOL_ADD_REQUEST:
            if (r ==  -2)
            {
                char cluster[512];
                SDFLOG_DEBUG((B, "Received ADD Request"))
                mw->instance->method = METHOD_SUBREL_ADD;
                if (mw->lmsg->controls != NULL)
                {
                    if ((mw->lmsg->controls->flags[CONTROLTYPE] == 1) && (mw->lmsg->controls->flags[CONTROLVALUE] == 1))
                    {
                        SDFLOG_DEBUG((B, "Control Type [%s]", mw->lmsg->controls->comps.control_type))
                        SDFLOG_DEBUG((B, "Control Value [%s]", mw->lmsg->controls->comps.control_value.value))

                        if (strcmp (mw->lmsg->controls->comps.control_type, LDAP_CONTROL_MATCHING_IDENTITY) == 0)
                        {
                            unsigned int control_id;
                            char matchrule[16];
                            char *p;
                            char *pp;

                            p = mw->lmsg->controls->comps.control_value.value;
                            control_id = strtoul(p, &pp, 10);
                            SDFLOG_DEBUG((B, "ID Type [%p]", control_id))
                            SDFLOG_DEBUG((B, "p [%p]", p))
                            SDFLOG_DEBUG((B, "pp [%p]", pp))
                            SDFLOG_DEBUG((B, "pp [%s]", pp))
                            if((p != pp) && (pp[0] == '|'))
                            {
                                pp++;
                                SDFLOG_DEBUG((B, "ID Value [%s]", pp))
                                switch (control_id)
                                {
                                    case MATCHING_IDENT_MSISDN:    strcpy(matchrule, "msisdn"); break;
                                    case MATCHING_IDENT_IMSI:      strcpy(matchrule, "imsi"); break;
                                    case MATCHING_IDENT_PRIVATE:   strcpy(matchrule, "private"); break;
                                    default: 
                                        r = -3; break;
                                }
                                if (r == -3)
                                {
                                    SDFLOG_ERROR((B, "Invalid LDAP control ID Type"))
                                    strcpy(resp_msg, "Invalid LDAP control ID Type");
                                }
                                else
                                {
                                    if( config_get_matching_rule(matchrule, pp, cluster, 
                                                        d02global.conf_warm.matching_rule, 
                                                        d02global.conf_warm.matching_rule_count) == 0 )    
                                    {
                                        strcpy(mw->instance->cluster_d21 , cluster);
                                        SDFLOG_INFO((B, "Search DN at D21 on cluster[%s]", mw->instance->cluster_d21))
                                        r = 0;
                                    }
                                }
                            }
                        }
                    }
                    if(r == -1)
                    {
                        SDFLOG_ERROR((B, "%s", "Invalid LDAP control input"))
                        strcpy(resp_msg, "Invalid LDAP control input");
                        // SDFLOG_ERROR((B, "%s", res->resultdescription))
                    }
                    else if(r == -2)
                    {
                        SDFLOG_ERROR((B, "%s", "No cluster matches with the specified identity"))
                        strcpy(resp_msg, "No cluster matches with the specified identity");   
                        // SDFLOG_ERROR((B, "%s", res->resultdescription))
                    }
                }
                else
                {
                    SDFLOG_ERROR((B, "LDAP control must not be empty"))
                    strcpy(resp_msg, "LDAP control must not be empty");
                }
                if (r!=0)
                {
                    SDFLOG_DEBUG((B, "Sending Add response with error [%s]", resp_msg))
                    r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, LDAP_RESULT_UNWILLING_TO_PERFORM, "", resp_msg, error);
                    SDFLOG_DEBUG((B, "LDAP_gen_add_response Done[r=%d]", r))
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", error))
                        return -1;
                    }
                    SDFLOG_DEBUG((B, "l_sess_send_response before"))
                    l_sess_send_response(sess, ber);
                    SDFLOG_DEBUG((B, "l_sess_send_response after"))
                    // main_state = METHOD_STATE_IDLE;
                    return -1;
                }
            }
            else if (r == 0)
            {
                SDFLOG_ERROR((B, "The subrelative already exists"))
                r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, LDAP_RESULT_ENTRY_ALREADY_EXISTS, "", resp_msg, error);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", error))
                    return -1;
                }
                l_sess_send_response(sess, ber);
                // main_state = METHOD_STATE_IDLE;
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
            if (r != 0)
            {
                SDFLOG_ERROR((B, "Not proceed this Modify DN request due to the target RDN on D20 cannot be found"))
                r = LDAP_gen_moddn_response (d02global.ldapd, &ber, mw->tid, res->resultcode, "", res->resultdescription, error);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                    return -1;
                }
                l_sess_send_response(sess, ber);
                main_state = METHOD_STATE_IDLE;
            }
            else
            {
                SDFLOG_DEBUG((B, "Received MODIFY DN Request"))
                mw->instance->method = METHOD_SUBREL_MODDN;
                SDFLOG_DEBUG((B, "Entry             : [%s]", mw->lmsg->alt.mod_dn_request.comps.entry))
                SDFLOG_DEBUG((B, "newrdn            : [%s]", mw->lmsg->alt.mod_dn_request.comps.new_rdn))
                SDFLOG_DEBUG((B, "delete old rdn    : [%d]", mw->lmsg->alt.mod_dn_request.comps.delete_old_rdn))
            }
            break;
        case LDAP_PROTOCOL_DELETE_REQUEST:
            if (r != 0)
            {
                SDFLOG_ERROR((B, "Not proceed this Delete DN request due to the target RDN on D20 cannot be found"))
                r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, res->resultcode, "", res->resultdescription, error);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", error))
                    return -1;
                }
                l_sess_send_response(sess, ber);
                main_state = METHOD_STATE_IDLE;
            }
            else
            {
                SDFLOG_DEBUG((B, "Received DELETE Request"))
                mw->instance->method = METHOD_SUBREL_DELETE;
            }
            break;    
    }

    if (main_state == SUBREL_SEARCH_ROOT)
    {
        r = af_init_action_resolve_subrel(sess, mw->lmsg, &tid, (void**)&h_data, mw->instance, error);
        if( r != 0 )
        {
            SDFLOG_ERROR((B, "af_init_action_resolve_subrel return error"))
            main_state = METHOD_STATE_IDLE;
        }
        else
        {
            main_state = mw->instance->main_state;    
        }        
    }
 
    /* Clear instance */
    if(main_state == METHOD_STATE_IDLE){
        return main_state;
    }

    //TODO: Change group and service to D20 and GRPC_RESOLVE_ALIASE
    if (h_data != NULL && http2_send_msg_to_queue(mw->instance, h_data) != 0 )
    {
        SDFLOG_ERROR((B, "Cannot send HTTP2 request."));
        return METHOD_STATE_IDLE;
    }
    
    

    /* Update Instance */
    mw->instance->main_state = main_state;
    mw->instance->sub_state = sub_state;

    /* Create new edb */
    MWRAPPER *nmw = NULL;
    nmw = SDF_MALLOC(sizeof(*nmw));
    if(nmw == NULL){
        strcpy(error, "Can not allocate memory");
        SDFLOG_FATAL((B, "Cannot allocate memory size (%u)",(unsigned int)(sizeof(*mw))));
        return METHOD_STATE_IDLE;
    }
    memset (nmw, 0, sizeof(*nmw));
    nmw->hash_key_len = sprintf(nmw->hash_key, "tx:%d", tid);

    /* prepare dbllist */
    nmw->dbllist.node = nmw;
    nmw->dbllist.time = time (NULL);
    nmw->dbllist.retry = 0;
    nmw->ref = mw->ref;
    nmw->lmsg = mw->lmsg;
    nmw->tid = mw->tid;
    HASH_ADD(&(d02global.htable), nmw);
    LINKEDLIST_APPEND(d02global.dbl, &(nmw->dbllist));

    /* Copy DB */
    nmw->instance = mw->instance;
    mw->instance = NULL;
    HASH_REMOVE(&(d02global.htable), mw);
    LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
    SDF_FREE(mw);

    return 0;
}

int af_action_process_v2(HTTP2_CONNECTION* conn, DSSESSION **sess){
/*#define DELETE_INSTANCE                             \
{                                                   \
HASH_REMOVE(&(d02global.htable), mw)                \
LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist))    \
if (mw->instance != NULL)                           \
{                                                   \
    (void) FREE_BER_ATTRLIST(mw->instance->alist);  \
    if(mw->instance->amf != NULL){                  \
        crt_pkg_amf_free(mw->instance->amf);        \
        mw->instance->amf = NULL;                   \
    }                                               \
    if(mw->instance->result_data != NULL){          \
        SDF_FREE(mw->instance->result_data)         \
        mw->instance->result_data = NULL;           \
    }                                               \
    SDF_FREE(mw->instance)                          \
    mw->instance = NULL;                            \
}                                                   \
if (mw != NULL)                                     \
{                                                   \
    SDF_FREE(mw);                                   \
    mw = NULL;                                      \
}                                                   \
--(d02global.sdfdb_count);                          \
}*/

#define FREE_PB_RESPONSE  if(res!=NULL) pb__response__free_unpacked(res, NULL);

    static char func[] = "af_action_process_v2";
    MWRAPPER *mw=NULL;
    HSDATA *wbuff=NULL;
    char err[MY_ERR_BUFFER_SIZE];
    char hash[MAX_HASH_KEY_SIZE];
    int hlen = 0, blen = 0, len = 0, i = 0, r = 0, n = 0;
    err[0] = 0;
    
    Pb__Response *res = NULL;
    //LDAP_RESULT *lc = NULL;
    struct timeval elap_tm;
    init_watch(TMR4, err);

    r = GRPC_get_message_response(&res, conn->usr_data, err);
    SDFLOG_DEBUG((B, "GRPC_get_message_response err: %s", err))
    SDFLOG_DEBUG((B, "GRPC_get_message_response ret: %d", r))
    if( r == GRPC_RET_NEED_MORE_DATA){
        return 0; 
    }
    stop_watch(TMR4, &elap_tm, err);
    SDFLOG_INFO((B, "-----> GRPC_get_message_response ::  :%lu us", elap_tm.tv_sec*1000000+elap_tm.tv_usec))

    if( r != GRPC_RET_OK ){
        SDFLOG_ERROR((B, "GRPC_get_message_response return error[%s]", err))
        FREE_PB_RESPONSE
        return -1;
    }
    
    if(af_process_adaptive_naming_outbound(res, d02global.global_conf.attributevalue_mapping, d02global.global_conf.adaptive_naming) != 0){
        SDFLOG_ERROR((B, "af_process_adaptive_naming_outbound return error"))
        FREE_PB_RESPONSE
        return -1;
    }
   
    if( res != NULL){
        SDFLOG_DEBUG((B, "ResultCode : [%d]", res->resultcode))
        SDFLOG_DEBUG((B, "MatchedDN  : [%s]", res->matcheddn))
        SDFLOG_DEBUG((B, "Diag       : [%s]", res->resultdescription))
        SDFLOG_DEBUG((B, "mid        : [%lu]", res->id))
    }
    
    /* generate hash key, socket+id */
    //TODO: Replace tid
    hlen = sprintf(hash, "tx:%lu", res->id);
    
    /* match the received message */
    HASH_LOCATE(&(d02global.htable),hash, hlen, mw)
    if (mw == NULL)
    {
        SDFLOG_WARN((B,"Message MID[%lu] gone", res->id))
        FREE_PB_RESPONSE
        return 1;
    }
    
    
    if( mw->ref == NULL || mw->ref->sock < 0){
        SDFLOG_WARN((B,"Socket had been closed"))
        FREE_PB_RESPONSE
        return 1;
    }
    
    if (sess != NULL) *sess = mw->ref;    
    
    SDFLOG_DEBUG((B, "Number of entries : %d", (int)res->n_entries))
    
    BER *ber    = NULL;
        
    if( mw->instance->state == AFSTATE_GET_QUERY ){
        BER_ATTRLIST *alist = NULL;
        BER_VALLIST *vlist  = NULL;
        BER_ATTRLIST *alist_temp = NULL;
        BER_VALLIST *vlist_temp = NULL;
        BER *b_attrs = NULL;
        
        if ((mw->instance->flags.bit.variant == 1) && (mw->instance->variant_obj != NULL))
        {
            char dn_tmp[LDAP_MAX_BASE_DN];
            char dn_srch[LDAP_MAX_BASE_DN];
            char dn_req[LDAP_MAX_BASE_DN];
            BER_ATTRLIST_OBJ *tmp_list;
            PAIR_VALUE_LIST *pairlist;
            PAIR_VALUE_LIST *tmp_pair;
            BER_VALLIST *field  = NULL;
            BER_VALLIST *field_temp  = NULL;
            int field_match = 0;
            int v;

            SDFLOG_DEBUG((B, "variant response"))


            SDFLOG_DEBUG((B, "request dn : %s", mw->instance->default_base_dn))
            str_replace(mw->instance->default_base_dn,mw->instance->resolve_base_dn,"$root", dn_tmp);
            SDFLOG_DEBUG((B, "dn_tmp : %s", dn_tmp))
            lower_string(dn_tmp);
            alias_replace_value(dn_tmp, NULL, dn_req);
            SDFLOG_DEBUG((B, "dn_req : %s", dn_req))

            alist = NULL;
            for( n = 0; n < res->n_entries; n++ )
            {
                Pb__Entry *entry = res->entries[n];
                SDFLOG_DEBUG((B, "dn : %s", entry->dn))
                str_replace(entry->dn,mw->instance->resolve_base_dn,"$root", dn_tmp);
                SDFLOG_DEBUG((B, "dn_tmp : %s", dn_tmp))
                lower_string(dn_tmp);
                alias_replace_value(dn_tmp, NULL, dn_srch);

                tmp_list = mw->instance->variant_obj;
                while(tmp_list)
                {
                    SDFLOG_DEBUG((B, "variantSpec [%s]", tmp_list->name ))
                    if(STRCASEEQ(dn_srch, tmp_list->name))
                    {
                        pairlist = (PAIR_VALUE_LIST*)tmp_list->obj;
                        tmp_pair = pairlist;
                        while(tmp_pair)
                        {
                            vlist = NULL;
                            field_match = 0;
                            if(mw->lmsg->alt.search_request.comps.attributes == NULL)
                            {
                                if(STRCASEEQ(dn_srch,dn_req))
                                {
                                    SDFLOG_DEBUG((B, "STRCASEEQ(dn_srch,dn_req)"))
                                    for( i = 0; i < entry->n_attributes; i++)
                                    {
                                        SDFLOG_DEBUG((B, "Entry attribrute[%s]", entry->attributes[i]->name))
                                        if(STRCASEEQ(entry->attributes[i]->name, "objectClass"))
                                        {
                                            for(v = 0; v < entry->attributes[i]->n_values; v++)
                                            {
                                                SDFLOG_DEBUG((B, "values[%s]", entry->attributes[i]->values[v]))
                                                LBER_valuelist_add(&vlist, entry->attributes[i]->values[v], NULL);
                                            }
                                            LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                                            break;
                                        }
                                    }
                                    vlist = NULL;
                                }
                                field_match = 1;
                            }
                            else
                            {
                                field_temp = field = mw->lmsg->alt.search_request.comps.attributes;
                                while(field_temp)
                                {
                                    SDFLOG_DEBUG((B, "Request field[%s]", field_temp->value))
                                    if(STRCASEEQ(dn_srch,dn_req) && STRCASEEQ(field_temp->value,"objectClass"))
                                    {
                                        for( i = 0; i < entry->n_attributes; i++)
                                        {
                                            SDFLOG_DEBUG((B, "Entry attribrute[%s]", entry->attributes[i]->name))
                                            if(STRCASEEQ(entry->attributes[i]->name, "objectClass"))
                                            {
                                                for(v = 0; v < entry->attributes[i]->n_values; v++)
                                                {
                                                    SDFLOG_DEBUG((B, "values[%s]", entry->attributes[i]->values[v]))
                                                    LBER_valuelist_add(&vlist, entry->attributes[i]->values[v], NULL);
                                                }
                                                LBER_attrlist_add(&alist, "objectClass", vlist, NULL);
                                                break;
                                            }
                                        }
                                        vlist = NULL;
                                    }

                                    if(STRCASEEQ(field_temp->value, tmp_pair->value_2))
                                    {
                                        field_match = 1;
                                        break;
                                    }
                                    field_temp = field_temp->next;
                                    if(field_temp == field)
                                    {
                                        break;
                                    }
                                }
                            }

                            if(field_match ==  1)
                            {
                                for( i = 0; i < entry->n_attributes; i++)
                                {
                                    SDFLOG_DEBUG((B, "Entry attribrute[%s]", entry->attributes[i]->name))
                                    if(STRCASEEQ(entry->attributes[i]->name, tmp_pair->value_1))
                                    {
                                        for(v = 0; v < entry->attributes[i]->n_values; v++)
                                        {
                                            SDFLOG_DEBUG((B, "values[%s]", entry->attributes[i]->values[v]))
                                            LBER_valuelist_add(&vlist, entry->attributes[i]->values[v], NULL);
                                        }
                                        LBER_attrlist_add(&alist, tmp_pair->value_2, vlist, NULL);
                                        break;
                                    }
                                }
                            }
                            tmp_pair = tmp_pair->next;
                            if(tmp_pair == pairlist)
                            {
                                break;
                            }
                        }
                        break;
                    }
                    tmp_list = tmp_list->next;
                    if(tmp_list == mw->instance->variant_obj)
                    {
                        break;
                    }
                }
            }

            BER_ATTRLIST *alist_temp = alist;
            BER_VALLIST *vlist_temp;

            while(alist_temp)
            {
                SDFLOG_DEBUG((B, "alist     [%s]", alist_temp->name))
                vlist_temp = alist_temp->vals;
                while(vlist_temp)
                {
                    vlist_temp = vlist_temp->next;
                    SDFLOG_DEBUG((B, "    vlist [%s]", vlist_temp->value))    
                    if(vlist_temp == alist_temp->vals)
                    {
                        break;
                    }
                }

                alist_temp =  alist_temp->next;
                if(alist_temp == alist)
                {
                    break;
                }
            }

            b_attrs = NULL;
            LDAP_gen_ber_attrlist(alist, &b_attrs, 1, err);   
            sprintf(dn_tmp,"%s,%s",mw->instance->dn,mw->instance->resolve_base_dn);
            ber = NULL;
            LDAP_gen_search_entry (d02global.ldapd, &ber, mw->tid,  dn_tmp, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, err);
            l_sess_send_response(mw->ref, ber);
            if (b_attrs != NULL) LDAP_ber_free(b_attrs);
        }
        else
        {    
            for( n = 0; n < res->n_entries; n++ ){
                Pb__Entry *entry = res->entries[n];
                SDFLOG_DEBUG((B, "dn : %s", entry->dn))
                int i = 0;
                alist = NULL;
                for( i = 0; i < entry->n_attributes; i++){
                    SDFLOG_DEBUG((B, "attribrute[%s]", entry->attributes[i]->name))
                    int v = 0;
                    vlist = NULL;
                    for(v = 0; v < entry->attributes[i]->n_values; v++){
                        SDFLOG_DEBUG((B, "values[%s]", entry->attributes[i]->values[v]))
                        LBER_valuelist_add(&vlist, entry->attributes[i]->values[v], NULL);
                    }
                    LBER_attrlist_add(&alist, entry->attributes[i]->name, vlist, NULL);   
                }
                b_attrs = NULL;
                LDAP_gen_ber_attrlist(alist, &b_attrs, 1, err);   
                ber = NULL;
                LDAP_gen_search_entry (d02global.ldapd, &ber, mw->tid,  entry->dn, (b_attrs!=NULL)?b_attrs->berval:NULL, (b_attrs!=NULL)?b_attrs->len:0, err);
                l_sess_send_response(mw->ref, ber);
                if (b_attrs != NULL) LDAP_ber_free(b_attrs);
            }
        }

        SDFLOG_DEBUG((B, "n_referrals[%d]", res->n_referrals))
        if( res->n_referrals > 0)
        {
            SDFLOG_DEBUG((B, "Referrals  : [%s]", res->referrals[0]))
        }

        ber = NULL;
        SDFLOG_DEBUG((B, "return ldap response msgID[%d]", mw->tid))

        if( res->n_referrals > 0)
        {
            r = LDAP_gen_search_done_with_referal(d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, NULL, res->referrals[0], err);
        }
        else
        {
            r = LDAP_gen_search_done(d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, NULL, err);
        }

        
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_done return error [%s]", err))
            DELETE_INSTANCE
            FREE_PB_RESPONSE
            return -1;
        }

        l_sess_send_response(mw->ref, ber);
        struct timeval overall_time, stoptime;
        unsigned long process_time = 0;
        WATCH_WITH_START((mw->instance->timestamp), "-----> Send last Response :: ")
    
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_POST ){
        r = LDAP_gen_add_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", err))
            DELETE_INSTANCE
            FREE_PB_RESPONSE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_PUT ){
        r = LDAP_gen_modify_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_modify_response return error [%s]", err))
            DELETE_INSTANCE
            FREE_PB_RESPONSE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_MODDN ){
        r = LDAP_gen_moddn_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", err))
            DELETE_INSTANCE
            FREE_PB_RESPONSE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE    
    }else if( mw->instance->state == AFSTATE_DELETE ){
        r = LDAP_gen_delete_response (d02global.ldapd, &ber, mw->tid, res->resultcode, res->matcheddn, res->resultdescription, err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_delete_response return error [%s]", err))
            DELETE_INSTANCE
            FREE_PB_RESPONSE
            return -1;
        }
            
        l_sess_send_response(mw->ref, ber);
        DELETE_INSTANCE
    }else if( mw->instance->state == AFSTATE_EXTENDED){
        switch( mw->instance->method )
        {
            case METHOD_INQUIRY_SESSION:
                r = af_action_process_inquiry_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_PUSH_SESSION:
                r = af_action_process_push_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_PULL_SESSION:
                r = af_action_process_pull_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_MODIFY_SESSION:
                r = af_action_process_modify_sessioninfo(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_INQUIRY_SUBSCRIBER:
                r = af_action_process_inquiry_subscriber(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_INQUIRY_PCF_VAS:
                r = af_action_process_inquiry_pcf_vas(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            default:
                DELETE_INSTANCE
                break;
        }
    }else if( mw->instance->state == AFSTATE_SUBREL){
        switch( mw->instance->method )
        {
            case METHOD_SUBREL_ADD:
                SDFLOG_DEBUG((B, "af_action_process_subrelative_add"))
                r = af_action_process_subrelative_add(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_SUBREL_DELETE:
                SDFLOG_DEBUG((B, "af_action_process_subrelative_delete"))
                r = af_action_process_subrelative_delete(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            case METHOD_SUBREL_MODDN:
                SDFLOG_DEBUG((B, "af_action_process_subrelative_modify_dn"))
                r = af_action_process_subrelative_modify_dn(res, mw, err);
                if( r != 3){
                    DELETE_INSTANCE
                }
                break;
            default:
                DELETE_INSTANCE
                break;
        }
        
    }else if( mw->instance->state == AFSTATE_METHOD){
        if ( mw->instance->method == METHOD_RESOLVE_ALIASE ){
            r = af_process_resolve_alias(res, mw, err);
            if (r != 0)
            {
                SDFLOG_ERROR((B, "af_process_resolve_alias return error [%s]", err))
                DELETE_INSTANCE
                FREE_PB_RESPONSE
                return r;
            }
        }
        else if (mw->instance->method == METHOD_RESOLVE_ALIASE_SUBREL)
        {
            r = af_process_resolve_alias_subrel(res, mw, err);
            if (r != 0)
            {
                SDFLOG_ERROR((B, "af_process_resolve_alias_subrel return error [%s]", err))
                DELETE_INSTANCE
                FREE_PB_RESPONSE
                return r;
            }
        }
    }else{
        SDFLOG_ERROR((B, "Unknown instance state"))
        DELETE_INSTANCE
        FREE_PB_RESPONSE
        return -1;
    }

    FREE_PB_RESPONSE
    return 0;
}

#endif

int switch_system_by_control(Control *control, const char *oid){
    static char func[] = "switch_system_by_control";
    Control *temp = control;
    while(temp){
        if( STRCASEEQ(temp->comps.control_type, oid) ){
            //TODO: Check transactionId format
            SDFLOG_DEBUG((B, "checking control [%s] value [%s]", temp->comps.control_type, temp->comps.control_value.value))
            return DS3_MODE;
        }
        temp = temp->next;
        if(temp == control){
            break;
        }
    }
    return UNKNOWN_MODE; //Not found control 
}

int has_control(Control *control, const char *oid){
    static char func[] = "has_control";
    Control *temp = control;
    while(temp){
        SDFLOG_DEBUG((B, "checking control [%s]", temp->comps.control_type))
        if( STRCASEEQ(temp->comps.control_type, oid) ){
            return 1; // Found control
        }
        temp = temp->next;
        if(temp == control){
            break;
        }
    }
    return 0; //Not found control 
}

int find_control(Control *control, const char *oid, Control **control_out){
    static char func[] = "find_control";
    Control *temp = control;
    while(temp){
        SDFLOG_DEBUG((B, "checking control [%s]", temp->comps.control_type))
        if( STRCASEEQ(temp->comps.control_type, oid) ){
            if(control_out != NULL)
            {
                *control_out = temp;
            }
            return 1; // Found control
        }
        temp = temp->next;
        if(temp == control){
            break;
        }
    }
    return 0; //Not found control 
}

void print_controls(Control *control){
    static char func[] = "print_controls";
    Control *temp = control;
    while(temp){
        SDFLOG_DEBUG((B, "checking control [%s] value[%s]", temp->comps.control_type, temp->comps.control_value.value))
        temp = temp->next;
        if(temp == control){
            break;
        }
    }
}



static int
l_sess_recv_msg(DSSESSION *sess)
{
    static char func[] = "l_sess_recv_msg";
    LDAPMessage_t *lmsg = NULL;
	HSDATA *wbuff=NULL;
	time_t run_time;
	char contentType[HTTP_MAX_CONTENT_TYPE_SIZE];contentType[0]='\0';
	time_t current_time = time(NULL);
    char err[MY_ERR_BUFFER_SIZE];
    
    /* verify ldap readiness */

    if (d02global.ldap_ready_flag == 0)
    {
        int i, dflag=0, aflag=0;
        char group[LDAP_MAX_STRING_GROUP];
        for (i=0; i<d02global.ldap_list_count; i++)
        {
            LDAP_clnt_get_option(d02global.ldap_list[i], LDAP_CLNT_OPTION_GROUP, group);
            if ((dflag==0) && (strcmp(group, LDAP_DEFAULT_GROUP)==0) &&
                (LDAP_clnt_get_option(d02global.ldap_list[i], LDAP_CLNT_OPTION_READY, NULL) != 0))
            {
                d02global.ldap_host_index = i;
                d02global.ldap_ready_flag = 1;
                dflag = 1;
            }
            else if ((aflag==0) && (strcmp(group, LDAP_AMF_GROUP)==0) &&
                     (LDAP_clnt_get_option(d02global.ldap_list[i], LDAP_CLNT_OPTION_READY, NULL) != 0))
            {
                d02global.ldap_ext_index = i;
                aflag = 1;
            }
            if (dflag==1 && aflag==1) break;
        }
    }

    
    if (d02global.ldap_ready_flag == 0 && 0)
    {
        while ((lmsg=sess->rdata)!=NULL)
        {
            ++(d02global.ldapd->busy_msg_count);
            l_sess_send_error(sess, lmsg, LDAP_RESULT_BUSY, "");
            LINKEDLIST_REMOVE(sess->rdata, lmsg);
            SDF_FREE(lmsg);
        }

        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            sess->write_count = sess->total_wait_write_io = 0;
            gettimeofday(&(sess->timestamp_write),0);
        }
        
        write (1, "{}", 2);
        return -1;
    }
    
	/* calculate TPS */
    if (LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_RECV_COUNT, NULL) == 1)
    {
		d02global.ref_time = current_time;
		d02global.trans_count = 0;
		d02global.tps_limit_pause = 0;
    }
	run_time = current_time;
	if (run_time - d02global.ref_time >= d02global.conf_warm.tps_window)
    {
		d02global.ref_time = run_time;
		d02global.trans_count = 0;
		if (d02global.tps_limit_pause == 1)
		{
			SDFLOG_INFO((B, "UnderSpeedLimit ACCEPT"))
			d02global.tps_limit_pause = 0;
		}
    }
	else
    {
		++(d02global.trans_count);
		if (d02global.tps_limit_pause == 0 && d02global.trans_count > (d02global.conf_warm.tps_limit * d02global.conf_warm.tps_window))
		{
			SDFLOG_INFO((B, "ExceedSpeedLimit REJECT"))
			d02global.tps_limit_pause = 1;
		}
    }

    if (d02global.control_pause || d02global.msg_count_pause || d02global.tps_limit_pause)
    {
        while ((lmsg=sess->rdata)!=NULL)
        {
            ++(d02global.ldapd->busy_msg_count);
            l_sess_send_error(sess, lmsg, LDAP_RESULT_BUSY, "");
            LINKEDLIST_REMOVE(sess->rdata, lmsg);
            SDF_FREE(lmsg);
        }

		if (fd_set_write(sess->sock) != 0)
		{
			SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", sess->sock))
			return -1;
        }

        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            sess->write_count = sess->total_wait_write_io = 0;
            gettimeofday(&(sess->timestamp_write),0);
        }

        write (1, "{}", 2);
        return -1;
    }

#ifdef GRPC
    //!--Checking Sync to service registry.
    if (d02global.D11_status == D11_STATUS_UNSYNC){
        int r = 0;
        SDFLOG_ERROR((B, "The system is out of sync, Please checking the service registry(D11)"))
        while ((lmsg=sess->rdata)!=NULL)
        {
            SDFLOG_DEBUG((B, "lmsg->choice [%d] lmsg->message_id [%d]", lmsg->choice, lmsg->message_id))
            r = l_sess_send_error(sess, lmsg, LDAP_RESULT_UNAVAILABLE, "");
            SDFLOG_DEBUG((B, "r [%d]", r))
            LINKEDLIST_REMOVE(sess->rdata, lmsg);
            SDF_FREE(lmsg);
        }
        return 0;
    }
#endif

    void *req   = NULL;
    MWRAPPER *mw        = NULL;
    unsigned int tid    = -1;
    int r               = 0;
    char tempnewdn[LDAP_MAX_BASE_DN];
    tempnewdn[0]    = '\0';

    char temp_dn[LDAP_MAX_BASE_DN * 2];
    temp_dn[0]    = '\0';
    int debug_max_sess_per_loop = 0;
	SDFLOG_DEBUG((B, "MessageLen [%d] BodyLen [%d]", sess->r_len, sess->r_ber_body_length))


    /* Test Echo */
    
    while( (lmsg=sess->rdata)!=NULL ){
        BER *ber = NULL;
        SDFLOG_DEBUG((B, "return ldap response msgID[%d]", lmsg->message_id))
        r = LDAP_gen_search_done(d02global.ldapd, &ber, lmsg->message_id, LDAP_RESULT_SUCCESS, NULL, "Test Echo", err);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_gen_search_done return error [%s]", err))
            DELETE_INSTANCE
            return -1;
        }
            
        l_sess_send_response(sess, ber);
        LINKEDLIST_REMOVE(sess->rdata, lmsg);
        SDF_FREE(lmsg);
    }
    
    SDFLOG_INFO((B, "-----------##########################-----------"))
    struct timeval overall_time;
    struct timeval stoptime, starttime;
    unsigned long process_time = 0;
    gettimeofday(&starttime, 0);


SET_WATCH(sess->timestamp_process)

    while ((lmsg=sess->rdata)!=NULL && 0)
    {
        debug_max_sess_per_loop++;
        mw = SDF_MALLOC(sizeof(*mw));
        if (mw == NULL)
        {
            SDFLOG_FATAL((B,"Can not allocate memory size (%u)",(unsigned int)(sizeof(*mw))))
            return -1;
        }
        memset (mw, 0, sizeof(*mw));
        SDFLOG_DEBUG((B, "received ldap message id[%d]", lmsg->message_id))
        SDFLOG_DEBUG((B, "ProtocolOP [%d]", lmsg->choice))

        //Find DN from request //af_init_proxy


#define MAPPING_DN(_DN){                                                                                                \
    strcpy(temp_dn,_DN);                                                                                                \
    if (af_process_adaptive_dn(sess->user.name, temp_dn, tempnewdn, d02global.global_conf.adaptive_naming_dn) == 0)     \
    {                                                                                                                   \
        strcpy(_DN, tempnewdn);                                                                                         \
    }                                                                                                                   \
    SDFLOG_DEBUG((B, "Mapped dn [%s]", _DN))                                                                            \
}
        
        switch (d02global.conf_warm.migration_mode)
        {
            case DS3_MODE: SDFLOG_DEBUG((B, "Migration mode is configured to [DS3 mode]")) break;
            case DS4_MODE: SDFLOG_DEBUG((B, "Migration mode is configured to [DS4 mode]")) break;
            case MIG_MODE: SDFLOG_DEBUG((B, "Migration mode is configured to [MIG mode]")) break;
            default: break; 
        }

        switch (d02global.conf_warm.default_ident_add_target)
        {
            case DS3_MODE: SDFLOG_DEBUG((B, "Default identity add target is configured to [DS3 mode]")) break;
            case DS4_MODE: SDFLOG_DEBUG((B, "Default identity add target is configured to [DS4 mode]")) break;
            case MIG_MODE: SDFLOG_DEBUG((B, "Default identity add target is configured to [MIG mode]")) break;
            default: break; 
        }
        
        SDFLOG_DEBUG((B, "Username [%s]", sess->user.name))
        switch(lmsg->choice)
        {
            case LDAP_PROTOCOL_SEARCH_REQUEST:
                SDFLOG_DEBUG((B, "Check adaptive naming DN for request [ SEARCH ]"))
                ++(d02global.ldapd->cmd_search_count);
                MAPPING_DN(lmsg->alt.search_request.comps.base_object);
                break;
            case LDAP_PROTOCOL_ADD_REQUEST:
                SDFLOG_DEBUG((B, "Check adaptive naming DN for request [ ADD ]"))
                ++(d02global.ldapd->cmd_add_count);
                MAPPING_DN(lmsg->alt.add_request.comps.entry);
                break;
            case LDAP_PROTOCOL_MODIFY_REQUEST:
                SDFLOG_DEBUG((B, "Check adaptive naming DN for request [ MODIFY ]"))
                ++(d02global.ldapd->cmd_modify_count);
                MAPPING_DN(lmsg->alt.modify_request.comps.object);
                break;
            case LDAP_PROTOCOL_MODIFYDN_REQUEST:
                SDFLOG_DEBUG((B, "Check adaptive naming DN for request [ MODIFY DN ]"))
                ++(d02global.ldapd->cmd_modifydn_count);
                MAPPING_DN(lmsg->alt.mod_dn_request.comps.entry);
                break;
            case LDAP_PROTOCOL_DELETE_REQUEST:
                SDFLOG_DEBUG((B, "Check adaptive naming DN for request [ DELETE ]"))
                ++(d02global.ldapd->cmd_delete_count);
                MAPPING_DN(lmsg->alt.delete_request.ldap_dn);
                break;
            case LDAP_PROTOCOL_EXTENDED_REQUEST:
                SDFLOG_DEBUG((B, "Received request [ EXTENDED ]"))
                if (strcmp(lmsg->alt.extended_request.comps.request_name,INQUIRY_SUBSCRIBER)==0){
                    ++(d02global.ldapd->cmd_ds2a_count);
                    ++(d02global.ldapd->cmd_inquiry_subscriber_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,INQUIRY_PCF_VAS)==0){
                    ++(d02global.ldapd->cmd_ds2a_count);
                    ++(d02global.ldapd->cmd_inquiry_pcfvas_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,PUSH_SESSION)==0){
                    ++(d02global.ldapd->cmd_ds2c_count);
                    ++(d02global.ldapd->cmd_push_session_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,PULL_SESSION)==0){
                    ++(d02global.ldapd->cmd_ds2c_count);
                    ++(d02global.ldapd->cmd_pull_session_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,MODIFY_SESSION)==0){
                    ++(d02global.ldapd->cmd_ds2c_count);
                    ++(d02global.ldapd->cmd_modify_session_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,INQUIRY_SESSION)==0){
                    ++(d02global.ldapd->cmd_ds2c_count);
                    ++(d02global.ldapd->cmd_inquiry_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,LDAP_EXTENDED_START_TRANSACTION)==0){
                    ++(d02global.ldapd->cmd_starttransaction_count);
                }
                else if (strcmp(lmsg->alt.extended_request.comps.request_name,LDAP_EXTENDED_END_TRANSACTION)==0){
                    ++(d02global.ldapd->cmd_endtransaction_count);
                }
                else{
                    SDFLOG_DEBUG((B, "Invalid oid received"))
                }
                break;
            default :
                SDFLOG_ERROR((B, "Unsupported message request[%d]", lmsg->choice))
                break;
        }

        print_controls(lmsg->controls);
        if(lmsg->choice == LDAP_PROTOCOL_EXTENDED_REQUEST)
        {
            if (STRCASEEQ(lmsg->alt.extended_request.comps.request_name, d02global.conf_warm.heartbeat_oid))
            {
                r = LDAP_gen_extended_response(d02global.ldapd, (BER**)&req,    \
                    lmsg->message_id, LDAP_RESULT_SUCCESS, NULL, NULL,          \
                    lmsg->alt.extended_request.comps.request_name, NULL, 0, err);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", err))
                    return -1;
                }

                if (l_sess_send_response(sess,(BER*)req) != 0){
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue;
                }            
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
                SDF_FREE(mw);
                SDFLOG_INFO((B, "Sending heartbeat response"))
                continue;
            }
            else if (STRCASEEQ(lmsg->alt.extended_request.comps.request_name, LDAP_EXTENDED_START_TRANSACTION))
            {
                TRANSACTIONIDMAPPER *tim;
                BER *ber = NULL;
                char c_id[16];
                unsigned short int trans_id = trans_id_gen();
                BER_ATTRLIST *alist=NULL;
                BER_VALLIST *vlist=NULL;

                SDFLOG_DEBUG((B, "Received extended start transaction"))
                SDFLOG_DEBUG((B, "Response with transacrion id [%d]", trans_id))
                sprintf(c_id, "%d", trans_id);
                
                alist=NULL;
                vlist=NULL;
                LBER_valuelist_add(&vlist, c_id, NULL);
                LBER_attrlist_add(&alist, "trans_id", vlist, NULL);
                r = LDAP_gen_private_by_attrlist(LDAP_PRIVATE_ID_START_TRANS_RESULT, alist, (BER**)&ber, 0, NULL);

                r = LDAP_gen_extended_common_response(d02global.ldapd, (BER**)&req,                                 \
                                                      lmsg->message_id, LDAP_RESULT_SUCCESS, NULL, NULL,            \
                                                      lmsg->alt.extended_request.comps.request_name,                \
                                                      (ber!=NULL)?ber->berval:NULL, (ber!=NULL)?ber->len:0, err);
                if (r != LDAP_RET_OK)
                {
                    SDFLOG_ERROR((B, "LDAP_gen_extended_common_response return error [%s]", err))
                    return -1;
                }

                if (l_sess_send_response(sess,(BER*)req) != 0){
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue;
                }            
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
                SDF_FREE(mw);
                SDFLOG_DEBUG((B, "Sending start transaction response"))

                SDFLOG_DEBUG((B, "Preparing to store transaction id in mapper"))
                tim = SDF_MALLOC(sizeof(*tim));
                if (tim == NULL)
                {
                    SDFLOG_FATAL((B,"Can not allocate memory size (%u)",(unsigned int)(sizeof(*mw))))
                    return -1;
                }
                memset (tim, 0, sizeof(TRANSACTIONIDMAPPER));

                tim->hash_key_len = sprintf(tim->hash_key, "sid:%d", trans_id);
                tim->dest = TRANSACTION_DESTINATION_NONE;
                tim->state = TRANSACTION_STATE_START_RECEIVED;
                tim->l_sess_tid = trans_id;
                tim->time = time (NULL);
                tim->lc = NULL;
                SDFLOG_DEBUG((B, "timestamp [%lu]", tim->time))
                tim->tim_dbl.node = tim;
                tim->tim_dbl.time = tim->time;
                tim->tim_dbl.retry = 0;
                tim->ref = sess;
                HASH_ADD(&(d02global.trans_id_map), tim);
                LINKEDLIST_APPEND(d02global.tim_dbl, &(tim->tim_dbl));
                continue;
            }
            else if(STRCASEEQ(lmsg->alt.extended_request.comps.request_name, LDAP_EXTENDED_END_TRANSACTION))
            {
                BER *request_value = lmsg->alt.extended_request.comps.request_value;
                int len = request_value->len;
                int total_len;
                int i, j, k;
                unsigned char seq, private;
                char *p = NULL;
                int pp = 0;
                char temp[LDAP_MAX_ATTR_VALUE_SIZE];
                char *ber = request_value->berval;
                TRANS_PRIVATE *trans_private;
                TRANS_PRIVATE *tp_be = NULL;
                TRANSACTIONIDMAPPER *tim=NULL;
                char hash[MAX_HASH_KEY_SIZE];
                int hlen    = 0;


                SDFLOG_DEBUG((B, "Received extended end transaction"))
                SDFLOG_DEBUG((B, "request value len [%d]",len))

                trans_private = NULL;
                LDAP_decode_private_id_response(request_value->berval ,&trans_private);

                SDFLOG_DEBUG((B, "private id        [%X] ",trans_private->private_id))
                SDFLOG_DEBUG((B, "transaction id    [%d] ",trans_private->e4.trans_id))
                SDFLOG_DEBUG((B, "action            [%d] ",trans_private->e4.action))

                hlen = sprintf(hash, "sid:%d", trans_private->e4.trans_id);
                HASH_LOCATE(&(d02global.trans_id_map),hash,hlen,tim)
                if(tim == NULL)
                {
                    SDFLOG_WARN((B,"Transaction ID [%d] gone", trans_private->e4.trans_id))
                    l_sess_send_error(sess, lmsg, LDAP_RESULT_TRANS_NOT_ACTIVE, "");
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue;
                }
                else
                {
                   SDFLOG_DEBUG((B, "timestamp  [%lu]", tim->time))
                   SDFLOG_DEBUG((B, "state      [%d]", tim->state))
                   SDFLOG_DEBUG((B, "dest       [%d]", tim->dest))
                   SDFLOG_DEBUG((B, "DSx_tid       [%d]", tim->DSx_tid))
                }

                if (tim->DSx_tid != 0)
                {
                    // TODO : Send an end transaction to backend.
                    tp_be = (TRANS_PRIVATE*)malloc(sizeof(TRANS_PRIVATE));
                    memcpy(tp_be, trans_private, sizeof(TRANS_PRIVATE));
                    tp_be->e4.trans_id = tim->DSx_tid;

                    SDFLOG_DEBUG((B, "Send end transaction to backend"))
                    if(tim->dest == TRANSACTION_DESTINATION_DS3)
                    {
                        af_init_action_extended_end_transaction_v2(sess, lmsg, &tid, (void**)&req, &mw->instance, tp_be, err);
                        mw->instance->migration_mode = DS3_MODE;
                        tim->state = TRANSACTION_STATE_SENDING_END_BE;
                        mw->instance->state = AFSTATE_TRANSACTION;
                        mw->instance->tim = tim;
                    }
                    else
                    {
                        // mw->instance->migration_mode = DS4_MODE;
                    }
                }
                else
                {
                    SDFLOG_DEBUG((B, "Removing transaction id from list [%d]", tim->l_sess_tid))
                    HASH_REMOVE(&(d02global.trans_id_map), tim)
                    SDFLOG_DEBUG((B, "d02global.tim_dbl [%p]", d02global.tim_dbl))
                    if (d02global.tim_dbl != NULL)
                    {
                        LINKEDLIST_REMOVE(d02global.tim_dbl, &(tim->tim_dbl));
                    }
                    SDF_FREE(tim);
                    SDFLOG_DEBUG((B, "Send transaction extended response"))
                    r = LDAP_gen_extended_common_response(d02global.ldapd, (BER**)&req,
                        lmsg->message_id, LDAP_RESULT_SUCCESS, NULL, NULL,
                        NULL, NULL, 0, err);
                    if (r != LDAP_RET_OK)
                    {
                        SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", err))
                        return -1;
                    }

                    if (l_sess_send_response(sess,(BER*)req) != 0){
                        LINKEDLIST_REMOVE(sess->rdata, lmsg);
                        SDF_FREE(lmsg);
                        SDF_FREE(mw);
                        continue;
                    }
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue;
                }
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                // SDF_FREE(lmsg);
                // SDF_FREE(mw);
                // continue;
            }
            else
            {
                SDFLOG_DEBUG((B, "Select DS4 mode"))
                r = af_init_action_v2(sess, lmsg, &tid, (void**)&req, &mw->instance);
            }
        // }else if( has_control(lmsg->controls, LDAP_CONTROL_TRANSACTION_ID ) == 1 ){//Check control type of ldap extend
        }else{
            Control *control;
            if( find_control(lmsg->controls, LDAP_CONTROL_TRANSACTION_ID, &control) == 1 )
            {
                int hlen = 0;
                char hash[MAX_HASH_KEY_SIZE];
                TRANSACTIONIDMAPPER *tim=NULL;

                SDFLOG_DEBUG((B, "Received LDAP command with transaction ID control"))
                SDFLOG_DEBUG((B, "control type     [%s] ",control->comps.control_type))
                SDFLOG_DEBUG((B, "control value    [%s] ",control->comps.control_value.value))

                hlen = sprintf(hash, "sid:%s", control->comps.control_value.value);
                HASH_LOCATE(&(d02global.trans_id_map), hash, hlen, tim)
                if(tim == NULL)
                {
                    SDFLOG_WARN((B,"Transaction ID [%s] gone", control->comps.control_value.value))
                    l_sess_send_error(sess, lmsg, LDAP_RESULT_TRANS_NOT_ACTIVE, "");
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue;
                }

               SDFLOG_DEBUG((B, "timestamp  [%lu]", tim->time))
               SDFLOG_DEBUG((B, "state      [%d]", tim->state))
               SDFLOG_DEBUG((B, "dest       [%d]", tim->dest))
            
                if(tim->state == TRANSACTION_STATE_START_RECEIVED)
                {
                    tim->state = TRANSACTION_STATE_RESOLVING;


                    if( d02global.conf_warm.migration_mode == DS3_MODE )
                    {
                        SDFLOG_DEBUG((B, "Select DS3 mode"))
                        if( mw->instance == NULL)
                        {
                            mw->instance = (AFINSTANCE *) SDF_MALLOC (sizeof(AFINSTANCE));
                            (mw->instance)->state              = AFSTATE_IDLE;
                            (mw->instance)->resolve_base_dn[0] = 0;
                            (mw->instance)->default_base_dn[0] = 0;
                            (mw->instance)->cluster_d21[0]     = 0;
                            (mw->instance)->dn[0]              = 0;
                            (mw->instance)->migration_mode     = MIG_MODE;
                        }
                        if (af_init_action_extended_start_transaction_v2(sess, lmsg, &tid, (void **)&req, mw->instance, err) != 0)
                        {
                            SDFLOG_ERROR((B, "af_init_action_extended_start_transaction_v2 return error"))
                            l_sess_send_error(mw->ref, mw->lmsg, LDAP_RESULT_UNAVAILABLE, err);
                            HASH_REMOVE(&(d02global.htable), mw);
                            LINKEDLIST_REMOVE(d02global.dbl, &(mw->dbllist));
                            SDF_FREE(mw);
                            return -1;
                        }

                        tim->dest = TRANSACTION_DESTINATION_DS3;
                        tim->state = TRANSACTION_STATE_SENDING_START_BE;
                    }
                    else if( d02global.conf_warm.migration_mode == DS4_MODE )
                    {
                        // SDFLOG_DEBUG((B, "Select DS4 mode"))
                        // r = af_init_action_v2(sess, lmsg, &tid, (void**)&req, &mw->instance);
                        SDFLOG_WARN((B,"Not support DS4 mode yet"))
                        l_sess_send_error(sess, lmsg, LDAP_RESULT_UNWILLING_TO_PERFORM, "Not support DS4 mode yet");
                        LINKEDLIST_REMOVE(sess->rdata, lmsg);
                        SDF_FREE(lmsg);
                        SDF_FREE(mw);
                        continue;
                    }
                    else
                    { // MIG_MODE
                        SDFLOG_DEBUG((B, "Select MIG mode"))
                        r = af_init_proxy(sess, lmsg, &tid, (void**)&req, &mw->instance);
                    }
                    mw->instance->tim = tim;
                }
                else if(tim->state == TRANSACTION_STATE_RESOLVED)
                {
                    if(tim->dest == TRANSACTION_DESTINATION_DS3)
                    {
                        SDFLOG_DEBUG((B, "Select DS3 mode"))
                        if( mw->instance == NULL)
                        {
                            mw->instance = (AFINSTANCE *) SDF_MALLOC (sizeof(AFINSTANCE));
                            (mw->instance)->state              = AFSTATE_IDLE;
                            (mw->instance)->resolve_base_dn[0] = 0;
                            (mw->instance)->default_base_dn[0] = 0;
                            (mw->instance)->cluster_d21[0]     = 0;
                            (mw->instance)->dn[0]              = 0;
                            (mw->instance)->migration_mode     = DS3_MODE;
                        }
                        mw->instance->tim = tim;
                        r = af_init_action(sess, lmsg, &tid, (void**)&req, &mw->instance);
                    }
                    else if(tim->dest == TRANSACTION_DESTINATION_DS4)
                    {
                        SDFLOG_DEBUG((B, "Select DS4 mode"))
                        r = af_init_action_v2(sess, lmsg, &tid, (void**)&req, &mw->instance);
                    }
                }

                LINKEDLIST_REMOVE(sess->rdata, lmsg);
            }
            else
            {
                int mig_mode = MIG_MODE;
                if( d02global.conf_warm.migration_mode == DS3_MODE )
                {
                    SDFLOG_DEBUG((B, "Select DS3 mode"))
                    mig_mode = DS3_MODE;
                }
                else if( d02global.conf_warm.migration_mode == DS4_MODE )
                {
                    SDFLOG_DEBUG((B, "Select DS4 mode"))
                    mig_mode = DS4_MODE;
                }
                else // MIG_MODE
                {
                    int trans_state = 0;
                    char base_dn[LDAP_MAX_BASE_DN];
                    unsigned int control_id;
                    char matchrule[16];
                    char *p;
                    char *pp;
                    char *p_base_dn = NULL;
                    if((d02global.conf_warm.migration_state != NULL) && (find_control(lmsg->controls, LDAP_CONTROL_MATCHING_IDENTITY, &control) == 1))
                    {
                        // p = lmsg->controls->comps.control_value.value;
                        p = control->comps.control_value.value;
                        control_id = strtoul(p, &pp, 10);
                        SDFLOG_DEBUG((B, "ID Type [%d]", control_id))
                        SDFLOG_DEBUG((B, "p [%p]", p))
                        SDFLOG_DEBUG((B, "pp [%p]", pp))
                        SDFLOG_DEBUG((B, "pp [%s]", pp))

                        r = 0;
                        if((p != pp) && (pp[0] == '|'))
                        {
                            pp++;
                            SDFLOG_DEBUG((B, "ID Value [%s]", pp))
                            switch (control_id)
                            {
                                case MATCHING_IDENT_MSISDN:     
                                        strcpy(matchrule, "msisdn"); break;
                                case MATCHING_IDENT_IMSI:       
                                        strcpy(matchrule, "imsi"); break;
                                case MATCHING_IDENT_PRIVATE:    
                                        strcpy(matchrule, "private"); break;
                                default: 
                                        r = -3;
                                        sprintf(err, "Invalid LDAP control ID format"); 
                                        break;
                            }
                        }

                        if(r == 0)
                        {
                            SDFLOG_DEBUG((B, "trans_state before [%d]", trans_state))
                            r = get_migration_state_from_identity(pp, &trans_state, d02global.conf_warm.migration_state);
                            if ( r == -1)
                            {
                                sprintf(err, "Failed to get migration state");
                            }
                            else
                            {
                                SDFLOG_DEBUG((B, "trans_state after [%d]", trans_state))
                                if(trans_state == COMPLETED_STATE)
                                {
                                    SDFLOG_DEBUG((B, "Migration State [DONE]"))
                                    mig_mode = DS4_MODE;
                                }
                                else if(trans_state == DOING_STATE)
                                {
                                    int dn_type;
                                    SDFLOG_DEBUG((B, "Migration State [DOING]"))
                                }
                                r = 0;
                            }
                        }
                    }
                    if(lmsg->choice == LDAP_PROTOCOL_ADD_REQUEST)
                    {
                        int dn_type;
                        int alias_dn_flag = 0;
                        // char base_dn[LDAP_MAX_BASE_DN];
                        base_dn[0]      = '\0';
                        strcpy(base_dn, lmsg->alt.add_request.comps.entry);
                        GET_IDENTITY(0);
                        SDFLOG_DEBUG((B, "base_dn   [%s]", base_dn))
                        SDFLOG_DEBUG((B, "p_base_dn [%s]", p_base_dn))
                        dn_type = af_common_check_rdn(base_dn);
                        SDFLOG_DEBUG((B, "af_common_check_rdn [dn_type=%d]", dn_type))
                        switch (dn_type)
                        {
                            case 1:
                            // case 2:
                                    if(trans_state == COMPLETED_STATE)
                                    {
                                        mig_mode = DS4_MODE;
                                    }
                                    else if(trans_state == DOING_STATE)
                                    {
                                        mig_mode = DS4_MODE;
                                    }
                                    else
                                    {
                                        // mig_mode = DS3_MODE;
                                        mig_mode = d02global.conf_warm.default_ident_add_target;
                                    }
                                    break;
                            default:
                                    SDFLOG_DEBUG((B, "Select MIG mode"))
                                    // r = af_init_proxy(sess, lmsg, &tid, (void**)&req, &mw->instance);
                                    // mig_mode = MIG_MODE;
                                    break;
                        }
                    }
                }

                SDFLOG_DEBUG((B, "r [%d]", r))
                if(r != 0)
                {
                    SDFLOG_DEBUG((B, "err [%s]", err))
                    l_sess_send_error(sess, lmsg, LDAP_RESULT_UNWILLING_TO_PERFORM, err);
                    LINKEDLIST_REMOVE(sess->rdata, lmsg);
                    SDF_FREE(lmsg);
                    SDF_FREE(mw);
                    continue; 
                }

                switch(mig_mode)
                {
                    case MIG_MODE:
                            SDFLOG_DEBUG((B, "Select MIG mode"))
                            r = af_init_proxy(sess, lmsg, &tid, (void**)&req, &mw->instance);
                            break;
                    case DS3_MODE:
                            SDFLOG_DEBUG((B, "Select DS3 mode"))
                            r = af_init_action(sess, lmsg, &tid, (void**)&req, &mw->instance);
                            break;
                    case DS4_MODE:
                            WATCH("-----> incomming ::") 
                            SDFLOG_DEBUG((B, "Select DS4 mode"))
                            SET_WATCH(starttime)
                            r = af_init_action_v2(sess, lmsg, &tid, (void**)&req, &mw->instance);
                            WATCH("-----> af_init_action_v2 ::")  
                            break; 
                    default:
                            break;                               
                }
            }
        }
        LINKEDLIST_REMOVE(sess->rdata, lmsg);
        SDFLOG_DEBUG((B,"mw->intance->state:[%d] ",mw->instance->state))
        if (tid != -1)
        {
            SDFLOG_DEBUG((B, "Use MID: %u", tid))
        }
        
        if (r!=0)
        {
            SDFLOG_ERROR((B,"af_init_action return error"))
            SDF_FREE(mw);

            if( r != -2){   //error occured
                if(r == -3)
                {
                    SDFLOG_ERROR((B,"return LDAP_RESULT_NO_SUCH_OBJECT [%d]", LDAP_RESULT_NO_SUCH_OBJECT))
                    l_sess_send_error(sess, lmsg, LDAP_RESULT_NO_SUCH_OBJECT, "");
                }
                else
                {
                    SDFLOG_ERROR((B,"return LDAP_RESULT_BUSY [%d]", LDAP_RESULT_BUSY))
                    l_sess_send_error(sess, lmsg, LDAP_RESULT_BUSY, "");
                }
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
            }else{
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
            }

            if (SDF_log_level() & SDFLOG_LEVEL_INFO)
            {
                sess->write_count = sess->total_wait_write_io = 0;
                gettimeofday(&(sess->timestamp_write),0);
            }

            continue;
        }
       
        SET_WATCH(starttime)
        if( d02global.conf_warm.migration_mode == DS4_MODE || (mw->instance->migration_mode == DS4_MODE)){
            if( http2_send_msg_to_queue(mw->instance, (HTTP2_BUFFER*)req) != 0 ){
                SDFLOG_ERROR((B, "http2_send_msg_to_queue return error"))
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
                SDF_FREE(mw);
                continue;
            }
            WATCH("-----> Send queue ::")
            SET_WATCH(starttime)
        }else{
            if(mw->instance->tim == NULL)
            {
                r = l_clnt_send_msg((BER*)req);
            }
            else
            {
                r = l_clnt_send_msg_lc((BER*)req, mw->instance->tim->lc);
            }
            if (r != 0){
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
                SDF_FREE(mw);
                continue;
            }
        }

        mw->tid = lmsg->message_id;
        /* generate hash key, socket+id */
        mw->hash_key_len = sprintf(mw->hash_key, "tx:%d", tid);
        /* prepare dbllist */
        mw->dbllist.node = mw;
        mw->dbllist.time = time (NULL);
        mw->dbllist.retry = 0;
        /* store message */
        mw->ref = sess;
        mw->protocolOp = lmsg->choice;
        mw->lmsg = lmsg;
        if (lmsg->choice==LDAP_PROTOCOL_SEARCH_REQUEST)
        {
            if (lmsg->alt.search_request.flags[BASEOBJECT])
                strcpy(mw->object, lmsg->alt.search_request.comps.base_object);
        }
        else if (lmsg->choice==LDAP_PROTOCOL_EXTENDED_REQUEST)
        {
            if (lmsg->alt.extended_request.flags[REQUESTNAME])
                strcpy(mw->object, lmsg->alt.extended_request.comps.request_name);
        }
        
        ++(d02global.sdfdb_count);
        HASH_ADD(&(d02global.htable),mw)
        LINKEDLIST_APPEND(d02global.dbl,&(mw->dbllist));
        continue;
    }

    //gettimeofday(&stoptime, 0);
    //timeval_subtract(&overall_time, &stoptime, &starttime);
    //unsigned long process_time = overall_time.tv_sec*1000000+overall_time.tv_usec;
    //SDFLOG_INFO((B, "Response Time : %lu us", process_time))
    WATCH_WITH_START(sess->timestamp_process, "-----> Resposne Time ::" )
    SDFLOG_DEBUG((B, "Max events : %d", debug_max_sess_per_loop))
	return 0;
}

static int
l_sess_send_response(DSSESSION *sess, BER *ber)
{
    static char func[] = "l_sess_send_response";
    char err[MY_ERR_BUFFER_SIZE];
    err[0] = 0;
    int r=0;

    SDFLOG_DEBUG((B, "Send LDAP response"))
    r = LDAP_sess_send_message (d02global.ldapd, sess, ber, fd_set_write, err);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_clnt_send_message return error [%s]", err))
        return -1;
    }

    return 0;
}

static int
l_sess_send_error(DSSESSION *sess, LDAPMessage_t *lmsg, int error_code, char *error_msg)
{
    static char func[] = "l_sess_send_error";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0;
    BER *ber=NULL;

    switch (lmsg->choice) {
        case LDAP_PROTOCOL_SEARCH_REQUEST:
        case LDAP_PROTOCOL_SEARCH_ENTRY:
        case LDAP_PROTOCOL_SEARCH_DONE:
            r = LDAP_gen_search_done(d02global.ldapd, &ber, lmsg->message_id, error_code, NULL, error_msg, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_search_done return error [%s]", err))
                return -1;
            }
            break;

        case LDAP_PROTOCOL_EXTENDED_REQUEST:
        case LDAP_PROTOCOL_EXTENDED_RESPONSE:
            r = LDAP_gen_extended_response(d02global.ldapd, &ber, lmsg->message_id, error_code,
                                           NULL, error_msg,
                                           lmsg->alt.extended_request.comps.request_name, NULL, 0, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_extended_response return error [%s]", err))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFY_REQUEST:
        case LDAP_PROTOCOL_MODIFY_RESPONSE:
            r = LDAP_gen_modify_response(d02global.ldapd, &ber, lmsg->message_id, error_code, NULL, error_msg, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_modify_response return error [%s]", err))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_ADD_REQUEST:
        case LDAP_PROTOCOL_ADD_RESPONSE:
            r = LDAP_gen_add_response(d02global.ldapd, &ber, lmsg->message_id, error_code, NULL, error_msg, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_add_response return error [%s]", err))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_DELETE_REQUEST:
        case LDAP_PROTOCOL_DELETE_RESPONSE:
            r = LDAP_gen_delete_response(d02global.ldapd, &ber, lmsg->message_id, error_code, NULL, error_msg, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_delete_response return error [%s]", err))
                return -1;
            }
            break;
        case LDAP_PROTOCOL_MODIFYDN_REQUEST:
        case LDAP_PROTOCOL_MODIFYDN_RESPONSE:
            r = LDAP_gen_moddn_response(d02global.ldapd, &ber, lmsg->message_id, error_code, NULL, error_msg, err);
            if (r != LDAP_RET_OK)
            {
                SDFLOG_ERROR((B, "LDAP_gen_moddn_response return error [%s]", err))
                return -1;
            }
            break;
        default:
            break;
    }

    SDFLOG_DEBUG((B, "Send LDAP error"))
    r = LDAP_sess_send_message (d02global.ldapd, sess, ber, fd_set_write, err);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_clnt_send_message return error [%s]", err))
        return -1;
    }

    return 0;
}


static int
l_clnt_open()
{
	static char func[] = "l_clnt_open";
	char err[MY_ERR_BUFFER_SIZE];
    int r, hi;
    LDAP_CLNT *lc;
	epoll_event_element_t* epoll_event_elem = NULL;

    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        while ((r=LDAP_clnt_open(d02global.ldap_list[hi], &lc, err))==LDAP_RET_OK)
        {
            SDFLOG_DEBUG((B,"Open LDAP Connection"))
            if (epoll_event_add(d02global.base_epoll, lc->sock, EPOLLIN | EPOLLOUT | EPOLLET, &epoll_event_elem) == 0)
            {
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void*)lc );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void*)l_clnt_write_callback );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void*)l_clnt_read_callback );
                epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void*)l_clnt_close_callback );
            }
            else
            {
                SDFLOG_FATAL((B,"Cannot register base_epoll for socket %d", lc->sock))
                return -1;
            }
        }
        if (r!=LDAP_RET_MAX_CONNECTION)
        {
            SDFLOG_FATAL((B,"LDAP_clnt_open return error [%s]", err))
            return -1;
        }
    }

	return 0;
}

static int
l_clnt_close(LDAP_CLNT *lc)
{
	static char func[] = "l_clnt_close";
    char err[MY_ERR_BUFFER_SIZE];
    int sk = lc->sock;
    int i, found=0;
    char group[LDAP_MAX_STRING_GROUP];

    if (LDAP_clnt_close((LDAP_t *)lc->group, lc->no, err)!=LDAP_RET_OK)
    {
        SDFLOG_FATAL((B,"Cannot close ldap connection for socket %d", lc->sock))
		return -1;
    }

	if (sk >= 0)
	{
        SDFLOG_WARN((B,"Connection close (%d)", sk))
        fd_clear(sk);
	}

    // scan available connection list
    for (i=0; i<d02global.ldap_list_count; i++)
    {
        LDAP_clnt_get_option(d02global.ldap_list[i], LDAP_CLNT_OPTION_GROUP, group);
        if ((strcmp(group, LDAP_DEFAULT_GROUP)==0) &&
            (LDAP_clnt_get_option(d02global.ldap_list[i], LDAP_CLNT_OPTION_READY, NULL) != 0))
        {
            found = 1;
            break;
        }
    }
    if (found==0) d02global.ldap_ready_flag = 0;

	return 0;
}

static int
l_clnt_write_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	static char func[] = "l_clnt_write_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0;
    LDAP_CLNT *lc = (LDAP_CLNT *)user_data;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
	//SDFLOG_DEBUG((B,"FD %d ", fd))

    r = LDAP_clnt_write((LDAP_t *)lc->group, lc, err);
	if (r == LDAP_RET_SENT)
    {
        SDFLOG_DEBUG((B, "Session (%d) sent success", lc->sock))
        // Send stats should be incremented here
    }
    else if (r == LDAP_RET_OK)
    {
        //SDFLOG_DEBUG((B, "OK"))
    }
    else
    {
        SDFLOG_ERROR((B, "Session (%d) LDAP write return error [%s]", lc->sock, err))
        (void) l_clnt_close (lc);
        return -1;
    }
    // Flush ldap request data
    r = LDAP_clnt_send_message ((LDAP_t *)lc->group, NULL, NULL, fd_set_write, NULL);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "Session (%d) LDAP_clnt_send_message return error", lc->sock))
        return -1;
    }

	return 0;
}

static int
l_clnt_read_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	static char func[] = "l_clnt_read_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, sk;
    LDAP_CLNT *lc = (LDAP_CLNT *)user_data;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
    SDFLOG_DEBUG((B,"user_data %p ", lc))

    sk = lc->sock;
    if (fd_set_read(sk) != 0)
    {
        SDFLOG_ERROR((B,"fd_set_read error for socket (%d)", sk))
        return -1;
    }

    r = LDAP_clnt_read((LDAP_t *)lc->group, lc, err);
	if (r == LDAP_RET_READY)
    {
        SDFLOG_INFO((B, "LDAP connection (%d) established", sk))
    }
    else if (r == LDAP_RET_OK)
    {
        SDFLOG_DEBUG((B, "Session (%d) Read success", sk))
        while ((r=LDAP_clnt_decode((LDAP_t *)lc->group, lc, err))==LDAP_RET_DATA_AVAILABLE)
        {
            l_clnt_recv_msg(lc);
        }
        if (r<0)
        {
            SDFLOG_ERROR((B, "Session (%d) LDAP decode return error [%s]", sk, err))
            (void) l_clnt_close (lc);
            return -1;
        }
    }
    else
    {
        SDFLOG_ERROR((B, "Session (%d) LDAP read return error [%s]", sk, err))
        (void) l_clnt_close (lc);
        return -1;
    }
    // Flush ldap request data
    r = LDAP_clnt_send_message ((LDAP_t *)lc->group, NULL, NULL, fd_set_write, NULL);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "Session (%d) LDAP_clnt_send_message return error", sk))
        return -1;
    }

	return 0;
}

static int
l_clnt_close_callback( base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data )
{
	//static char func[] = "l_clnt_close_callback";

	//SDFLOG_DEBUG((B,"FD %d ", fd))
    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);

	(void) l_clnt_close (user_data);
	return 0;
}
#ifdef USE_RPC
int rpc_clnt_send_msg(Request *req, Response **res){
    static char func[] = "rpc_clnt_send_msg";
	D21Client *D21 = new_D21Client("127.0.0.1:6051");
    
    if(req == NULL){
        SDFLOG_ERROR((B, "rpc_clnt_send_msg return error[Request is emptry]"))
        return -1;
    }
    
	*res = new_Response();

	/* Send Request */
	c_Do_param(D21, req, *res);

	/* Recv Request */
	SDFLOG_DEBUG((B, "Matcheddn :: %s", Res_MatchedDn(*res)));
	SDFLOG_DEBUG((B, "referrals size :: %d", Res_Referrals_Size(*res)));

	/* Print Refferals */
	int i = 0;
	int r = Res_Referrals_Size(*res);
	for ( ;i < r; i++){
	SDFLOG_DEBUG((B, "referrals i :: %d = %s",i,Res_Referrals_Index(*res, i)));
	}

	/* Print Entry */
	i = 0;
	r = Res_Entry_Size(*res);
	for ( ;i < r; i++){
	Entry *e = (Entry*)Res_entries(*res, i); 
	SDFLOG_DEBUG((B, "Entry [%d]", i));
	SDFLOG_DEBUG((B, "Dn      : %s", Res_Entry_Dn(e)));
	SDFLOG_DEBUG((B, "Methode : %d", Res_Entry_Method(e)));

	int a_len = Res_EntryAttribute_Size(e);
	int j = 0;

     for( ;j < a_len; j++){
		EntryAttribute *ea = (EntryAttribute *)Res_EntryAttributes_Index(e, j);
		SDFLOG_DEBUG((B, "-Attr name[%s]", Res_EntryAttribute_Name(ea)));
		SDFLOG_DEBUG((B, "-Attr value[%s]", Res_EntryAttribute_Value(ea,0)));
		}
	}
    
    /* Response HTTP */
    
    return 0;
}
#endif
static int
l_clnt_send_msg_lc(BER *ber, LDAP_CLNT *lc)
{
    static char func[] = "l_clnt_send_msg_lc";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, i, found=0;
    char group[LDAP_MAX_STRING_GROUP];

    SDFLOG_DEBUG((B, "Send LDAP message with lc"))
    r = LDAP_clnt_send_message (LDAP_LIST_HANDLE, lc, ber, fd_set_write, err);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_clnt_send_message return error [%s]", err))
        return -1;
    }
    // Perform round-robin sharing logic
    for (i=1; i<=d02global.ldap_list_count; i++)
    {
        r = d02global.ldap_host_index + i;
        if (r >= d02global.ldap_list_count) r = 0;
        LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_GROUP, group);
        if ((strcmp(group, LDAP_DEFAULT_GROUP)==0) &&
            (LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_READY, NULL) != 0))
        {
            found = 1;
            d02global.ldap_host_index = r;
            break;
        }
    }
    if (found==0) d02global.ldap_ready_flag = 0;

    return 0;
}

static int
l_clnt_send_msg(BER *ber)
{
    static char func[] = "l_clnt_send_msg";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, i, found=0;
    char group[LDAP_MAX_STRING_GROUP];

    SDFLOG_DEBUG((B, "Send LDAP message"))
    r = LDAP_clnt_send_message (LDAP_LIST_HANDLE, NULL, ber, fd_set_write, err);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_clnt_send_message return error [%s]", err))
        return -1;
    }
    // Perform round-robin sharing logic
    for (i=1; i<=d02global.ldap_list_count; i++)
    {
        r = d02global.ldap_host_index + i;
        if (r >= d02global.ldap_list_count) r = 0;
        LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_GROUP, group);
        if ((strcmp(group, LDAP_DEFAULT_GROUP)==0) &&
            (LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_READY, NULL) != 0))
        {
            found = 1;
            d02global.ldap_host_index = r;
            break;
        }
    }
    if (found==0) d02global.ldap_ready_flag = 0;

    return 0;
}

static int
l_clnt_send_ext_msg(BER *ber)
{
    static char func[] = "l_clnt_send_ext_msg";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, i;
    char group[LDAP_MAX_STRING_GROUP];

    SDFLOG_DEBUG((B, "Send LDAP extended message"))
    r = LDAP_clnt_send_message (LDAP_EXT_HANDLE, NULL, ber, fd_set_write, err);
    if (r != LDAP_RET_OK)
    {
        SDFLOG_ERROR((B, "LDAP_clnt_send_message return error [%s]", err))
        return -1;
    }
    // Perform round-robin sharing logic
    for (i=1; i<=d02global.ldap_list_count; i++)
    {
        r = d02global.ldap_ext_index + i;
        if (r >= d02global.ldap_list_count) r = 0;
        LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_GROUP, group);
        if ((strcmp(group, LDAP_AMF_GROUP)==0) &&
            (LDAP_clnt_get_option(d02global.ldap_list[r], LDAP_CLNT_OPTION_READY, NULL) != 0))
        {
            d02global.ldap_ext_index = r;
            break;
        }
    }

    return 0;
}

static int
l_clnt_recv_msg(LDAP_CLNT *lc)
{
#define CLEAR_RBER(){           \
    if(lc->rber != NULL){       \
    lc->rber->berval[0] = 0;    \
    lc->rber->len = 0;          \
    }                           \
}
    static char func[] = "l_clnt_recv_msg";
    char err[MY_ERR_BUFFER_SIZE];
    char hash[MAX_HASH_KEY_SIZE];
    MWRAPPER *mw        = NULL;
    DSSESSION *sess     = NULL;
    HSDATA *wbuff       = NULL;
    int hlen            = 0;
    int r               = 0;

    SDFLOG_DEBUG((B, "Received MID[%u] ResultCode[%d] MatchedDN[%s] DiagnosticMessage[%s]", lc->tid, lc->result_code, lc->matchedDN, lc->diagnosticMessage))

    /* generate hash key, socket+id */
    hlen = sprintf(hash, "tx:%d", lc->tid);

    /* match the received message */
    HASH_LOCATE(&(d02global.htable),hash,hlen,mw)

    if( mw->instance->migration_mode == DS3_MODE ){
        // SDFLOG_DEBUG((B, "DS3 Mode"))
        r = af_action_process(lc, &sess);
    }else if(  mw->instance->migration_mode == DS4_MODE ){
        SDFLOG_DEBUG((B, "Invalid Mode"))
    }else if(  mw->instance->migration_mode == MIG_MODE ){
        // SDFLOG_DEBUG((B, "MIG Mode"))
        r = af_process_proxy(lc, &sess);
    }

    CLEAR_RBER()
    if (r == 1)
    {
        LDAP_clnt_string_free(lc, err);
        return -1;
    }
    else if (r == 2)
    {
/*        if (http_gen_not_implemented_page(sess, &wbuff) != 0)
        {
            LDAP_clnt_string_free(lc, err);
            l_sess_close(sess);
            return -1;
        }*/

        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            sess->write_count = sess->total_wait_write_io = 0;
            gettimeofday(&(sess->timestamp_write),0);
        }
    }
    else if (r == 3){
        //Send next request.
        lc->diagnosticMessage[0] = '\0';
        SDFLOG_DEBUG((B, "Wait ldap response"))
        LDAP_clnt_string_free(lc, err);
    }
    else if (r != 0)
    {
/*        if (http_gen_internal_error_page(sess, &wbuff) != 0)
        {
            LDAP_clnt_string_free(lc, err);
            l_sess_close(sess);
            return -1;
        }*/
        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            sess->write_count = sess->total_wait_write_io = 0;
            gettimeofday(&(sess->timestamp_write),0);
        }
    }

    LDAP_clnt_string_free(lc, err);
    return 0;
}





static int
config_load_cold()
{
	static char func[] = "config_load_cold";
	char buff[1024], dis[10], dis1[10];
	SDF_CONFIG_MEM *cc, *cf, cold, tmp, tmp1;
	SDF_XML xml;
    char group[LDAP_MAX_STRING_GROUP], host[LDAP_MAX_STRING_HOST];
    int port, max_w_len, concurrent, max_con, host_count;
    char baseDN[LDAP_MAX_BASE_DN];
    char username[LDAP_MAX_STRING_USERNAME];
    char password[LDAP_MAX_STRING_PASSWORD];
    int  ret;

    // Local Configuration
	cf = SDF_config_load_file(d02global.config);
	if (cf == NULL) return -1;

	if (SDF_config_find_element(cf, "configuration", &tmp1, NULL, 1) != 0)
	{
		SDF_config_free(cf);
		return -1;
	}
	if (SDF_config_find_element(&tmp1, "cold", &cold, NULL, 1) != 0)
	{
		SDF_config_free(cf);
		return -1;
	}

	cold.curr = 0;
	if (SDF_config_find_element_attr(&cold, "HomeDirectory", "value", buff, sizeof(buff), 1) != 0)
	{
		SDF_config_free(cf);
		return -1;
	}
	if (chdir(buff) != 0)
	{
		SDFLOG_FATAL((B, "chdir [%s] return error [%s]", buff, strerror(errno)))
		SDF_config_free(cf);
		return -1;
	}

    cold.curr = 0;
	while (1)
	{
        if (SDF_config_find_element(&cold, "Instance", &tmp, &xml, 0) !=0 )
        {
            SDFLOG_FATAL((B, "Can't find matched instance id [%s] configuration", d02global.instance))
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "id", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (strcmp(d02global.instance, buff)==0)
        {
            break;
        }
	}
    // process <Instance><ldapd>
    tmp.curr = 0;
    if (SDF_config_find_element(&tmp, "ds", &tmp1, &xml, 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (SDF_config_find_attr(&xml, "baseDN", baseDN, sizeof(baseDN), 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (SDF_config_find_attr(&xml, "port", buff, sizeof(buff), 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (get_int(buff, &(port)) != 0)
    {
        SDFLOG_FATAL((B, "Invalid attribute port=\"%s\" of element <ldapd>", buff))
        SDF_config_free(cf);
        return -1;
    }
    if (SDF_config_find_attr(&xml, "backlog", buff, sizeof(buff), 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (get_int(buff, &(max_w_len)) != 0)
    {
        SDFLOG_FATAL((B, "Invalid attribute backlog=\"%s\" of element <ldapd>", buff))
        SDF_config_free(cf);
        return -1;
    }
    if (SDF_config_find_attr(&xml, "connection", buff, sizeof(buff), 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (get_int(buff, &(max_con)) != 0)
    {
        SDFLOG_FATAL((B, "Invalid attribute connection=\"%s\" of element <ldapd>", buff))
        SDF_config_free(cf);
        return -1;
    }
    if (max_con > LDAP_MAX_SESSION)
    {
        SDFLOG_FATAL((B, "Max connection exceeds [%d:%d]", max_con, LDAP_MAX_SESSION))
        SDF_config_free(cf);
        return -1;
    }
    if (SDF_config_find_attr(&xml, "concurrent", buff, sizeof(buff), 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    if (get_int(buff, &(concurrent)) != 0)
    {
        SDFLOG_FATAL((B, "Invalid attribute concurrent=\"%s\" of element <ldapd>", buff))
        SDF_config_free(cf);
        return -1;
    }
    if (concurrent > LDAP_MAX_CONCURRENT_REQUEST)
    {
        SDFLOG_FATAL((B, "Max concurrent exceeds [%d:%d]", concurrent, LDAP_MAX_CONCURRENT_REQUEST))
        SDF_config_free(cf);
        return -1;
    }
    d02global.ldapd = LDAP_svr_init(baseDN, port, max_w_len, max_con, concurrent);

    // process <Instance><ldap>
    host_count = 0;
    tmp.curr = 0;
    while (host_count < MAX_LDAP_HOST)
    {
        ret = SDF_config_find_element(&tmp, "ldap", &tmp1, &xml, (host_count==0)?1:0);
        if (ret != 0)
        {
            if (ret == SDF_CONFIG_RET_EOF) break;
            SDF_config_free(cf);
            return -1;
        }
        strcpy(group, LDAP_DEFAULT_GROUP);
        if (SDF_config_find_attr(&xml, "group", buff, sizeof(buff), 0)==0)
        {
            if (strcmp(buff, LDAP_AMF_GROUP)==0)
                strcpy(group, LDAP_AMF_GROUP);
            else
                strcpy(group, LDAP_DEFAULT_GROUP);
        }
        if (SDF_config_find_attr(&xml, "ip", host, sizeof(host), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "port", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (get_int(buff, &(port)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute port=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "wbuffer", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        max_w_len = 0;
        if (get_int(buff, &(max_w_len)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute wbuffer=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }

        if (SDF_config_find_attr(&xml, "baseDN", baseDN, sizeof(baseDN), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "username", username, sizeof(username), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "password", password, sizeof(password), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "concurrent", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        concurrent = 0;
        if (get_int(buff, &(concurrent)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute concurrent=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (concurrent > LDAP_MAX_CONCURRENT_REQUEST)
        {
            SDFLOG_FATAL((B, "Max concurrent exceeds [%d:%d]", concurrent, LDAP_MAX_CONCURRENT_REQUEST))
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "connection", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        max_con = 0;
        if (get_int(buff, &(max_con)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute connection=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (max_con > LDAP_MAX_CLIENT)
        {
            SDFLOG_FATAL((B, "Max connection exceeds [%d:%d]", max_con, LDAP_MAX_CLIENT))
            SDF_config_free(cf);
            return -1;
        }
        d02global.ldap_list[host_count++] = LDAP_clnt_init(group, baseDN, username, password, host, port, max_w_len, concurrent, max_con);
    }
    d02global.ldap_list_count = host_count;
    
#ifdef GRPC
    #define MAX_D21_CLUSTER 128
    
    host_count = 0;
    tmp.curr = 0;
    
    while (host_count < MAX_D21_CLUSTER)
    {
        ret = SDF_config_find_element(&tmp, "grpc", &tmp1, &xml, 0);
        if (ret != 0)
        {
            if (ret == SDF_CONFIG_RET_EOF) break;
            SDF_config_free(cf);
            return -1;
        }
        strcpy(group, LDAP_DEFAULT_GROUP);
        if (SDF_config_find_attr(&xml, "group", buff, sizeof(buff), 0)==0)
        {
            strcpy(group, buff);
        }
        if (SDF_config_find_attr(&xml, "ip", host, sizeof(host), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "port", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (get_int(buff, &(port)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute port=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "concurrent", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        concurrent = 0;
        if (get_int(buff, &(concurrent)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute concurrent=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (concurrent > LDAP_MAX_CONCURRENT_REQUEST)
        {
            SDFLOG_FATAL((B, "Max concurrent exceeds [%d:%d]", concurrent, LDAP_MAX_CONCURRENT_REQUEST))
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "connection", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        max_con = 0;
        if (get_int(buff, &(max_con)) != 0)
        {
            SDFLOG_FATAL((B, "Invalid attribute connection=\"%s\" of element <ldap>", buff))
            SDF_config_free(cf);
            return -1;
        }
        if (max_con > LDAP_MAX_CLIENT)
        {
            SDFLOG_FATAL((B, "Max connection exceeds [%d:%d]", max_con, LDAP_MAX_CLIENT))
            SDF_config_free(cf);
            return -1;
        }
        SDFLOG_DEBUG((B, "Add group[%s] host[%s] port[%d]",group, host, port))
        if( http2_add_conn(group, host, port, max_con, concurrent, "cluster0", 0, "node0", 0, "default", 7, 1, 1) != 0 ){
            SDFLOG_FATAL((B, "http2_add_conn return error"))
            SDF_config_free(cf);
            return -1;
        }
        host_count++;
    }

    // process <Instance><globalgrpc>
    tmp.curr = 0;
    concurrent = 0;
    max_con = 0;
    if (SDF_config_find_element(&tmp, "GlobalGrpc", &tmp1, &xml, 0) == SDF_CONFIG_RET_OK)
    {
        SDFLOG_DEBUG((B,"Found GlobalGrpc"))
        if (SDF_config_find_attr(&xml, "concurrent", buff, sizeof(buff), 0) == SDF_CONFIG_RET_OK)
        {
            if (get_int(buff, &(concurrent)) != 0)
            {
                SDFLOG_WARN((B,"Invalid globalgrpc concurrent attribute=\"%s\", using default value [%d]",buff, GRPC_DEFAULT_CONCURRENCE))
                concurrent = GRPC_DEFAULT_CONCURRENCE;
            }
            else
            {
                if (concurrent > HTTP2_MAX_CONCURRENCE)
                {
                    SDFLOG_WARN((B,"Globalgrpc concurrent value is too large [%d], using max value [%d]",concurrent, HTTP2_MAX_CONCURRENCE))
                    concurrent = HTTP2_MAX_CONCURRENCE;
                }
            }
        }

        if (SDF_config_find_attr(&xml, "connection", buff, sizeof(buff), 0) == SDF_CONFIG_RET_OK)
        {
            if (get_int(buff, &(max_con)) != 0)
            {
                SDFLOG_WARN((B,"Invalid globalgrpc connection attribute=\"%s\", using default value [%d]",buff, GRPC_DEFAULT_CONNECTION))
                max_con = GRPC_DEFAULT_CONNECTION;
            }
            else
            {
                if (max_con > HTTP2_MAX_CONNECTION)
                {
                    SDFLOG_WARN((B,"Globalgrpc connection value is too large [%d], using max value [%d]",max_con, HTTP2_MAX_CONNECTION))
                    max_con = HTTP2_MAX_CONNECTION;
                }
            }
        }
    }

    if (concurrent != 0)
    {
        d02global.grpc_conf.max_concurrence = concurrent;
        SDFLOG_DEBUG((B,"Set GlobalGrpc concurrent [%d]", d02global.grpc_conf.max_concurrence))
    }
    else
    {
        SDFLOG_WARN((B,"No GlobalGrpc concurrent in config, using default value [%d]", GRPC_DEFAULT_CONCURRENCE))
        d02global.grpc_conf.max_concurrence = GRPC_DEFAULT_CONCURRENCE;
    }

    if (max_con != 0)
    {
        d02global.grpc_conf.max_connection = max_con;
        SDFLOG_DEBUG((B,"Set GlobalGrpc connection [%d]", d02global.grpc_conf.max_connection))
    }
    else
    {
        SDFLOG_WARN((B,"No GlobalGrpc connection in config, using default value [%d]", GRPC_DEFAULT_CONNECTION))
        d02global.grpc_conf.max_connection = GRPC_DEFAULT_CONNECTION;
    }

    /*
    <RoutingRule>
        <Service name="D11" cluster="infra-1" rule="ROUNDROBIN"/>
        <Service name="D20" cluster="d20-cluster" rule="ROUNDROBIN"/>
        <Service name="D21" cluster="d21-cluster" rule="MASTERRATIO"/>
    </RoutingRule>
    */
    SDFLOG_DEBUG((B, "Finding routing rule"))
    tmp.curr = 0;
    ret = SDF_config_find_element(&tmp, "RoutingRule", &tmp1, &xml, 0);
    if( ret == SDF_CONFIG_RET_OK ){
        char service_name[1024];
        char cluster_name[1024];
        char rule[1024];
        SDFLOG_DEBUG((B, "Enable routing rule"))
        while (1)
        {
            ret = SDF_config_find_element(&tmp1, "Service", NULL, &xml, 0);
            if (ret != 0)
            {
                if (ret == SDF_CONFIG_RET_EOF) break;
                SDF_config_free(cf);
                return -1;
            }
            if (SDF_config_find_attr(&xml, "name", service_name, sizeof(service_name), 1) !=0 )
            {
                SDF_config_free(cf);
                return -1;
            }
            if (SDF_config_find_attr(&xml, "cluster", cluster_name, sizeof(cluster_name), 1) !=0 )
            {
                SDF_config_free(cf);
                return -1;
            }
            if (SDF_config_find_attr(&xml, "rule", rule, sizeof(rule), 1) != 0 )
            {
                SDF_config_free(cf);
                return -1;
            }
            SDFLOG_DEBUG((B, "Add new rule service[%s] cluster[%s] rule[%s]", service_name, cluster_name, rule))
            if( http2_add_rule(service_name, cluster_name, rule) != 0 ){
                SDFLOG_FATAL((B, "http2_add_rule return error"))
                SDF_config_free(cf);
                return -1;
            }
        }
    }
    
#endif
	SDF_config_free(cf);
	return 0;
}


static int
config_load_warm ()
{
    static char func[] = "config_load_warm";
    char buff[1024];
    SDF_CONFIG_MEM *cf, warm, tmp, tmp1, tmp2;
    RAHS_CONF_WARM wconf;
    SDF_XML xml;
    char group[LDAP_MAX_STRING_GROUP];
    int conf_value;
    DSUSER *dsu = NULL;
    int ret;
#define READ_WARM_CONFIG(_name,_min,_max,_var)                                              \
{                                                                                           \
   int _i_;                                                                                 \
   warm.curr = 0;                                                                           \
   if (SDF_config_find_element_attr (&warm, (_name), "value", buff, sizeof(buff), 1) != 0)  \
   {                                                                                        \
      SDF_config_free (cf);                                                                 \
      return -1;                                                                            \
   }                                                                                        \
   if (get_int (buff, &_i_) != 0)                                                           \
   {                                                                                        \
      SDFLOG_ERROR((B,"Invalid attribute value=\"%s\" of element <%s>",buff,(_name)))       \
      SDF_config_free (cf);                                                                 \
      return -1;                                                                            \
   }                                                                                        \
   if (_i_ < (_min))                                                                        \
   {                                                                                        \
      SDFLOG_ERROR((B,"Attribute value=\"%s\" of element <%s> is too small",buff,(_name)))  \
      SDF_config_free (cf);                                                                 \
      return -1;                                                                            \
   }                                                                                        \
   if (_i_ > (_max))                                                                        \
   {                                                                                        \
      SDFLOG_ERROR((B,"Attribute value=\"%s\" of element <%s> is too big",buff,(_name)))    \
      SDF_config_free (cf);                                                                 \
      return -1;                                                                            \
   }                                                                                        \
   (_var) = _i_;                                                                            \
}
#define READ_WARM_CONFIG_OPT(_name,_min,_max,_def,_var)                                     \
{                                                                                           \
   int _i_;                                                                                 \
   warm.curr = 0;                                                                           \
   if (SDF_config_find_element_attr (&warm, (_name), "value", buff, sizeof(buff), 0) != 0)  \
   {                                                                                        \
      (_var) = _def;                                                                        \
   }                                                                                        \
   else                                                                                     \
   {                                                                                        \
      if (get_int (buff, &_i_) != 0)                                                        \
      {                                                                                     \
         SDFLOG_WARN((B,"Invalid attribute value=\"%s\" of element <%s>",buff,(_name)))     \
         (_var) = _def;                                                                     \
      }                                                                                     \
	  else                                                                                  \
	  {                                                                                     \
         if (_i_ < (_min)) {                                                                \
            SDFLOG_WARN((B,"Attribute value=\"%s\" of element <%s> is too small",buff,(_name))) \
            (_var) = _min;                                                                  \
         } else if (_i_ > (_max)) {                                                         \
            SDFLOG_WARN((B,"Attribute value=\"%s\" of element <%s> is too big",buff,(_name)))\
            (_var) = _max;                                                                  \
         } else {                                                                           \
			(_var) = _i_;                                                                   \
		 }                                                                                  \
      }                                                                                     \
   }                                                                                        \
}

    cf = SDF_config_load_file (d02global.config);
    if (cf == NULL)
        return -1;
    if (SDF_config_find_element (cf, "configuration", &tmp, NULL, 1) != 0)
    {
        SDF_config_free (cf);
        return -1;
    }
    if (SDF_config_find_element (&tmp, "warm", &warm, NULL, 1) != 0)
    {
        SDF_config_free (cf);
        return -1;
    }
#ifdef XTHREAD_STAT
    READ_WARM_CONFIG("StatInterval",1,60,wconf.stat_interval)
	if ((60 % wconf.stat_interval)!=0)
	{
		SDFLOG_ERROR((B,"StatInterval value must set to 1,2,3,4,5,6,10,12,15,20,30 and 60 only."))
		return -1;
	}
	READ_WARM_CONFIG_OPT("StatAlignment",0,59,0,wconf.stat_alignment)
#else
    READ_WARM_CONFIG("StatInterval",0,600,wconf.stat_interval)
#endif
#ifdef STAT_RESET
	READ_WARM_CONFIG_OPT("StatResetInterval",0,1440,1440,wconf.stat_reset_interval)
#endif
#ifdef SDFLOG_SPLIT
	READ_WARM_CONFIG_OPT("SFLOGSplitInterval",5,1440,1440,wconf.sflog_split_interval)
	if ((1440 % wconf.sflog_split_interval )){
		SDFLOG_ERROR((B,"SFLOGSplitInterval value can modulo to 1440(1 day) only.(exp. 5,10,60(1 hour),360(6 hours))"))
		return -1;
	}
#endif
    READ_WARM_CONFIG("HousekeeperInterval",1,3600,wconf.housekeeper_interval)
    READ_WARM_CONFIG("RestartDelay",1,600,wconf.restart_delay)

    warm.curr = 0;
    if (SDF_config_find_element(&warm, "UserList", &tmp, NULL, 1) != 0)
    {
        SDF_config_free(cf);
        return -1;
    }
    while (1)
    {
        if (SDF_config_find_element(&tmp, "user", &tmp1, &xml, 0) != 0)
        {
            break;
        }
        dsu = (DSUSER *) SDF_MALLOC(sizeof(*dsu));
        if (SDF_config_find_attr(&xml, "name", dsu->name, sizeof(dsu->name), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        if (SDF_config_find_attr(&xml, "password", dsu->password, sizeof(dsu->password), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        LINKEDLIST_APPEND(d02global.ldapd->user_list, dsu);
    }


    warm.curr = 0;
    if (SDF_config_find_element_attr (&warm, "SDFDBFormat", "value", buff, sizeof(buff), 0) != 0)
    {
        wconf.sdfdb_format = LBER_DECODE_JSON;
    }
    else
    {
        if (strcasecmp(buff, "default")==0)
            wconf.sdfdb_format = LBER_DECODE_JSON;
        else if (strcasecmp(buff, "string")==0)
            wconf.sdfdb_format = LBER_DECODE_PRINTABLE_STRING;
        else if (strcasecmp(buff, "json")==0)
            wconf.sdfdb_format = LBER_DECODE_JSON;
        else if (strcasecmp(buff, "xml")==0)
            wconf.sdfdb_format = LBER_DECODE_XML;
    }
   
#ifdef GRPC

    warm.curr = 0;
    if (SDF_config_find_element_attr (&warm, "RoutingRule", "value", buff, sizeof(buff), 0) != 0)
    {
        wconf.sdfdb_format = LBER_DECODE_JSON;
    }
    else
    {
        if (strcasecmp(buff, "default")==0)
            wconf.sdfdb_format = LBER_DECODE_JSON;
        else if (strcasecmp(buff, "string")==0)
            wconf.sdfdb_format = LBER_DECODE_PRINTABLE_STRING;
        else if (strcasecmp(buff, "json")==0)
            wconf.sdfdb_format = LBER_DECODE_JSON;
        else if (strcasecmp(buff, "xml")==0)
            wconf.sdfdb_format = LBER_DECODE_XML;
    }
#endif   
    
    READ_WARM_CONFIG("SDFDBTimeToWait",1,600,wconf.sdfdb_time_to_wait)

    READ_WARM_CONFIG("DsReadTimeout",1,600,conf_value)
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_READ_TIMEOUT, conf_value);
    READ_WARM_CONFIG("DsWriteTimeout",1,600,conf_value)
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_WRITE_TIMEOUT, conf_value);
    READ_WARM_CONFIG("DsIdleTimeout",0,600,conf_value)
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_IDLE_TIMEOUT, conf_value);
    READ_WARM_CONFIG("DsMaxWriteLength",0,204800,conf_value)
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_MAX_WRITE_LENGHT, conf_value);

    int hi, lct, lwat, lrt, lwrt;
    READ_WARM_CONFIG("LdapConnectTimeout", 1, 600, lct)
    READ_WARM_CONFIG("LdapWaitTimeout",1, 600, lwat)
    READ_WARM_CONFIG("LdapReadTimeout", 1, 600, lrt)
    READ_WARM_CONFIG("LdapWriteTimeout", 1, 600, lwrt)
    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_NUMBER, hi);
        LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_CONNECT_TIMEOUT, lct);
        LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_WAIT_TIMEOUT, lwat);
        LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_READ_TIMEOUT, lrt);
        LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_WRITE_TIMEOUT, lwrt);
    }

    /* Get remote DSA */
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "DSBEList", "value", buff, sizeof(buff), 0) != 0){
        /* set to default */
        /* No scalling */
        wconf.scaleNumberDSA = 0;
    }else{
        char *token;
        wconf.scaleNumberDSA = 0;
        token=strtok(buff,",|");
        while(token != NULL){
            wconf.remoteDSA[wconf.scaleNumberDSA] = atoi(token);
            wconf.scaleNumberDSA++;
            token=strtok(NULL,",|");
        }
    }
    SDFLOG_DEBUG((B, "ScaleNumberDSA : %d",wconf.scaleNumberDSA))

    /* Set SLA Create Package */
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "CreationWindow", "value", buff, sizeof(buff), 0) != 0){
        /* set to default 200 seconds */
        wconf.sla_crt_pkg = 200;
    }else{
        wconf.sla_crt_pkg = atoi(buff);
        SDFLOG_DEBUG((B, "CreationWindow : %d s",wconf.sla_crt_pkg))
    }

    /* Set Package Control*/
    /*
     *  <LimitPackage value ="25"/>
     *  <MinPackage value = "4000" />
     *  <MaxPakcage value = "4096" />
     *  <SkipPackage value = "4096" />
     */
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "LimitPackage", "value", buff, sizeof(buff), 0) != 0){
        /* set to default 25 Packages */
        wconf.limit_package = 25;
    }else{
        wconf.limit_package = atoi(buff);
    }
    SDFLOG_DEBUG((B, "LimitPackage : %d", wconf.limit_package))

    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "MinPackage", "value", buff, sizeof(buff), 0) != 0){
        /* set to default begin at 4000 */
        wconf.min_package = 4000;
    }else{
        wconf.min_package = atoi(buff);
    }
    SDFLOG_DEBUG((B, "MinPackage : %d",wconf.min_package))

    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "MaxPackage", "value", buff, sizeof(buff), 0) != 0){
        /* set to default begin at 4096 */
        wconf.max_package = 4095;
    }else{
        wconf.max_package = atoi(buff);
    }
    SDFLOG_DEBUG((B, "MaxPackage : %d",wconf.max_package))

    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "SkipPackage", "value", buff, sizeof(buff), 0) != 0){
        /* set to default begin at 4096 */
        wconf.skip_pacakge[0] = 0;
        wconf.skip_len = 0;
    }else{
        char *token;
        wconf.skip_len = 0;
        token=strtok(buff,",|");
        while(token != NULL){
            wconf.skip_pacakge[wconf.skip_len] = atoi(token);
            wconf.skip_len++;
            token=strtok(NULL,",|");
        }
        /* Sortig skip package */
        qsort(&wconf.skip_pacakge, wconf.skip_len, sizeof(int), cmp_int);
    }
    SDFLOG_DEBUG((B, "SkipPackage : %d skip",wconf.skip_len))

    /* Verify config */
    if( wconf.max_package < wconf.min_package ){
        SDFLOG_FATAL((B, "MinPackage must more than MaxPackage"))
        return -1;
    }

    /* Set number of thread logger*/
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "ThreadLogMax", "value", buff, sizeof(buff), 0) != 0){
        /* set to default 1 thread */
        wconf.thread_log_max = 1;
    }else{
        wconf.thread_log_max = atoi(buff);
    }
    SDFLOG_INFO((B, "ThreadLogMax : %d threads", wconf.thread_log_max))

    /*
     * <Logger>
     *      <path value="/opt/damocles/log" />
     *      <filename value= "D01BIZ.log" />
     * <Logger>
     */

    /* Set path logger*/
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "LogPath", "value", buff, sizeof(buff), 0) != 0){
        wconf.log_path[0] = '\0';
    }else{
        strcpy( wconf.log_path, buff );
    }
    SDFLOG_INFO((B, "Path Log : %s", wconf.log_path))

    READ_WARM_CONFIG_OPT("LdapKeepAlive",0,86400,0,wconf.ldap_keepalive_interval)
    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_GROUP, group);
        if (wconf.ldap_keepalive_interval==0)
        {
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_TYPE, LDAP_KEEPALIVE_NONE);
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_INTERVAL, wconf.ldap_keepalive_interval);
        }
        else if (strcmp(group, LDAP_AMF_GROUP)==0)
        {
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_TYPE, LDAP_KEEPALIVE_EXTENDED);
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_INTERVAL, wconf.ldap_keepalive_interval);
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_OID, "0.0.0.0");
        }
        else
        {
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_TYPE, LDAP_KEEPALIVE_SEARCH);
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_INTERVAL, wconf.ldap_keepalive_interval);
            LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_KEEPALIVE_DN, "");
        }
    }

    READ_WARM_CONFIG("TPSLimit",1,1000000,wconf.tps_limit)
    READ_WARM_CONFIG("TPSWindow",1,1000,wconf.tps_window)

    READ_WARM_CONFIG("TransactionExpTime",1,1000,wconf.tim_dbl_expiry_time)    

    /* must be the last */
    warm.curr = 0;
    if (SDF_config_find_element_attr (&warm, "SFLOG", "value", buff, sizeof(buff), 1) != 0)
    {
        SDF_config_free (cf);
        return -1;
    }
    STRCPY(wconf.sflog_level,buff)
    if (SDF_set_level_string (wconf.sflog_level) < 0)
    {
        SDFLOG_ERROR((B,"Invalid attribute value=\"%s\" of element <%s>",wconf.sflog_level,"SFLOG"))
        SDF_config_free (cf);
        return -1;
    }

#ifdef SDFLOG_SPLIT
	char logDirectory[300];

	sprintf(buff, "%s.%s", MY_NAME, d02global.instance);
	strcpy(logDirectory, d02global.directory);
	strcat(logDirectory, "/log");
	SDF_log_init(buff, logDirectory, wconf.sflog_split_interval);
#endif


    SDFLOG_DEBUG((B, "Finding matching rule"))
    warm.curr = 0;
    wconf.matching_rule_count = 0;
    ret = SDF_config_find_element(&warm, "MatchingRule", &tmp, &xml, 0);
    if( ret == SDF_CONFIG_RET_OK ){
        char c_temp[32];
        MatchingRule *new_match = NULL;
        SDFLOG_INFO((B, "Enable Matching Rule"))

        strcpy(c_temp,"MSISDN");
        if ( config_matching_add_rule(wconf.matching_rule, &wconf.matching_rule_count, tmp, c_temp) == -1)
        {
            return -1;
        }
        strcpy(c_temp,"IMSI");
        if ( config_matching_add_rule(wconf.matching_rule, &wconf.matching_rule_count, tmp, c_temp) == -1)
        {
            return -1;
        }  
    }


    SDFLOG_DEBUG((B, "Finding Migration State Table"))
    int i;

    warm.curr = 0;
    ret = SDF_config_find_element(&warm, "MigrationState", &tmp, NULL, 0);
    if (ret == SDF_CONFIG_RET_ERROR)
    {
        SDF_config_free(cf);
        return -1;
    }
    else if (ret == SDF_CONFIG_RET_OK)
    {
        char state_str[32];
        char prefix[32];
        int entry_count = 0;
        MigrationState *new_table = NULL;
        if( create_migration_state(&new_table) != 0 ){
            SDF_config_free(cf);
            SDFLOG_DEBUG((B, "create_migration_state error"))
            return -1;
        }

        SDFLOG_DEBUG((B, "Initialize state list", i+DOING_STATE))
        for (i=0; i<MIGRATION_STATE_NUM; i++)
        {
            new_table->list[i] = malloc(MIGRATION_STATE_NAME_LEN_MAX);
            sprintf(new_table->list[i], "%d", i+DOING_STATE);
        }

        while (1)
        {
            ret = SDF_config_find_element(&tmp, "prefix", &tmp1, &xml, 0);
            if( ret != SDF_CONFIG_RET_OK)
            {
                break;
            }

            if (SDF_config_find_attr(&xml, "value", prefix, sizeof(prefix), 1) !=0 )
            {
                SDF_config_free(cf);
                SDFLOG_DEBUG((B, "SDF_config_find_attr [value]"))
                return -1;
            }

            if (SDF_config_find_attr(&xml, "state", state_str, sizeof(state_str), 1) !=0 )
            {
                SDF_config_free(cf);
                SDFLOG_DEBUG((B, "SDF_config_find_attr [cluster]"))
                return -1;
            }

            if(new_table->trie == NULL)
            {
                new_table->trie = trie_new();
            }

            SDFLOG_DEBUG((B, "Adding MigrationState value[%s] State[%s]", prefix, state_str))

            if(strlen(prefix) == 0)
            {
                SDFLOG_ERROR((B, "Prefix must not be empty"))
                return -1;
            }

            char *t_chr;
            strtoul(prefix, &t_chr, 10);
            if(*t_chr)
            {
                SDFLOG_ERROR((B, "Prefix contains non-numeric"))
                return -1;
            }

            if(strlen(state_str) == 0)
            {
                SDFLOG_ERROR((B, "State name must not be empty"))
                return -1;
            }

            int index;
            MIG_STATE_NAME2INDEX(state_str,index)
            SDFLOG_DEBUG((B, "index [%d %s %x]", index , new_table->list[index], new_table->list[index][0]))
            ret = trie_insert_binary(new_table->trie, (unsigned char*)prefix, strlen(prefix), new_table->list[index]);
            if(ret == -1)
            { 
                SDFLOG_ERROR((B, "Prefix already exists in table prefix[%s] state[%s]", prefix, state_str))
                return -1;
            }
            new_table->entry_count = ++entry_count;
        }

        wconf.migration_state = new_table;
    }
    else
    {
        wconf.migration_state = NULL;
    }

#ifdef GRPC        
    /* Get MigrationMode */
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "MigrationMode", "value", buff, sizeof(buff), 0) != 0){
        wconf.migration_mode = DS4_MODE;
    }else{
        if( STRCASEEQ(buff, "DS4") ){
            wconf.migration_mode = DS4_MODE;
        }else if( STRCASEEQ(buff, "DS3") ){
            wconf.migration_mode = DS3_MODE;
        }else if( STRCASEEQ(buff, "MIG") ){
            wconf.migration_mode = MIG_MODE;
        }else{
            SDFLOG_DEBUG((B, "Unsupported migration mode[%s]", buff))
            SDF_config_free(cf);
            return -1;    
        }
    }
    SDFLOG_DEBUG((B, "MigrationMode : %s", buff))


    //--------------------------------------
    warm.curr = 0;
    if(SDF_config_find_element_attr (&warm, "DefaultIdentAddTarget", "value", buff, sizeof(buff), 0) != 0){
        wconf.default_ident_add_target = DS4_MODE;
    }else{
        if( STRCASEEQ(buff, "DS4") ){
            wconf.default_ident_add_target = DS4_MODE;
        }else if( STRCASEEQ(buff, "DS3") ){
            wconf.default_ident_add_target = DS3_MODE;
        }else{
            SDFLOG_DEBUG((B, "Unsupported migration mode[%s]", buff))
            SDF_config_free(cf);
            return -1;    
        }
    }
    SDFLOG_DEBUG((B, "MigrationMode : %s", buff))

    

    //!-------HEARTBEAT----------
    warm.curr = 0;
    wconf.heartbeat_type = 0;
    if (SDF_config_find_element(&warm, "LdapHeartBeatService", &tmp, &xml, 0) == 0)
    {
        if (SDF_config_find_attr(&xml, "type", buff, sizeof(buff), 1) != 0)
        {
            SDF_config_free(cf);
            return -1;
        }
        else
        {
            wconf.heartbeat_type = 0;

            if (strcmp("search", buff) == 0)
            {
                wconf.heartbeat_type = 1;
            }
            else if (strcmp("extend", buff) == 0)
            {
                wconf.heartbeat_type = 2;
            }

            if (SDF_config_find_attr(&xml, "interval", buff, sizeof(buff), 1) != 0)
            {
                SDF_config_free(cf);
                return -1;
            }
            int n = 0;
            if (get_int(buff, &n) != 0)
            {
                SDFLOG_FATAL((B, "Invalid attribute interval=\"%s\" of element <LdapHeartBeat>", buff))
                SDF_config_free(cf);
                return -1;
            }

            SDFLOG_DEBUG((B, "Heartbeat Interval %d ", n));
            wconf.hearthbeat_interval = n;

            //!--Search
            if (wconf.heartbeat_type == 1)
            {
                if (SDF_config_find_attr(&xml, "dn", wconf.heartbeat_dn, sizeof(wconf.heartbeat_dn), 1) != 0)
                {
                    SDF_config_free(cf);
                    return -1;
                }
                if (SDF_config_find_attr(&xml, "scope", wconf.heartbeat_scope, sizeof(wconf.heartbeat_scope), 1) != 0)
                {
                    SDF_config_free(cf);
                    return -1;
                }
                if (SDF_config_find_attr(&xml, "object", wconf.heartbeat_object, sizeof(wconf.heartbeat_object), 1) != 0)
                {
                    SDF_config_free(cf);
                    return -1;
                }
            }
            //!--Extend
            else if (wconf.heartbeat_type == 2)
            {
                if (SDF_config_find_attr(&xml, "oid", wconf.heartbeat_oid, sizeof(wconf.heartbeat_oid), 1) != 0)
                {
                    SDF_config_free(cf);
                    return -1;
                }
            }
        }
    }else{
        wconf.heartbeat_type = -1;
        wconf.heartbeat_oid[0] = 0;
        SDFLOG_WARN((B, "Disable Heartbeat Service"));
    }
    //!-------HEARTBEAT----------

#endif
    d02global.conf_warm = wconf;
    return 0;
}


int config_load_common(){
    static char func[] = "config_load_common";
    char buff[1024], dis[10], dis1[10];
    SDF_CONFIG_MEM *cc, *cf, cold,  ds2a, ds2c, tmp, tmp1, conf, adaptive_naming, attribute_value, adaptive_naming_dn, variant_dn, quorumsearch;
    SDF_XML xml;
    GLOBAL_APP_CONF app_conf;
    GLOBAL_CONF global_conf;
    int  ret;

    // Common Configuration
    cc = SDF_config_load_file(d02global.common_config);
    if (cc == NULL) return -1;

    if (SDF_config_find_element(cc, "configuration", &conf, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    if (SDF_config_find_element(&conf, "ds2a", &ds2a, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    ds2a.curr = 0;
    if (SDF_config_find_element(&ds2a, "value-mapping", &tmp, &xml, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    /* initialize database */
    HMAP_DB *my_hmap_db         = NULL;  
    HMAP_DB *my_invert_hmap_db  = NULL;
    hmap_init(1024, &my_hmap_db);

    // all mapping
    char name[1024];
    char value[1024];
    tmp.curr = 0;

    while(1){
        ret = SDF_config_find_element(&tmp, "key", NULL, &xml, 0);
        if( ret != SDF_CONFIG_RET_OK)
            break;
        
        if (SDF_config_find_attr(&xml, "name", name, sizeof(name), 1) !=0 )
        {
            SDF_config_free(cc);
            return -1;
        }
        
        if (SDF_config_find_attr(&xml, "value", value, sizeof(value), 1) !=0 )
        {
            SDF_config_free(cc);
            return -1;
        }
        
        SDFLOG_DEBUG((B, "key name=\"%s\" value=\"%s\"", name, value))
        if( hmap_add(&my_hmap_db, name, strlen(name), 1, HMAP_DATA_TYPE_INT, atoi(value), 0) < 0 ){
            SDFLOG_ERROR((B, "Cannot store  : [%s]", name))
            return -1;
        } 

    }
    app_conf.ds2a.map = my_hmap_db;

    conf.curr = 0;
    if (SDF_config_find_element(&conf, "ds2c", &ds2c, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    if(SDF_config_find_element_attr (&ds2c, "MaxSessionInfo", "value", buff, sizeof(buff), 0) != 0){
        /* set to default begin at 25 */
        app_conf.ds2c.max_sesssion_info = 25;
    }else{
        app_conf.ds2c.max_sesssion_info = atoi(buff);
    }
    SDFLOG_DEBUG((B, "ds3c max session info     : %d", app_conf.ds2c.max_sesssion_info ))

    conf.curr = 0;
    if (SDF_config_find_element(&conf, "DS4", &tmp, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    tmp.curr = 0;
    if (SDF_config_find_element(&tmp, "attribute-adaptation", &adaptive_naming, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    /* initialize database */
    my_hmap_db          = NULL;  
    my_invert_hmap_db   = NULL; 
    hmap_init(1024, &my_hmap_db);
    hmap_init(1024, &my_invert_hmap_db);

    while(1){
        ret = SDF_config_find_element(&adaptive_naming, "attr", NULL, &xml, 0);
        if( ret != SDF_CONFIG_RET_OK)
            break;
        
        if (SDF_config_find_attr(&xml, "name", name, sizeof(name), 1) !=0 )
        {
            SDF_config_free(cc);
            return -1;
        }
        
        if (SDF_config_find_attr(&xml, "value", value, sizeof(value), 1) !=0 )
        {
            SDF_config_free(cc);
            return -1;
        }
        
        SDFLOG_DEBUG((B, "attr name=\"%s\" value=\"%s\"", name, value))
        if( hmap_add(&my_hmap_db, name, strlen(name), 1, HMAP_DATA_TYPE_CHARS, value, strlen(value)) < 0 ){
            SDFLOG_ERROR((B, "Cannot store  : [%s]", name))
            return -1;
        } 
        if( hmap_add(&my_invert_hmap_db, value, strlen(value), 1, HMAP_DATA_TYPE_CHARS, name, strlen(name)) < 0 ){
            SDFLOG_ERROR((B, "Cannot store(invert adaptive naming) : [%s]", name))
            return -1;
        } 

    }

    global_conf.adaptive_naming         = my_hmap_db;
    global_conf.invert_adaptive_naming  = my_invert_hmap_db;


    //----GRPC-GET-REQUEST-TYPE----//
    SDFLOG_INFO((B, "GRPC GET REQUEST TYPE"));
    char nameRequest[LDAP_MAX_DN_SIZE];
    char valueRequest[LDAP_MAX_DN_SIZE];
    tmp.curr = 0;
    ret = SDF_config_find_element(&tmp, "QuorumSearch", &quorumsearch, NULL, 0);
    if ( ret == SDF_CONFIG_RET_OK ){
        while(1){
            ret = SDF_config_find_element(&quorumsearch, "TARGET", NULL, &xml, 0);
            if( ret != SDF_CONFIG_RET_OK ){
                break;
            }
            if ( ret == SDF_CONFIG_RET_OK ){

                if ( SDF_config_find_attr(&xml, "name", nameRequest, sizeof(nameRequest), 1) !=0 ){
                    SDF_config_free(cc);
                    return -1;
                }

                if (strcasecmp(nameRequest, "D20") == 0){
                    if (SDF_config_find_attr(&xml, "value", valueRequest, sizeof(valueRequest), 0) !=0){
                        global_conf.get_type.d20_get_type = TYPE_QGET;
                        SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d20_get_type))
                    }else{
                        SDFLOG_INFO((B, "Value Type [%s]",valueRequest))
                        if(strcasecmp(valueRequest, "default") == 0){
                            global_conf.get_type.d20_get_type = TYPE_QGET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d20_get_type))
                        }
                        else if(strcasecmp(valueRequest, "GET") == 0){
                            global_conf.get_type.d20_get_type = TYPE_GET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d20_get_type))
                        }
                        else if(strcasecmp(valueRequest, "QGET") == 0){
                            global_conf.get_type.d20_get_type = TYPE_QGET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d20_get_type))
                        }
                        else{
                            SDFLOG_DEBUG((B, "Unsupported request type [%s]", valueRequest))
                            SDF_config_free(cc);
                            return -1;
                        }
                    }
                }
                else if (strcasecmp(nameRequest, "D21") == 0){
                    if (SDF_config_find_attr(&xml, "value", valueRequest, sizeof(valueRequest), 0) !=0){
                        global_conf.get_type.d21_get_type = TYPE_QGET;
                        SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d21_get_type))
                    }else{
                        SDFLOG_INFO((B, "Value Type [%s]",valueRequest))
                        if(strcasecmp(valueRequest, "default") == 0){
                            global_conf.get_type.d21_get_type = TYPE_QGET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d21_get_type))
                        }
                        else if(strcasecmp(valueRequest, "GET") == 0){
                            global_conf.get_type.d21_get_type = TYPE_GET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d21_get_type))
                        }
                        else if(strcasecmp(valueRequest, "QGET") == 0){
                            global_conf.get_type.d21_get_type = TYPE_QGET;
                            SDFLOG_INFO((B, "name request : [%s] value request : [%s=%d]", nameRequest, valueRequest, global_conf.get_type.d21_get_type))
                        }
                        else{
                            SDFLOG_DEBUG((B, "Unsupported request type [%s]", valueRequest))
                            SDF_config_free(cc);
                            return -1;
                        }
                    }
                }
                else{
                    SDFLOG_DEBUG((B, "Unsupported request name [%s]", nameRequest))
                }
            }
        }
    }
    else{
        global_conf.get_type.d20_get_type = TYPE_QGET;
        global_conf.get_type.d21_get_type = TYPE_QGET;
    }


    //----Adaptive-Naming-DN----//
    my_hmap_db          = NULL;   
    hmap_init(1024, &my_hmap_db);
    char matchDN[LDAP_MAX_DN_SIZE];
    char mapDN[LDAP_MAX_DN_SIZE];
    char keyDN[LDAP_MAX_DN_SIZE*2];
    HMAP_DB *db;
    TUPLE *ptr_tuple = NULL;
    tmp.curr = 0;
    SDFLOG_INFO((B, "Initialize adaptive naming dn"));
    ret = SDF_config_find_element(&tmp, "adaptive-naming-dn", &adaptive_naming_dn, NULL, 1);
    if ( ret == SDF_CONFIG_RET_OK ){ //if--->adaptive-naming-dn
        while(1){  

            ret = SDF_config_find_element(&adaptive_naming_dn, "user", &tmp1, &xml, 0);
            if( ret != SDF_CONFIG_RET_OK){
                break;
            }
            
            if( ret == SDF_CONFIG_RET_OK){ //if--->user
                if (SDF_config_find_attr(&xml, "name", name, sizeof(name), 1) !=0 ){
                    SDF_config_free(cc);
                    return -1;
                }
                SDFLOG_INFO((B, "name : [%s]", name))

                tmp1.curr = 0;
                while(1){
                    ret = SDF_config_find_element(&tmp1, "adapName", NULL, &xml, 0);
                    if( ret != SDF_CONFIG_RET_OK)
                        break;

                    if (SDF_config_find_attr(&xml, "matchDN", matchDN, sizeof(matchDN), 1) !=0 ){
                        SDF_config_free(cc);
                        return -1;
                    }
    
                    if (SDF_config_find_attr(&xml, "mapDN", mapDN, sizeof(mapDN), 1) !=0 )
                    {
                        SDF_config_free(cc);
                        return -1;
                    }

                    sprintf(keyDN,"%s:%s",name,matchDN);
                    SDFLOG_DEBUG((B, "keyDN : %s", keyDN));
                    lower_string(keyDN);
                    remove_Space(keyDN);
                    if( hmap_add(&my_hmap_db, keyDN, strlen(keyDN), 1, HMAP_DATA_TYPE_CHARS, mapDN, strlen(mapDN)) < 0 ){
                        SDFLOG_ERROR((B, "Cannot store  : [matchDN already exists for user : %s]",name))
                        return -1;
                    }
                }
            }
        } 
        global_conf.adaptive_naming_dn = my_hmap_db;
    }

    tmp.curr = 0;
    if (SDF_config_find_element(&tmp, "attributeValue-mapping", &attribute_value, NULL, 1) != 0)
    {
        SDF_config_free(cc);
        return -1;
    }

    /* initialize database */
    my_hmap_db          = NULL;  
    ret = hmap_init(1024, &my_hmap_db);
    SDFLOG_ERROR((B, "hmap_init ret = %d", ret))

    char input[1024];
    int  data_type;
    int  display;
    int  format;
    char *tmp_res;


    while(1){
        ret = SDF_config_find_element(&attribute_value, "attr", NULL, &xml, 0);
        if( ret != SDF_CONFIG_RET_OK)
            break;
        
        if (SDF_config_find_attr(&xml, "name", name, sizeof(name), 1) < SDF_CONFIG_RET_OK )
        {
            SDF_config_free(cc);
            return -1;
        }
        
        if (SDF_config_find_attr(&xml, "value", value, sizeof(value), 0) < SDF_CONFIG_RET_OK )
        {
            SDF_config_free(cc);
            return -1;
        }

        if (SDF_config_find_attr(&xml, "type", input, sizeof(input), 1) < SDF_CONFIG_RET_OK )
        {
            SDF_config_free(cc);
            return -1;
        }
        data_type = strtol(input,&tmp_res,10);
        if (*tmp_res) return -1;

        if (SDF_config_find_attr(&xml, "display", input, sizeof(input), 0) < SDF_CONFIG_RET_OK )
        {
            SDF_config_free(cc);
            return -1;
        }
        display = strtol(input,&tmp_res,10);
        if (*tmp_res) return -1;

        if (SDF_config_find_attr(&xml, "format", input, sizeof(input), 0) < SDF_CONFIG_RET_OK )
        {
            SDF_config_free(cc);
            return -1;
        }
        format = strtol(input,&tmp_res,10);
        if (*tmp_res) return -1;

        data_type = HMAP_SET_DATA_TYPE(data_type, display, format);
        
        SDFLOG_DEBUG((B, "attr name=\"%s\" value=\"%s\" data_type=\"%X\"", name, value, data_type))
        if( (ret = hmap_add(&my_hmap_db, name, strlen(name), 1, data_type, atoi(value), 0)) < 0 ){
            SDFLOG_ERROR((B, "Cannot store  : [%s]  ret = %d  data_type  %d", name, ret, HMAP_GET_DATA_TYPE(data_type)))
            return -1;
        } 

    }
    global_conf.attributevalue_mapping = my_hmap_db;

    /* initialize database */
    SDFLOG_DEBUG((B, "Loading variant configuration"))
    conf.curr = 0;
    if (SDF_config_find_element(&conf, "variant", &variant_dn, NULL, 0) == SDF_CONFIG_RET_ERROR)
    {
        SDF_config_free(cc);
        return -1;
    }

    my_hmap_db          = NULL;  
    ret = hmap_init(1024, &my_hmap_db);
    if (ret != HMAP_SUCCESS)
    {
        SDFLOG_ERROR((B, "hmap_init ret = %d", ret))
        return -1;
    }

    char v_dn[1024];
    char v_objClass[1024];
    char r_dn[1024];
    char r_objClass[1024];
    char srcName[1024];
    char dstAlias[1024];
    BER_VALLIST *vallist;
    BER_ATTRLIST_OBJ *redirect_list;
    PAIR_VALUE_LIST *pairlist;

    variant_dn.curr = 0;
    while(1){
        // SDFLOG_DEBUG((B, "Looking for next object"))
        ret = SDF_config_find_element(&variant_dn, "variantDN", &tmp, &xml, 0);
        if( ret != SDF_CONFIG_RET_OK)
        {
            // SDFLOG_WARN((B, "Cannot find any variant dn object in config"))
            // SDF_config_free(cc);
            // return -1;
            break;
        }
        // SDFLOG_DEBUG((B, "variant object found"))

        if (SDF_config_find_attr(&xml, "dn", v_dn, sizeof(v_dn), 1) < SDF_CONFIG_RET_OK )
        {
            SDFLOG_DEBUG((B, "v_dn fail"))
            SDF_config_free(cc);
            return -1;
        }
        SDFLOG_DEBUG((B, "variantDN [%s]", v_dn))

        // if (SDF_config_find_attr(&xml, "objClass", v_objClass, sizeof(v_objClass), 1) < SDF_CONFIG_RET_OK )
        // {
        //     SDFLOG_DEBUG((B, "v_objClass fail"))
        //     SDF_config_free(cc);
        //     return -1;
        // }
        // SDFLOG_DEBUG((B, "v_objClass [%s]", v_objClass))

        tmp.curr = 0;
        redirect_list = NULL;
        while(1)
        {
            if (SDF_config_find_element(&tmp, "variantSpec", &tmp1, &xml, 0) != SDF_CONFIG_RET_OK)
            {
                // SDF_config_free(cf);
                // return -1;
                // SDFLOG_DEBUG((B, "No more redirect"))
                break;
            }
            // SDFLOG_DEBUG((B, "redirect found"))

            if (SDF_config_find_attr(&xml, "dn", r_dn, sizeof(r_dn), 0) != 0)
            {
                SDFLOG_DEBUG((B, "r_dn fail"))
                SDF_config_free(cf);
                return -1;
            }
            // SDFLOG_DEBUG((B, "r_dn [%s]", r_dn))

            if (SDF_config_find_attr(&xml, "objClass", r_objClass, sizeof(r_objClass), 1) < SDF_CONFIG_RET_OK )
            {
                SDFLOG_DEBUG((B, "r_objClass fail"))
                SDF_config_free(cc);
                return -1;
            }
            SDFLOG_DEBUG((B, "   variantSpec dn [%s]   objClass [%s]", r_dn, r_objClass))

            vallist = NULL;
            LBER_valuelist_add(&vallist, r_objClass, NULL);
            pairlist = NULL;
            while(1)
            {
                if (SDF_config_find_element(&tmp1, "attribute", NULL, &xml, 0) != SDF_CONFIG_RET_OK)
                {
                    // SDF_config_free(cf);
                    // return -1;
                    // SDFLOG_DEBUG((B, "No more attribute"))
                    break;
                }
                // SDFLOG_DEBUG((B, "attribute found"))


                if (SDF_config_find_attr(&xml, "srcName", srcName, sizeof(srcName), 0) != 0)
                {
                    SDFLOG_DEBUG((B, "srcName fail"))
                    SDF_config_free(cf);
                    return -1;
                }
                // SDFLOG_DEBUG((B, "srcName [%s]", srcName))

                if (SDF_config_find_attr(&xml, "dstAlias", dstAlias, sizeof(dstAlias), 0) != 0)
                {
                    SDFLOG_DEBUG((B, "dstAlias fail"))
                    SDF_config_free(cf);
                    return -1;
                }
                SDFLOG_DEBUG((B, "          srcName [%s]    dstAlias [%s]", srcName, dstAlias))
                pair_list_add(&pairlist, srcName, dstAlias, NULL);
            }
            LBER_attrlist_obj_add(&redirect_list, r_dn, vallist, pairlist, NULL);
        }
        lower_string(v_dn);
        if( hmap_add(&my_hmap_db, v_dn, strlen(v_dn), 1, HMAP_DATA_TYPE_CUSTOM, redirect_list, 0) < 0 ){
            SDFLOG_ERROR((B, "Cannot store  : [%s]", name))
            return -1;
        }
    }

    global_conf.variant_db = my_hmap_db;
    d02global.global_conf = global_conf;
    d02global.app_conf = app_conf;
    SDF_config_free(cc);
    return 0;
}


#ifdef STAT_RESET
static int stat_reset()
{
	static char func[] = "stat_reset";
    int hi = 0;
	SDFLOG_DEBUG((B, "Reset stats value."))
    
	d02global.sdfdb_purge_count = 0;
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_SENT_COUNT, 0);
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_RECV_COUNT, 0);
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_BUSY_COUNT, 0);
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_ERROR_COUNT, 0);
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_AVG_RESPONSE, 0);
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_MAX_RESPONSE, 0),
    LDAP_svr_set_option(d02global.ldapd, LDAP_SERV_OPTION_MIN_RESPONSE, 0);

    // reset method
    d02global.MMID_count = 0;
    d02global.MCPKG_count = 0;
    d02global.MCPRF_count = 0;
    d02global.MMNM_count = 0;
    
    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_SENT_COUNT, 0);
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_RECV_COUNT, 0);
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_ERROR_COUNT, 0);
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_MAX_RESPONSE, 0);
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_AVG_RESPONSE, 0);
         LDAP_clnt_set_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_MIN_RESPONSE, 0);
    }
    
	d02global.stat_reset_time = time(NULL);
    d02global.ldapd->total_response_time = 0;
	return 0;
}
#endif

static int
stat_gen()
{
	static char func[] = "stat_gen";
#ifndef STAT_RESET
	static int pday = -1;
#endif

	char buff[128*1024];
    char host[LDAP_MAX_STRING_HOST];
	int fd, i, r, hi;
	struct tm tm;
	time_t ct;

	ct = time (NULL);
	tm = *localtime(&ct);
	sprintf (buff, "%s/stat/%s.%s_%04d%02d%02d.stat", d02global.directory, MY_NAME, d02global.instance, 1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday);
	fd = open (buff, O_RDWR|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
	if (fd < 0)
	{
		SDFLOG_ERROR((B, "open [%s] return error [%s]", buff, strerror(errno)))
		return -1;
	}
#ifndef STAT_RESET
	// Reset accumulating counters
	if (pday!=tm.tm_mday)
	{
        stat_reset();
        pday = tm.tm_mday;
	}
#endif
	i = sprintf(buff, "\n\n%04d-%02d-%02d %02d:%02d:%02d\n", 1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);

	i += sprintf(&buff[i], "FMONProcessID=%d\nFMONUpSince=%s\nFMONFaultCount=%lu\nSharedMemID=%d\n",
                 d02global.fmon_pid,
                 time_to_string(d02global.fmon_start),
                 d02global.fmon_fault_count,
                 d02global.shm_id);

	i += sprintf(&buff[i], "MainProcessID=%d\nMainUpSince=%s\n",
                 d02global.main_pid,
                 time_to_string(d02global.main_start));

	i += sprintf(&buff[i], "ControlPause=%s\nMessagePause=%s\nShutdown=%s\n",
                 ((d02global.control_pause)? "YES" : "NO"),
                 ((d02global.msg_count_pause)? "YES" : "NO"),
                 ((d02global.shutdown)? "YES" : "NO"));

    i += sprintf(&buff[i], "DbQueueCount=%lu\nPurgeMessageCount=%lu\n",
                 d02global.sdfdb_count,
                 d02global.sdfdb_purge_count);

    i += sprintf(&buff[i], "LdapSessionCount=%d\nLdapRecvMessageCount=%d\n"
                "LdapSearchCount=%d\nLdapAddCount=%d\nLdapModifyCount=%d\nLdapModifydnCount=%d\nLdapDeleteCount=%d\n"
                "[Extended]\n  DS2A=%d\n  DS2C=%d\n  StartTransaction=%d\n  EndTransaction=%d\n"
                "LdapSentMessageCount=%d\n"
                "LdapBusyMessageCount=%d\n"
                "LdapErrorMessageCount=%d\nLdapMaxResponseTime=%d\nLdapAvgResponseTime=%d\nLdapMinResponseTime=%d\n",
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_SESSION_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_RECV_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_SEARCH_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_ADD_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_MODIFY_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_MODIFYDN_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_DELETE_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_DS2A_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_DS2C_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_STARTTRANSACTION_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_ENDTRANSACTION_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_SENT_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_BUSY_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_ERROR_COUNT, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_MAX_RESPONSE, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_AVG_RESPONSE, NULL),
                LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_MIN_RESPONSE, NULL));

    i += sprintf(&buff[i], "CdrQueueCount=%d\n", sdf_buffer.occupied);
    i += sprintf(&buff[i], "[Cluster Queue]\n");
    for( hi = 0; hi < d02global.http2_service_count; hi++){
        HTTP2_SERVICE *service = HTTP2_SERVICES[hi];
        int c = 0;
        for(c = 0; c < service->cluster_count; c++){
            HTTP2_CLUSTER *cluster = service->clusters[c];
            i += sprintf(&buff[i], " - Queued=%d\n", cluster->send_msg_queue_count);
        }
    }


    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_HOST, host);

        i += sprintf(&buff[i], "===== ldap://%s:%d =====\n",
                     host, LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_PORT, NULL));

        i += sprintf(&buff[i], "LdapClientCount=%d\nLdapQueueCount=%d\nLdapSentCount=%d\n"
                     "LdapRecvCount=%d\nLdapErrorCount=%d\n"
                     "LdapMaxResponseTime=%d\n"
                     "LdapAvgResponseTime=%d\n"
                     "LdapMinResponseTime=%d\n",
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_CLIENT_COUNT, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_QUEUE_COUNT, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_SENT_COUNT, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_RECV_COUNT, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_ERROR_COUNT, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_MAX_RESPONSE, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_AVG_RESPONSE, NULL),
                     LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_MIN_RESPONSE, NULL)
                     );
    }
    
#ifdef SYNC_DMCD
    if( d02global.cluster_group != NULL ){
        TUPLE *list_cluster         = d02global.cluster_group->list_tuple;
        CLUSTER *t_cluster          = NULL;
        CONN_PROPERTY * t_d21conn   = NULL;
        for ( hi = 0; list_cluster != NULL; hi++){
            t_cluster = (CLUSTER *) list_cluster->data;
            i += sprintf(&buff[i], "Cluster=%s\n", list_cluster->key);
            t_d21conn = t_cluster->conn_d21;
            while( t_d21conn ){
                i += sprintf(&buff[i], " d21=%s:%d", t_d21conn->host, t_d21conn->port);
                t_d21conn = t_d21conn->next;
                if(t_d21conn == t_cluster->conn_d21){
                    break;
                }
            }
            list_cluster = list_cluster->next;
            if( list_cluster == d02global.cluster_group->list_tuple ){
                break;
            }
        }
    }
#endif   

	buff[i++] = '\n';   /* add ending newline */
	r = (int) write(fd, buff, i);
	if (r < 0)
	{
		SDFLOG_ERROR((B, "write return error [%s]", strerror(errno)))
		close(fd);
		return -1;
	}
	if (r != i)
	{
		SDFLOG_ERROR((B, "write return (%d), expected (%d)", r, i))
		close(fd);
		return -1;
	}
	if (close (fd) != 0)
	{
		SDFLOG_ERROR((B, "close return error [%s]", strerror(errno)))
		close(fd);
		return -1;
	}
	return 0;
}

int rb_init(RING_BUFFER *rbff, int slot_size){
static char func[] = "rb_init";
    int i = 0;

    if( rbff == NULL ){
        SDFLOG_ERROR((B, "rbff is null"))
        return -1;
    }
    rbff->slot_size = slot_size;
    rbff->idx_rcv = 0;
    rbff->idx_snd = 0;
    rbff->occupied = 0;
    rbff->buffer = calloc( slot_size, sizeof( SDF_BUFFER *) );
    for(; i < slot_size; i++){
        rbff->buffer[i] = calloc( 1, ( sizeof(SDF_BUFFER)+ BUFFER_SIZE) );
        rbff->buffer[i]->size = BUFFER_SIZE;
        rbff->buffer[i]->len = 0;
    }
    return 0;
}

#ifdef GRPC

static int http2_query_registry_requst( char *error){
    static char func[] = "http2_query_registry_requst";
    GRPC_BUFFER *data       = NULL;
        
    if( d02global.D11_instance == NULL){
        d02global.D11_instance = (AFINSTANCE *) SDF_MALLOC (sizeof(AFINSTANCE));
        memset (d02global.D11_instance, 0, sizeof(AFINSTANCE));
        strcpy(d02global.D11_instance->cluster, D11_DEFAULT_CLUSTER);
    }else{
         return 0;
    }
    
    if ( GRPC_get_etcd_range_request(&data, (unsigned char *)"damocles_", sizeof("damocles_")-1, (unsigned char *)"damocles`", sizeof("damocles`")-1, error) != GRPC_RET_OK  ){
        return -1;
    }
    SDFLOG_DEBUG((B, "query service registry"))
    USE_RPC_SERVICE(d02global.D11_instance, "D11", GRPC_ETCD_RANGE_REQUEST, RESTFUL_COMMAND_SEARCH);
    if (data != NULL && http2_send_msg_to_queue(d02global.D11_instance, data) != 0 ){
        return -1;
    }
    
    d02global.D11_instance->state = D11_STATE_IDLE;
    
    return 0;
}

static int http2_watch_registry_requst( char *error){
    static char func[] = "http2_watch_registry_requst";
    GRPC_BUFFER *data       = NULL;
        
    if( d02global.D11_instance == NULL){
        return 0;
    }
    
    if( d02global.D11_instance->state == D11_STATE_QUERY_REQUEST )
    {

        if ( GRPC_get_etcd_watch_request(&data, (unsigned char *)"damocles_", sizeof("damocles_")-1, (unsigned char *)"damocles`", sizeof("damocles`")-1, error) != GRPC_RET_OK  ){
            return -1;
        }
        SDFLOG_DEBUG((B, "watch service registry"))
        USE_RPC_SERVICE(d02global.D11_instance, "D11", GRPC_ETCD_WATCH_REQUEST, RESTFUL_COMMAND_SEARCH);
        if (data != NULL && http2_send_msg_to_queue(d02global.D11_instance, data) != 0 ){
            return -1;
        }

        d02global.D11_instance->state = D11_STATE_WATCH_REQUEST;
    }
    
    return 0;
}

int update_connection( char *key, char *value){
    static char func[] = "update_connection";
#define has_next(_ch) do{   \
	p = pp;					\
	pp = strchr(p, _ch);	\
	if (pp == NULL)  break;	\
	memcpy(b, p, pp-p);		\
	b[pp-p]	 = 0;			\
	pp++;					\
}while(0)
	char *p   = NULL;	
	char *pp  = NULL;
	char b[4096];
    char group[1024];
    char host[1024];
    char cluster_name[1024];
    char node_name[1024];
    char key_name[1024];
    unsigned long cluster_id;
    unsigned long node_id;
    HTTP2_CLUSTER *cluster = NULL;
    HTTP2_SERVICE *service = NULL;
    HTTP2_NODE  *node      = NULL;
    int i           = 0;
    int key_len     = 0;
    int state       = 0;
    int port        = 0;
    SDFLOG_DEBUG((B, "Query key : %s", key))
    //damocles_d20_cluster_5c8f6b17c7dbdad6_node_193b7109e2e90a33_status
	pp = strchr(key, '_'); // Ignore damocles key
	pp++; // Skipe '_'

	has_next('_');
	SDFLOG_DEBUG((B, "group :%s", b))
    strcpy(group, b);
    
	has_next('_');  //cluster
	has_next('_');  //5c8f6b17c7dbdad6
	SDFLOG_DEBUG((B, "clusterID :%s", b))
    strcpy(cluster_name, b);
    cluster_id = (unsigned long)strtoul(b, NULL, 16);
    
	has_next('_');  //node
	has_next('_');  //193b7109e2e90a33
	SDFLOG_DEBUG((B,"nodeID:%s", b))	
    strcpy(node_name, b);	
    node_id = (unsigned long)strtoul(b, NULL, 16);
    
    key_len = (pp-key);
    memcpy(key_name, key, key_len);//damocles_d20_cluster_5c8f6b17c7dbdad6_node_193b7109e2e90a33_
    key_name[key_len] = 0;
    
    // Find existing service.
    for( i = 0; i < d02global.http2_service_count; i++){
       SDFLOG_DEBUG((B, "Checking avialable service[%s] == [%s]",HTTP2_SERVICES[i]->name, group))
      if( HTTP2_SERVICES[i] != NULL && STRCASEEQ( HTTP2_SERVICES[i]->name, group) ){
           service = HTTP2_SERVICES[i];
           break;
       }
    }
    
    if( service == NULL ){
        SDFLOG_ERROR((B, "No existing service"))
        return -1;
    }
    
    // Find existing cluster.
    for(i = 0; i < service->cluster_count; i++){
        SDFLOG_DEBUG((B, "Checking avialable clusterID [%lu] == [%lu]", service->clusters[i]->cluster_id, cluster_id))
        if( service->clusters[i] != NULL && service->clusters[i]->cluster_id == cluster_id ) {
            cluster = service->clusters[i];
            break;
        }
    }
    
    if(cluster == NULL){
        SDFLOG_ERROR((B, "No existing cluster"))
        return -1;
    }

    // Find existing node(member).
    for(i = 0; i < cluster->node_count; i++){
        SDFLOG_DEBUG((B, "Checking avialable memberID [%lu] == [%lu]", cluster->nodes[i]->id, node_id))
        if( cluster->nodes[i] != NULL && cluster->nodes[i]->id == node_id ) {
            node = cluster->nodes[i];
            break;
        }
    }
   
    if( node == NULL ){
        SDFLOG_ERROR((B, "No existing member"))
        return -1;
    }
    
    
    if( STRCASEEQ(pp, "status") )
    {
        SDFLOG_DEBUG((B, "Update status : %s", value))
        HTTP2_CLNT_ADDR *tmp_list_addr;
        tmp_list_addr = node->list_addr;
        while(tmp_list_addr){                       
            SDFLOG_DEBUG((B, "finding avialable key_name[%s][%d] == [%s][%d]", tmp_list_addr->key_name,tmp_list_addr->key_len , key_name, key_len))
            if( tmp_list_addr->key_len == key_len && memcmp( tmp_list_addr->key_name, key_name, key_len) == 0 ){  //find the same key
                SDFLOG_DEBUG((B, "Updated status !!"))
                //Update data
                if( STRCASEEQ(value, "up") ){
                    tmp_list_addr->link_status = LINK_STATUS_UP;
                }else if( STRCASEEQ(value, "down") ){
                    tmp_list_addr->link_status = LINK_STATUS_DOWN;
                }else if( STRCASEEQ(value, "-") ){
                    tmp_list_addr->link_status = LINK_STATUS_UNKNOWN;
                }else{
                    SDFLOG_ERROR((B, "Unknown link status [%s]", value))
                }
                return 0;
            }
            
            tmp_list_addr = tmp_list_addr->next;
            if( tmp_list_addr == node->list_addr){
                break;
            }
        }
    }
    else if( STRCASEEQ(pp, "state") )
    {
        SDFLOG_DEBUG((B, "Update state : %s", value))
        //TODO: Change structure store data.

        HTTP2_CLNT_ADDR *tmp_list_addr;
        tmp_list_addr = node->list_addr;
        while(tmp_list_addr){                       
            
            if( tmp_list_addr->key_len == key_len && memcmp( tmp_list_addr->key_name, key_name, key_len) == 0 ){  //find the same key
                SDFLOG_DEBUG((B, "Updated state !!"))
                //Update data
                if( STRCASEEQ(value, "StateFollower") ){
                    tmp_list_addr->state = RAFT_STATE_FOLLOWER;
                }else if( STRCASEEQ(value, "StateLeader") ){
                    cluster->leader_node = node;
                    tmp_list_addr->state = RAFT_STATE_LEADER;
                }else if( STRCASEEQ(value, "-")){
                    tmp_list_addr->state = RAFT_STATE_UNKNOWN;
                }else{
                    SDFLOG_ERROR((B, "Unknown link status [%s]", value))
                }
                return 0;
            }
            
            tmp_list_addr = tmp_list_addr->next;
            if( tmp_list_addr == node->list_addr){
                break;
            }
        }
    }
    else if( STRCASEEQ(pp, "cfg") )
    { 

        pp = strstr(value, "\"grpcAddrs\":[");	
        if( pp == NULL){return -2;}
        pp += 14; // sizeof  "\"grpcAddrs\":[\""
        has_next(':');
        SDFLOG_DEBUG((B, "Host :%s", b));
        strcpy(host, b);
        
        has_next('"');
        SDFLOG_DEBUG((B, "Port :%s", b));
        port = atoi(b);
        
        pp = strstr(value, "\"name\":\"");	
        pp += 8; // sizeof "\"name\":\""
        has_next('"');
        SDFLOG_DEBUG((B, "Node name :%s", b));
        strcpy(node_name, b);
        
        pp = strstr(value, "\"clusterName\":\"");	
        pp += 15; // sizeof "\"clusterName\":\""
        has_next('"');
        SDFLOG_DEBUG((B, "Cluster name :%s", b));
        strcpy(cluster_name, b);

        strcpy(cluster->cluster_name, cluster_name);
        strcpy(node->name, node_name);
        
        if( strcasecmp(group, "D21") == 0){
            strcpy(DEFAULT_CLUSTER_D21, cluster_name);
            cluster->routing_rule = http2_get_rule(service->name, cluster->cluster_name);
        }else if( strcasecmp(group, "D20") == 0){
            strcpy(DEFAULT_CLUSTER_D20, cluster_name);
        }
        
        //TODO: Change structure store data.
        HTTP2_CLNT_ADDR *tmp_list_addr;
        tmp_list_addr = node->list_addr;
        while(tmp_list_addr){                       
            if( tmp_list_addr->key_len == key_len && memcmp( tmp_list_addr->key_name, key_name, key_len) == 0 ){  //find the same key
                //Update data
                strcpy(tmp_list_addr->host, host);
                strcpy(tmp_list_addr->cluster_name, cluster_name);
                strcpy(tmp_list_addr->node_name, node_name);
                tmp_list_addr->port = port;
                return 0;
            }
            
            tmp_list_addr = tmp_list_addr->next;
            if( tmp_list_addr == node->list_addr){
                break;
            }
        }
        SDFLOG_INFO((B, "Add service [%s] cluster[%s] node[%s] tpc://%s:%d", group, cluster_name, node_name, host, port))
    }
	return 0;
}

int add_connection( char *key, char *value){
    static char func[] = "add_connection";
#define has_next(_ch) do{   \
	p = pp;					\
	pp = strchr(p, _ch);	\
	if (pp == NULL)  break;	\
	memcpy(b, p, pp-p);		\
	b[pp-p]	 = 0;			\
	pp++;					\
}while(0)
	char *p   = NULL;	
	char *pp  = NULL;
	char b[4096];
    char group[1024];
    char host[1024];
    char cluster_name[1024];
    char node_name[1024];
    char key_name[1024];
    unsigned long cluster_id;
    unsigned long node_id;

    int link_status = 0;
    int key_len     = 0;
    int state       = 0;
    int port        = 0;
    
	pp = strchr(key, '_'); // Ignore damocles key
	pp++; // Skipe '_'

	has_next('_');
	printf("Group :%s", b);	
    strcpy(group, b);
    
	has_next('_');
	has_next('_');
	printf("Cluster ID :%s", b);
    strcpy(cluster_name, b);
    cluster_id = (unsigned long)strtoul(b, NULL, 16);
    
	has_next('_');
	has_next('_');
	printf("Node ID :%s", b);	
    strcpy(node_name, b);	
    node_id = (unsigned long)strtoul(b, NULL, 16);
    
    key_len = (pp-key);
    memcpy(key_name, key, key_len);//damocles_d20_cluster_5c8f6b17c7dbdad6_node_193b7109e2e90a33_
    key_name[key_len] = 0;
    
    pp = strstr(value, "\"grpcAddrs\":[");  
    if( pp == NULL){return -2;}
    pp += 14; // sizeof  "\"grpcAddrs\":[\""
	has_next(':');
	printf("Host :%s", b);
    strcpy(host, b);
	
    has_next('"');
	printf("Port :%s", b);
    port = atoi(b);
    
    //TODO: Decode node name
	
    SDFLOG_INFO((B, "Add service [%s] cluster[%s] node[%s] tpc://%s:%d", group, cluster_name, node_name, host, port))
    if( http2_add_conn(group, host, port, d02global.grpc_conf.max_connection, d02global.grpc_conf.max_concurrence, cluster_name, cluster_id, node_name, node_id, key_name, key_len, 1, 1) != 0 ){
        SDFLOG_FATAL((B, "http2_add_conn return error"))
        return -1;
    }
    
	return 0;
}

static int http2_process_registry_response( HTTP2_CONNECTION *conn){
    static char func[] = "http2_process_registry_response";

    SDFLOG_DEBUG((B, "Got message from D11"))
    ATTRLIST *alist = NULL;
    char hash[128];
    char err[MY_ERR_BUFFER_SIZE];
    SDFLOG_DEBUG((B, "D11 state [%s]", D11_STATE_TO_STR(d02global.D11_instance->state)))
    if( d02global.D11_instance->state == D11_STATE_IDLE || d02global.D11_instance->state == D11_STATE_QUERY_REQUEST){
        int r = GRPC_get_etcd_range_response(conn->usr_data, &alist, err);
        if( r == GRPC_RET_NEED_MORE_DATA){
            SDFLOG_DEBUG((B, "Need more data to decode"))
            return 0;
        }else if( r == GRPC_RET_OK ){
            ATTRLIST* tmp_attr = alist;
            while( tmp_attr ){
                //SDFLOG_DEBUG((B, "Key: %s", tmp_attr->name));
                
                if( tmp_attr->vals ){
                    //SDFLOG_DEBUG((B, "value: %s", tmp_attr->vals->value));
                    add_connection(tmp_attr->name, tmp_attr->vals->value);
                    update_connection(tmp_attr->name, tmp_attr->vals->value);
                }
                
                tmp_attr = tmp_attr->next;
                if(tmp_attr == alist){
                    break;
                }
                
            }

            conn->usr_data->len = 0;
            conn->usr_data->cur = 0;
            
            d02global.D11_instance->state = D11_STATE_QUERY_REQUEST;
            
            //if ( http2_watch_registry_requst(err) != 0 ){
            //    SDFLOG_ERROR((B, "http2_test_send return error[%s]", err))
            //}
        }else{
            SDFLOG_ERROR((B, "GRPC_get_etcd_range_response return error[%s]", err))
            return -1;
        }
    }else if(d02global.D11_instance->state == D11_STATE_WATCH_REQUEST || d02global.D11_instance->state == D11_STATE_WATCH_RESTORE){
        int r = GRPC_get_etcd_watch_response(conn->usr_data, &alist, err);
        
        if( r == GRPC_RET_NEED_MORE_DATA){
            SDFLOG_DEBUG((B, "Need more data to decode"))
            return 0;
        }else if( r == GRPC_RET_OK ){
            SDFLOG_DEBUG((B, "Update Cluster"))
            ATTRLIST* tmp_attr = alist;
            while( tmp_attr ){
                //SDFLOG_DEBUG((B, "Key: %s\n", tmp_attr->name));
                
                if( tmp_attr->vals ){
                    //SDFLOG_DEBUG((B, "update value: %s", tmp_attr->vals->value));
                    update_connection(tmp_attr->name, tmp_attr->vals->value);
                }
                
                tmp_attr = tmp_attr->next;
                if(tmp_attr == alist){
                    break;
                }
                
            }
            conn->usr_data->len = 0;
            conn->usr_data->cur = 0;
            d02global.D11_instance->state = D11_STATE_WATCH_RESTORE;
        }else{
            SDFLOG_ERROR((B, "GRPC_get_etcd_watch_response return error[%s]", err))
            return -1;
        }
    }else{
            SDFLOG_ERROR((B, "Unknown state [%d]", d02global.D11_instance->state))
            return -1;
    }

    LINKEDLIST_FREE_CHAIN_CHILD(alist,NULL,vals)
    
    d02global.D11_status = D11_STATUS_SYNC;
    
    return 0;
}

static int http2_create_header(int grpc_service, HTTP2_CONNECTION *conn, HTTP2_BUFFER** hb, char *auth, int timeout, char *error){
    static char func[] = "http2_create_header";
    static HEADER_FIELD d21_hfs[8] = {{NULL,NULL,0,0,":method", "POST"},
                                        {NULL,NULL,0,0,":scheme", "http"},
                                        {NULL,NULL,0,0,":path", "/pb.D21/Do"},
                                        {NULL,NULL,0,0,":authority", "10.252.169.10"},
                                        {NULL,NULL,0,0,"content-type", "application/grpc"},
                                        {NULL,NULL,0,0,"user-agent", "grpc-go/0.11"},
                                        {NULL,NULL,0,0,"te", "trailers"},
                                        {NULL,NULL,0,0,"grpc-timeout", "5000000u"}};
                                
    static HEADER_FIELD d20_hfs[8] = {{NULL,NULL,0,0,":method", "POST"},
                                        {NULL,NULL,0,0,":scheme", "http"},
                                        {NULL,NULL,0,0,":path", "/pb.D21/ResolveAlias"},
                                        {NULL,NULL,0,0,":authority", "10.252.169.10"},
                                        {NULL,NULL,0,0,"content-type", "application/grpc"},
                                        {NULL,NULL,0,0,"user-agent", "grpc-go/0.11"},
                                        {NULL,NULL,0,0,"te", "trailers"},
                                        {NULL,NULL,0,0,"grpc-timeout", "5000000u"}};
                                
    static HEADER_FIELD d11_hfs[8] = {  {NULL,NULL,0,0,":method", "POST"},
                                        {NULL,NULL,0,0,":scheme", "http"},
                                        {NULL,NULL,0,0,":path", "/etcdserverpb.KV/Range"},
                                        {NULL,NULL,0,0,":authority", "10.252.169.10"},
                                        {NULL,NULL,0,0,"content-type", "application/grpc"},
                                        {NULL,NULL,0,0,"user-agent", "grpc-go/0.11"},
                                        {NULL,NULL,0,0,"te", "trailers"},
                                        {NULL,NULL,0,0,"grpc-timeout", "5000000u"}};
    
    static HEADER_FIELD d11_watch_hfs[8] = {{NULL,NULL,0,0,":method", "POST"},
                                        {NULL,NULL,0,0,":scheme", "http"},
                                        {NULL,NULL,0,0,":path", "/etcdserverpb.Watch/Watch"},
                                        {NULL,NULL,0,0,":authority", "10.252.169.10"},
                                        {NULL,NULL,0,0,"content-type", "application/grpc"},
                                        {NULL,NULL,0,0,"user-agent", "grpc-go/0.11"},
                                        {NULL,NULL,0,0,"te", "trailers"}};

    int i = 0;
    if( grpc_service == GRPC_SERVICE_DO ){
        if( auth != NULL ){
            strcpy(d21_hfs[3].value, auth);             //set up: authority
        }
        if( timeout > 0){
            sprintf(d21_hfs[7].value,"%dm", timeout);   //set up: grpc-timeout
        }
        for(; i < 8; i++){
            if ( HTTP2_write_header(conn, hb, &d21_hfs[i], error) != HTTP2_RET_OK){
                SDFLOG_ERROR((B, "HTTP2_write_header return error[%s]", error))
                return -1;
            }
        }
    }else if( grpc_service == GRPC_RESOLVE_ALIASE ){
        if( auth != NULL ){
            strcpy(d20_hfs[3].value, auth);             //set up: authority
        }
        if( timeout > 0){
            sprintf(d20_hfs[7].value,"%dm", timeout);   //set up: grpc-timeout
        }
        for(; i < 8; i++){
            if ( HTTP2_write_header(conn, hb, &d20_hfs[i], error) != HTTP2_RET_OK){
                SDFLOG_ERROR((B, "HTTP2_write_header return error[%s]", error))
                return -1;
            }
        }
    }else if( grpc_service == GRPC_ETCD_RANGE_REQUEST ){
        if( auth != NULL ){
            strcpy(d11_hfs[3].value, auth);             //set up: authority
        }
        if( timeout > 0){
            sprintf(d11_hfs[7].value,"%dm", timeout);   //set up: grpc-timeout
        }
        for(; i < 8; i++){
            if ( HTTP2_write_header(conn, hb, &d11_hfs[i], error) != HTTP2_RET_OK){
                SDFLOG_ERROR((B, "HTTP2_write_header return error[%s]", error))
                return -1;
            }
        }
    }else if( grpc_service == GRPC_ETCD_WATCH_REQUEST ){
        if( auth != NULL ){
            strcpy(d11_watch_hfs[3].value, auth);             //set up: authority
        }
        for(; i < 7; i++){
            if ( HTTP2_write_header(conn, hb, &d11_watch_hfs[i], error) != HTTP2_RET_OK){
                SDFLOG_ERROR((B, "HTTP2_write_header return error[%s]", error))
                return -1;
            }
        }
    }else{
        SDFLOG_ERROR((B, "Unknown type of grpc_service : %d", grpc_service))
        return -1;
    }
    
    return 0;
}

/*
static int http2_test_send(char *error){
    static char func[]  = "http2_test_send";
    HTTP2_BUFFER *hb    = NULL;
    HTTP2_BUFFER *data  = NULL;
    HTTP2_HOST *hc      = HTTP2_HOSTS[0];
    if( hc->ready_queue != NULL ){
        SDFLOG_DEBUG((B, "http2_create_header"))
        if( http2_create_header(GRPC_SERVICE_DO, hc->ready_queue, &hb, NULL, 0, error) != 0 ){
            return -1;
        }
        
        SDFLOG_DEBUG((B, "GRPC_gen_search_request"))
        unsigned int tid = grpc_tid_gen();
        if( GRPC_gen_search_request(tid, &data,"uid=000000000000001,ds=SUBSCRIBER,o=AIS,DC=C-NTDB", "search", "(objectClass=*)", NULL, 0, 0, error) != GRPC_RET_OK ){
            return -1;
        }
        
        SDFLOG_DEBUG((B, "HTTP2_send_message"))
        if( HTTP2_send_message(hc, hc->ready_queue, hb, 0x4, data, 0x0, error) != HTTP2_RET_OK ){
            return -1;
        }
        
        if (fd_set_write(hc->ready_queue->sock) != 0)
        {
            SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", hc->ready_queue->sock))
            return -1;
        }
    }
    return 0;
}
*/
static int http2_close(HTTP2_CONNECTION *conn){
    
	static char func[] = "http2_close";
    char err[MY_ERR_BUFFER_SIZE];
    int sk = conn->sock;
    
    if( d02global.D11_sock == conn->sock){
        if(d02global.D11_instance != NULL){
            d02global.D11_instance->state = D11_STATE_QUERY_REQUEST;
        }
    }
    
    if( conn->sock ){
        SDFLOG_WARN((B,"HTTP client connection close (%d)", conn->sock))
        fd_clear(sk);
    }
    
    if ( HTTP2_close((HTTP2_NODE*)conn->ref_group, conn->no, err) != HTTP2_RET_OK ){
        SDFLOG_FATAL((B,"Cannot close HTTP2 client connection for socket %d", conn->sock))
		return -1;
    }
    
	return 0;
}

static int http2_write_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    
	static char func[]          = "http2_write_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r                       = 0;
    HTTP2_CONNECTION *conn      = NULL;
    conn                        = (HTTP2_CONNECTION*)user_data;
    
    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
    
    if( conn == NULL ){
        SDFLOG_ERROR((B, "fd[%d] has been closed", fd))
        return -1;
    }
    
    r = HTTP2_write(conn, err);
    if (r == HTTP2_RET_SENT){
        SDFLOG_DEBUG((B, "HTTP client session (%d) group[%s] host[%s] port[%d] sent success", conn->sock, conn->addr_info->group, conn->addr_info->host, conn->addr_info->port))
        struct timeval overall_time, stoptime;
        unsigned long process_time = 0;
        char buff[1024];
        sprintf(&buff[0], "-----> (%d)HTTP2 send :: ", conn->sock);
        WATCH_WITH_START(conn->timestamp_write2, buff)
        gettimeofday(&conn->timestamp_write2,0);
    }
    else if (r == HTTP2_RET_OK){
        //SDFLOG_DEBUG((B, "OK"))
    }
    else{
        SDFLOG_ERROR((B, "Session (%d) group[%s] host[%s] port[%d] HTTP client write return error [%s]", conn->sock, conn->addr_info->group, conn->addr_info->host, conn->addr_info->port, err))
        (void) http2_close (conn);
        return -1;
    }
/*  //TODO:
    // Flush ldap request data
    r = HTTP_CLNT_send_message ((HTTP_CLNT_t *)sess->http_clnt, NULL, NULL, fd_set_write, err);
    if (r != HTTP_CLNT_RET_OK)
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP_CLNT_send_message return error", sess->sock))
        return -1;
    }
    */
	return 0; 
}

static int http2_read_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    static char func[] = "http2_read_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, sk;
    struct timeval elap_tm;
    HTTP2_CONNECTION *conn = (HTTP2_CONNECTION *)user_data;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
    SDFLOG_DEBUG((B,"user_data %p ", conn))

    sk = conn->sock;
    if (fd_set_read(sk) != 0)
    {
        SDFLOG_ERROR((B,"fd_set_read error for socket (%d)", sk))
        return -1;
    }
    
    r = HTTP2_read(conn, err);

	if (r == HTTP2_RET_READY)
    {
        SDFLOG_INFO((B, "HTTP client connection (%d) established", sk))
    }
    else if (r == HTTP2_RET_OK)
    {
        SDFLOG_DEBUG((B, "Session (%d) Read success", sk))
        init_watch(TMR5, err);
        while ((r=HTTP2_decode(conn, err)) == HTTPP_RET_DATA_AVAILABLE)
        {
            //TODO: 
            
            stop_watch(TMR5, &elap_tm, err);
            SDFLOG_INFO((B, "-----> (%d)HTTP2_decode ::  :%lu us", conn->sock, elap_tm.tv_sec*1000000+elap_tm.tv_usec))
            init_watch(TMR5, err);
            SDFLOG_DEBUG((B, "Data avalaible[%d]", conn->frame_recv->type))
            if( conn->frame_recv->type == HTTP2_FRAME_DATA ){
                struct timeval overall_time, stoptime;
                unsigned long process_time = 0;
                char buff[1024];
                sprintf(&buff[0], "-----> (%d)HTTP2 Response :: ", conn->sock);
                WATCH_WITH_START(conn->timestamp_write2, buff)
                gettimeofday(&conn->timestamp_write2,0);
                if(http2_recv_msg(conn, err) != 0){
                    SDFLOG_ERROR((B, "http2_recv_msg return error"))
                    return -1;
                }
            }else if(conn->frame_recv->type == HTTP2_FRAME_RST_STREAM){
                SDFLOG_ERROR((B, "Session (%d) has been reset[%s]", sk, err))
                (void) http2_close (conn);
                return -1;
            }
        }
        SDFLOG_DEBUG((B, "FRAME TYPE [%d]", conn->frame_recv->type))
        if (r<0)
        {
            SDFLOG_ERROR((B, "Session (%d) gropu[%s] host[%s] port[%d] HTTP client decode return error [%s]", conn->sock, conn->addr_info->group, conn->addr_info->host, conn->addr_info->port, err))
            (void) http2_close (conn);
            return -1;
        }
    }
    else
    {
        SDFLOG_ERROR((B, "Session (%d) group[%s] host[%s] port[%d] HTTP client read return error [%s]", sk, conn->addr_info->group, conn->addr_info->host, conn->addr_info->port, err))
        (void) http2_close (conn);
        return -1;
    }
    
    //Send Message frome queue
     r = http2_send_msg_to_queue (NULL, NULL);
    if (r != 0)
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP_CLNT_send_message return error", sk))
        return -1;  
    }
    
	return 0;
}

static int http2_close_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
	(void) (user_data);
	return 0;
}

static int http2_open(){
    static char func[] = "http2_open";
	char err[MY_ERR_BUFFER_SIZE];
    int r = 0, hi = 0, c = 0, n = 0;
    
    epoll_event_element_t* epoll_event_elem = NULL;
    HTTP2_CONNECTION *conn                  = NULL;
    HTTP2_CLUSTER *cluster                  = NULL;
    HTTP2_NODE *node                        = NULL;
    
    for (hi=0; hi<d02global.http2_service_count; hi++)
    {
        for(c = 0; c <  HTTP2_SERVICES[hi]->cluster_count; c++)
        {
            cluster = HTTP2_SERVICES[hi]->clusters[c];
            if( cluster == NULL )break;
            for(n = 0; n < cluster->node_count; n++){
                
                node = cluster->nodes[n];
                if( node == NULL)break;
                r = HTTP2_open(node, &conn, err);
                
                if(r == HTTP2_RET_OK ){
                    if (epoll_event_add(d02global.base_epoll, conn->sock, EPOLLIN | EPOLLOUT | EPOLLET, &epoll_event_elem) == 0)
                    {
                        SDFLOG_INFO((B, "Service[%s] Cluster[%s] Node[%s]", HTTP2_SERVICES[hi]->name, cluster->cluster_name, node->name))
                        SDFLOG_INFO((B,"Open HTTP2 Client Connection session(%d) group[%s] host[%s] port[%d] " ,conn->sock, conn->addr_info->group, conn->addr_info->host, conn->addr_info->port))
                        epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void*)conn );
                        epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void*)http2_write_callback );
                        epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void*)http2_read_callback );
                        epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void*)http2_close_callback );
                    }else{
                        SDFLOG_ERROR((B,"HTTP client cannot register base_epoll for socket %d", conn->sock))
                        //return -1;
                    }
                }else{
                    if (r != HTTP2_RET_MAX_CONNECTION)
                    {
                        SDFLOG_ERROR((B,"h_clnt_open return error [%s] ret[%d]", err, r))
                        //return -1;
                    }
                }
                
            }

        }

    }
	return r;
}

static int http2_add_conn(  char *group, 
                            char *ip, 
                            int port, 
                            int max_connection, 
                            int max_concurrence, 
                            char *cluster_name, 
                            unsigned long cluster_id,
                            char *node_name,
                            unsigned long node_id,
                            char *key_name,
                            int key_len,
                            int link_status,
                            int state){
    static char func[] = "http2_add_conn";
    HTTP2_SERVICE *service      = NULL;
    HTTP2_CLUSTER *cluster      = NULL;
    HTTP2_NODE  *node           = NULL;
    int i;
    char err[MY_ERR_BUFFER_SIZE];
    
    // Find existing service.
    for( i = 0; i < d02global.http2_service_count; i++){
       SDFLOG_DEBUG((B, "Checking avialable service[%s] == [%s]",HTTP2_SERVICES[i]->name, group))
      if( HTTP2_SERVICES[i] != NULL && STRCASEEQ( HTTP2_SERVICES[i]->name, group) ){
           service = HTTP2_SERVICES[i];
           break;
       }
    }
    
    if( service == NULL ){
        if( HTTP2_service_create(&service, group, err) != HTTP2_RET_OK ){
            SDFLOG_ERROR((B, "HTTP2_service_create return error[%s]", err))
            return -1;
        }
        HTTP2_SERVICES[d02global.http2_service_count] = service;
        SDFLOG_INFO((B, "Add Service[%s]", group))
        d02global.http2_service_count++;
    }
    
    // Find existing cluster.
    for(i = 0; i < service->cluster_count; i++){
        SDFLOG_DEBUG((B, "Checking avialable cluster[%lu] == [%lu]", service->clusters[i]->cluster_id, cluster_id))
        if( service->clusters[i] != NULL && service->clusters[i]->cluster_id == cluster_id ) {
            cluster = service->clusters[i];
            break;
        }
    }
    
    if(cluster == NULL){
        if( HTTP2_cluster_create(&cluster, cluster_id, cluster_name, err) != HTTP2_RET_OK ){
            SDFLOG_ERROR((B, "HTTP2_cluster_create return error[%s]", err))
            return -1;
        }
        service->clusters[service->cluster_count] = cluster;
        SDFLOG_INFO((B, "Add Cluster[%s]", cluster_name))
        service->cluster_count++;
        
        if( STRCASEEQ(service->name, "D21") ){
            cluster->routing_rule = MASTER_RATIO_WITH_ROUNDROBIN;//http2_get_rule(service->name, cluster->cluster_name);
        }else if( STRCASEEQ(service->name, "D20") ){
            strcpy(DEFAULT_CLUSTER_D20, cluster_name);
            cluster->routing_rule = ROUND_ROBIN;
        }else if( STRCASEEQ(service->name, "D11") ){
            cluster->routing_rule = ROUND_ROBIN;
        }
    }

    // Find existing node(member).
    for(i = 0; i < cluster->node_count; i++){
        SDFLOG_DEBUG((B, "Checking avialable member[%lu] == [%lu]", cluster->nodes[i]->id, node_id))
        if( cluster->nodes[i] != NULL && cluster->nodes[i]->id == node_id ) {
            node = cluster->nodes[i];
            break;
        }
    }
   
    if( node == NULL ){
        if( HTTP2_node_create(&node, node_name, node_id, max_connection, max_concurrence,err) != HTTP2_RET_OK ){
            SDFLOG_ERROR((B, "HTTP2_node_create return error[%s]", err))
            return -1;
        }
        cluster->nodes[cluster->node_count] = node;
        LINKEDLIST_APPEND(cluster->list_nodes, node);
        SDFLOG_INFO((B, "Add Node[%s]", node_name))
        cluster->node_count++;
    }
    
    if( HTTP2_addr_add_by_cluster(node, ip, port, max_connection, group, cluster_name, cluster_id, node_name, node_id, key_name, key_len, link_status, state, err) != HTTP2_RET_OK ){
        SDFLOG_ERROR((B, "HTTP2_host_create return error[%s]", err))
        return -1;
    }
    

    return 0;
}

int http2_add_rule(char *service, char *cluster, char *rule){
    static char func[] = "http2_add_rule";
    
    ROUTING_RULE *new_rule;
    new_rule = malloc(sizeof(ROUTING_RULE));
    
    if( new_rule == NULL ){
        SDFLOG_ERROR((B, "Cannot allocate memory"))
        return -1;
    }
    
    new_rule->next = NULL;
    new_rule->prev = NULL;
    strcpy(new_rule->service, service);
    strcpy(new_rule->cluster, cluster);
    
    if( strcasecmp(rule, "RoundRobin") == 0 ){
        new_rule->rule = ROUND_ROBIN;
    }else if(strcasecmp(rule, "MasterRatioWithRoundRobin") == 0){
        new_rule->rule = MASTER_RATIO_WITH_ROUNDROBIN;
    }else if(strcasecmp(rule, "MasterRatioWithLeastUtilize") == 0){
        new_rule->rule = MASTER_RATIO_WITH_LEASTUTILIZE;
    }else{
        SDFLOG_ERROR((B, "Invalid Routinge Rule name"))
        return -1;
    }

    LINKEDLIST_APPEND(G_OFFILE_RULE, new_rule);
    
    return 0;
}

int http2_get_rule(char *service, char *cluster){
    static char func[] = "http2_get_rule";
    ROUTING_RULE *tmp = G_OFFILE_RULE;
    while( tmp ){
        SDFLOG_DEBUG((B, "checking rule [%s:%s] = [%s:%s]", tmp->service, tmp->cluster, service, cluster))
        if( strcasecmp(tmp->service, service) == 0 && strcasecmp(tmp->cluster, cluster) == 0){
            return tmp->rule;
        }
        tmp = tmp->next;
        if( tmp == G_OFFILE_RULE ){
            break;
        }
    }
    SDFLOG_INFO((B, "Using default rule"))
    return ROUND_ROBIN;
}

int http2_route_by_round_robin(HTTP2_CLUSTER *cluster){
    #define BREAKOUT 10
    static char func[] = "http2_route_by_round_robin";
    char error[MY_ERR_BUFFER_SIZE];
    int breaker = 0;
    HTTP2_MESSAGES *queue   = NULL;
    HTTP2_CONNECTION *conn  = NULL;
    HTTP2_NODE *first_node = NULL;
    HTTP2_NODE *node = first_node = cluster->list_nodes;

    while ( node != NULL && cluster->send_msg_queue != NULL && breaker < BREAKOUT){
        SDFLOG_DEBUG((B, "Select node[%s]", node->name))
        if( node->ready_queue != NULL ){
            queue = cluster->send_msg_queue;
            LINKEDLIST_REMOVE(cluster->send_msg_queue, queue);
            cluster->send_msg_queue_count--;
            
            //round-robin connection
            conn = node->ready_queue;
            LINKEDLIST_REMOVE(node->ready_queue, conn);
            LINKEDLIST_APPEND(node->ready_queue, conn);
            
            //remember sock id in case of D11 group;
            if( strcasecmp(queue->group, "D11") == 0 ){
                d02global.D11_sock = conn->sock;
            }
            
            //TODO: Make it to static header
            HTTP2_BUFFER *hb = NULL;
            if( http2_create_header(queue->service, conn, &hb, NULL, 0, error) != 0 ){
                free(queue->buffer);
                free(queue);
                free(hb);
                SDFLOG_DEBUG((B, "http2_create_header return error[%s]", error))
                return -1;
            }

            //Put message to the buffer of connecton
            if( HTTP2_send_message(node, conn, hb, 0x04, queue->buffer, 0x0, error) != HTTP2_RET_OK ){ //0x04= End Header, 0x0 = continue frame.
                free(queue->buffer);
                free(queue);
                free(hb);
                SDFLOG_DEBUG((B, "HTTP2_send_message return error[%s]", error))
                return -1;
            }
            
            SDFLOG_DEBUG((B, "Write flag is set"))
            if (fd_set_write(conn->sock) != 0)
            {
                free(queue->buffer);
                free(queue);
                free(hb);
                SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", node->ready_queue->sock))
                return -1;
            }
            gettimeofday(&conn->timestamp_write2,0);
            free(queue->buffer);
            free(queue);
            free(hb);
        }else{
            breaker++;
        }
        
        LINKEDLIST_REMOVE(cluster->list_nodes, node);
        LINKEDLIST_APPEND(cluster->list_nodes, node);
        node = cluster->list_nodes;
    }
    return 0;
}

#define BREAKOUT 10
int http2_route_by_master_ratio(HTTP2_CLUSTER *cluster){
    static char func[] = "http2_route_by_master_ratio";
    char error[MY_ERR_BUFFER_SIZE];
    int breaker = 0;
    HTTP2_MESSAGES *queue   = NULL;
    HTTP2_CONNECTION *conn  = NULL;
    HTTP2_NODE *first_node = NULL;
    HTTP2_NODE *node = cluster->list_nodes;

    while ( cluster->send_msg_queue != NULL && breaker < BREAKOUT){
        queue = cluster->send_msg_queue;
        switch( queue->command_type ){
            case RESTFUL_COMMAND_ADD:
            case RESTFUL_COMMAND_DELETE:
            case RESTFUL_COMMAND_MODIFY:
            {
                if( (cluster->leader_node) != NULL && (conn = cluster->leader_node->ready_queue) != NULL){
                    SDFLOG_DEBUG((B, "Select node[%s]", cluster->leader_node->name))
                    //RoundRobin connection
                    LINKEDLIST_REMOVE(cluster->leader_node->ready_queue, conn);
                    LINKEDLIST_APPEND(cluster->leader_node->ready_queue, conn);
                                        
                    LINKEDLIST_REMOVE(cluster->send_msg_queue, queue);
                    cluster->send_msg_queue_count--;
                    
                    //TODO: Make it to static header
                    HTTP2_BUFFER *hb = NULL;
                    if( http2_create_header(queue->service, conn, &hb, NULL, 0, error) != 0 ){
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_DEBUG((B, "http2_create_header return error[%s]", error))
                        return -1;
                    }

                    //Put message to the buffer of connecton
                    if( HTTP2_send_message(cluster->leader_node, conn, hb, 0x04, queue->buffer, 0x0, error) != HTTP2_RET_OK ){ //0x04= End Header, 0x0 = continue frame.
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_DEBUG((B, "HTTP2_send_message return error[%s]", error))
                        return -1;
                    }
                    SDFLOG_DEBUG((B, "Send to master node"))
                    SDFLOG_DEBUG((B, "Write flag is set"))
                    if (fd_set_write(conn->sock) != 0)
                    {
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", conn->sock))
                        return -1;
                    }
                    
                    free(queue->buffer);
                    free(queue);
                    free(hb);
                }else{
                    SDFLOG_WARN((B, "No available Leader node"))
                    LINKEDLIST_REMOVE(cluster->send_msg_queue, queue);
                    LINKEDLIST_APPEND(cluster->send_msg_queue, queue);
                    breaker++;
                }
                
            }
            break; 
            case RESTFUL_COMMAND_SEARCH:
            {
                //Find available node that has ready connection.
                while( node != NULL && (node->ready_queue == NULL)){
                    LINKEDLIST_REMOVE(cluster->list_nodes, node);
                    LINKEDLIST_APPEND(cluster->list_nodes, node);
                    node = cluster->list_nodes;
                    if(breaker++ > BREAKOUT){
                        return 0;
                    }
                }
                
                if( node != NULL  && (conn = node->ready_queue) != NULL){
                    SDFLOG_DEBUG((B, "Select node[%s]", node->name))
                    //RoundRobin connection
                    LINKEDLIST_REMOVE(node->ready_queue, conn);
                    LINKEDLIST_APPEND(node->ready_queue, conn);
                                        
                    LINKEDLIST_REMOVE(cluster->send_msg_queue, queue);
                    cluster->send_msg_queue_count--;
                    
                    //TODO: Make it to static header
                    HTTP2_BUFFER *hb = NULL;
                    if( http2_create_header(queue->service, conn, &hb, NULL, 0, error) != 0 ){
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_DEBUG((B, "http2_create_header return error[%s]", error))
                        return -1;
                    }

                    //Put message to the buffer of connecton
                    if( HTTP2_send_message(node, conn, hb, 0x04, queue->buffer, 0x0, error) != HTTP2_RET_OK ){ //0x04= End Header, 0x0 = continue frame.
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_DEBUG((B, "HTTP2_send_message return error[%s]", error))
                        return -1;
                    }
                    
                    SDFLOG_DEBUG((B, "Write flag is set"))
                    if (fd_set_write(conn->sock) != 0)
                    {
                        free(queue->buffer);
                        free(queue);
                        free(hb);
                        SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", conn->sock))
                        return -1;
                    }
                    
                    free(queue->buffer);
                    free(queue);
                    free(hb);
                    
                    LINKEDLIST_REMOVE(cluster->list_nodes, node);
                    LINKEDLIST_APPEND(cluster->list_nodes, node);
                }else{
                    LINKEDLIST_REMOVE(cluster->send_msg_queue, queue);
                    LINKEDLIST_APPEND(cluster->send_msg_queue, queue);
                    breaker++;
                }
            }
            break;
            default :
                SDFLOG_ERROR((B, "Unkown command type [%d]", queue->command_type))
                break;
            
        }
        node = cluster->list_nodes;
    }
    return 0;
}


int http2_send_msg_to_queue(AFINSTANCE *instance, HTTP2_BUFFER* h_data){
    
    static char func[] = "http2_send_msg_to_queue";
    char error[MY_ERR_BUFFER_SIZE];
    HTTP2_NODE *node        = NULL;
    HTTP2_SERVICE *service  = NULL;
    HTTP2_CONNECTION *conn  = NULL;
    HTTP2_MESSAGES *queue   = NULL;
    HTTP2_CLUSTER *cluster  = NULL;
    int r       = 0, 
        i       = 0,
        found   = 0;

    SDFLOG_DEBUG((B, "http2_send_msg_to_queue"))
        
    //TODO: Choose destination by condition
    //1.) choose cluster
    //2.) choose master node
    
    if( instance != NULL && h_data != NULL){
        for( i = 0; i < d02global.http2_service_count; i++){
            SDFLOG_DEBUG((B, "Checking avialable service[%s] == instance->group[%s]",HTTP2_SERVICES[i]->name, instance->group))
            if( HTTP2_SERVICES[i] != NULL && STRCASEEQ( HTTP2_SERVICES[i]->name, instance->group) ) {
                service = HTTP2_SERVICES[i];
                break;
            }
        }

        if(service == NULL){
            SDFLOG_ERROR((B, "HTTP2_NODE* is not available"))
            return -1;
        }
        
        for( i = 0; i < service->cluster_count; i++){
            SDFLOG_DEBUG((B, "Checking avialable cluster[%s] == instance->cluster[%s]",service->clusters[i]->cluster_name, instance->cluster))
            if( service->clusters[i] != NULL && STRCASEEQ( service->clusters[i]->cluster_name, instance->cluster) ) {
                cluster = service->clusters[i];
                break;
            }
        }

        if(cluster == NULL){
            SDFLOG_ERROR((B, "Cluster[%s] is not available", instance->cluster))
            return -1;
        }

        //Compose message
        queue = malloc(sizeof(HTTP2_MESSAGES));
        queue->next = NULL;
        queue->prev = NULL;
        queue->buffer = h_data;
        queue->service = instance->service;
        queue->command_type = instance->command_type;
        strcpy(queue->group, instance->group);
        LINKEDLIST_APPEND(cluster->send_msg_queue, queue)
        cluster->send_msg_queue_count++;
        SDFLOG_DEBUG((B, "routing type [%s]", ROUTING_RULE_TO_STRING(cluster->routing_rule)))
        SDFLOG_DEBUG((B, "http2_send_msg_to_queue completely"))
    }
    
    for( i = 0; i < d02global.http2_service_count; i++){
        service = HTTP2_SERVICES[i];
        int c = 0;
        for(c = 0; c < service->cluster_count; c++){
            cluster = service->clusters[c];
            if( cluster != NULL ){
                //Routing Rule
                switch( cluster->routing_rule ){
                    case ROUND_ROBIN:
                        http2_route_by_round_robin(cluster);
                        break;
                    case MASTER_RATIO_WITH_ROUNDROBIN:
                        http2_route_by_master_ratio(cluster);
                        break;
                    case MASTER_RATIO_WITH_LEASTUTILIZE:
                    case ACTIVE_STANDBY:
                    default:
                        http2_route_by_round_robin(cluster);
                    break;
                }
            }
        }

    }
    
    return 0;
}

int
http2_recv_msg(HTTP2_CONNECTION *conn)
{
    static char func[] = "http2_recv_msg";
    char err[MY_ERR_BUFFER_SIZE];
    DSSESSION *sess = NULL;
    HSDATA *wbuff   = NULL;
    HTTP2_BUFFER* buffer = NULL;
    MWRAPPER *mw    = NULL;
    char hash[1024];
    int hlen        = 0;
    int r           = 2;
    unsigned int tid= 0;
    SDFLOG_DEBUG((B, "Stream ID: %d", conn->frame_recv->streamID))
    
    /* Process etcd message */
    if( STRCASEEQ(conn->addr_info->group,"D11") ){
        
        return http2_process_registry_response(conn);
    }
    
    r = af_action_process_v2(conn, &sess);
    
    SDFLOG_DEBUG((B, "af_action_process_v2 : %d", r))
    /*
    if (r == 1)
    {
        return -1;
    }
    else if (r == 2)
    {
        if (sess != NULL && http_gen_not_implemented_page(sess, &wbuff) != 0)
        {
            //h_sess_close(sess);
            return -1;
        }
    }
    else if (r == 3){
        //Send next request.
    }
    else if (r != 0)
    {
        if (sess != NULL && http_gen_internal_error_page(sess, &wbuff) != 0)
        {
            //h_sess_close(sess);
            return -1;
        }
    }

    if ((r != 0) && (wbuff != NULL))
    {
        if (sess->w_buffer == NULL)
            sess->w_curr = 0;
        
        LINKEDLIST_APPEND(sess->w_buffer, wbuff)

        if (fd_set_write(sess->sock) != 0)
        {
            SDFLOG_ERROR((B,"fd_set_write error for socket (%d)", sess->sock))
            //h_sess_close(sess);
            return -1;
        }

        if (SDF_log_level() & SDFLOG_LEVEL_INFO)
        {
            sess->write_count = sess->total_wait_write_io = 0;
            gettimeofday(&(sess->timestamp_write),0);
        }
    }
    */
    return 0;
}


#endif

#ifdef SYNC_DMCD

/* decode json for get cluster */
int create_cluster_from_data(char *data, int data_len, char *error){
    if(data_len <= 0){
        if( error != NULL)
            sprintf(error, "data is empty, data length [%d]", data_len);
    }
    
    //TODO: decode json format and create new cluster
    
    
    return 0;
}

/*
 * add d21 connection 
 */
 
 int add_conn_d21(CLUSTER *cluster, char *host, int port, int type, char *error){
    if( cluster == NULL ){
        if( error ){
            sprintf(error, "Cluster is null");
        }
        return -1;
    }
    
    if( host == NULL ){
        if ( error ){
            sprintf(error, "host is null");
        }
        return -1;
    } 
    
    int curr = cluster->conn_d21_count;
    cluster->conn_d21[curr].port = port;
    cluster->conn_d21[curr].type = type;
    strcpy(cluster->conn_d21[curr].host, host);
    cluster->conn_d21_count = curr + 1;
    cluster->conn_d21[curr].next = NULL;
    cluster->conn_d21[curr].prev = NULL;
    LINKEDLIST_APPEND(cluster->list_conn_d21, &cluster->conn_d21[curr]);
    return 0;
 }

int create_cluster(CLUSTER **new_cluster, char *cluster_id, char *error){
    CLUSTER *new = NULL;
    new = (CLUSTER *) calloc(1,  sizeof(CLUSTER) );
    
    if( new == NULL ){
      if( error != NULL ){
          sprintf(error, "Cannot allocated memory.");
          return -1;
      }  
    } 
    strcpy(new->cluster_id, cluster_id);
    new->conn_d21_count = 0;
    new->list_conn_d21  = NULL;
    *new_cluster = new;
    return 0;
} 
  
int cluster_group_cleanup(){
    HMAP_DB * cluster_group  = d02global.cluster_group;
    if( cluster_group == NULL){
        return -1;
    }
    
    TUPLE *t_tuple = (TUPLE*) cluster_group->list_tuple;
    
    //remove d21 conn from cluster
    while( t_tuple ){
        CLUSTER *cluster = (CLUSTER*) t_tuple->data;
        CONN_PROPERTY *d21 = cluster->list_conn_d21;
        while( d21 ){
            LINKEDLIST_REMOVE(cluster->list_conn_d21, d21);
            d21 = cluster->list_conn_d21;
        }
        t_tuple = t_tuple->next;
        if( t_tuple ==  cluster_group->list_tuple){
            break;
        }
    }
    
    //remove cluster from cluster groups
    hmap_truncate(&d02global.cluster_group);
    return 0;
} 

/*
 * GROUP1 :
 *      HOST1 :
 *      HOST2 :
 * GROUP2 :
 *      HOST1 :
 *      HOST2 :
 */
 
static int test_h_clnt_open(){
    //Add host
    HTTP_CLNT_t *hc = (HTTP_CLNT_t *)HTTP_CLNT_init("dmcd", 2048, 1);
    HTTP_CLNT_add_host(hc, "127.0.0.1", 4001, HTTP_CLNT_CONN_ACTIVE, 2);
    hc->hc_addr_curr = 0;
    d02global.http_clnt[0] = hc;
    d02global.http_list_count = 1;
    return h_clnt_open();
}

static int h_clnt_open(){
    static char func[] = "h_clnt_open";
	char err[MY_ERR_BUFFER_SIZE];
    int r = 0, hi = 0, c = 0;
    HCSESSION *sess;
	epoll_event_element_t* epoll_event_elem = NULL;

    for (hi=0; hi<d02global.http_list_count; hi++)
    {
        for(c = 0; c <  d02global.http_clnt[hi]->hc_addr_count; c++){
            SDFLOG_DEBUG((B, "Open connection[%d]", c))
            r = HTTP_CLNT_sess_open(d02global.http_clnt[hi], &sess, err);
            if(r == HTTP_CLNT_RET_OK ){
                if (epoll_event_add(d02global.base_epoll, sess->sock, EPOLLIN | EPOLLOUT | EPOLLET, &epoll_event_elem) == 0)
                {
                    SDFLOG_DEBUG((B,"Open HTTP Client Connection"))
                    epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_USER_DATA , (void*)sess );
                    epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_WRITE_CALLBACK , (void*)h_clnt_write_callback );
                    epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_READ_CALLBACK , (void*)h_clnt_read_callback );
                    epoll_events_set_option(epoll_event_elem , BASE_EPOLL_SET_CLOSE_CALLBACK , (void*)h_clnt_close_callback );
                }else{
                    SDFLOG_FATAL((B,"HTTP client cannot register base_epoll for socket %d", sess->sock))
                    return -1;
                }
            }else{
                if (r != HTTP_CLNT_RET_MAX_SESSION)
                {
                    SDFLOG_FATAL((B,"h_clnt_open return error [%s] ret[%d]", err, r))
                    return -1;
                }
            }
        }

    }

	return r;
}

static int h_clnt_close(HCSESSION *sess){
    
	static char func[] = "h_clnt_close";
    char err[MY_ERR_BUFFER_SIZE];
    int sk = sess->sock;

    if (HTTP_CLNT_sess_close((HTTP_CLNT_t*)sess->http_clnt, sess->no, NULL, err)!=LDAP_RET_OK)
    {
        SDFLOG_FATAL((B,"Cannot close HTTP client connection for socket %d", sess->sock))
		return -1;
    }

	if (sk >= 0)
	{
        SDFLOG_WARN((B,"HTTP client connection close (%d)", sk))
        fd_clear(sk);
	}

	return 0;
}

static int h_clnt_write_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    
	static char func[] = "h_clnt_write_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r = 0;
    
    HCSESSION *sess = (HCSESSION *)user_data;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
	//SDFLOG_DEBUG((B,"FD %d ", fd))
    
    r = HTTP_CLNT_sess_write((HTTP_CLNT_t *)sess->http_clnt, sess, NULL, err);
	if (r == HTTP_CLNT_RET_SENT)
    {
        SDFLOG_DEBUG((B, "HTTP client session (%d) sent success", sess->sock))
        // Send stats should be incremented here
    }
    else if (r == HTTP_CLNT_RET_OK)
    {
        //SDFLOG_DEBUG((B, "OK"))
    }
    else
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP client write return error [%s]", sess->sock, err))
        (void) h_clnt_close (sess);
        return -1;
    }
    // Flush ldap request data
    r = HTTP_CLNT_send_message ((HTTP_CLNT_t *)sess->http_clnt, NULL, NULL, fd_set_write, err);
    if (r != HTTP_CLNT_RET_OK)
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP_CLNT_send_message return error", sess->sock))
        return -1;
    }

	return 0; 
}

static int h_clnt_read_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    static char func[] = "h_clnt_read_callback";
    char err[MY_ERR_BUFFER_SIZE];
    int r=0, sk;
    HCSESSION *sess = (HCSESSION *)user_data;

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);
    SDFLOG_DEBUG((B,"user_data %p ", sess))

    sk = sess->sock;
    if (fd_set_read(sk) != 0)
    {
        SDFLOG_ERROR((B,"fd_set_read error for socket (%d)", sk))
        return -1;
    }

    r = HTTP_CLNT_sess_read((HTTP_CLNT_t *)sess->http_clnt, sess, err);
	if (r == HTTP_CLNT_RET_READY)
    {
        SDFLOG_INFO((B, "HTTP client connection (%d) established", sk))
    }
    else if (r == HTTP_CLNT_RET_OK)
    {
        SDFLOG_DEBUG((B, "Session (%d) Read success", sk))
        while ((r=HTTP_CLNT_sess_decode((HTTP_CLNT_t *)sess->http_clnt, sess, err))==HTTP_CLNT_RET_DATA_AVAILABLE)
        {
            h_clnt_recv_msg(sess);
        }
        if (r<0)
        {
            SDFLOG_ERROR((B, "Session (%d) HTTP client decode return error [%s]", sk, err))
            (void) h_clnt_close (sess);
            return -1;
        }
    }
    else
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP client read return error [%s]", sk, err))
        (void) h_clnt_close (sess);
        return -1;
    }
    // Flush ldap request data
    r = HTTP_CLNT_send_message ((HTTP_CLNT_t *)sess->http_clnt, NULL, NULL, fd_set_write, NULL);
    if (r != HTTP_CLNT_RET_OK)
    {
        SDFLOG_ERROR((B, "Session (%d) HTTP_CLNT_send_message return error", sk))
        return -1;
    }

	return 0;
}

static int h_clnt_close_callback(base_epoll_t* base_epoll, epoll_event_element_t * elem, struct epoll_event events , int fd , void * user_data){
    //static char func[] = "h_clnt_close_callback";

    UNUSED(base_epoll);
    UNUSED(elem);
    UNUSED(events);
    UNUSED(fd);

	(void) h_clnt_close (user_data);
	return 0;
}

int json_object_d21_connect_get(CLUSTER *cluster, char const *root_key, int klen, ejson_obj_t * json_obj){
    static char func[] = "json_object_d21_connect_get";
    char key[1024];
    ejson_obj_t *t_json_obj = json_obj->child;
    TUPLE *f_tuple          = NULL;
    key[0]                  = 0;
    while(t_json_obj){
       //find d21 connection
       hmap_search(t_json_obj->map, "key", 3, &f_tuple); 
        if( f_tuple != NULL ){
            strcpy(key, &(((ejson_data_t *)(f_tuple->data))->value[klen+1]));   //1 instead of '/'
            SDFLOG_DEBUG((B, "        - connection : %s", key));
        }
        
        hmap_search(t_json_obj->map, "value", 5, &f_tuple); 
        if( STRCASEEQ(key, "grpc") ){
            char *host = ((ejson_data_t *)(f_tuple->data))->value;
            host = strstr(host, "tcp://");
            host += 6;                                                          //skip : 6 is size of "tcp://"
            char *port = strstr(host , ":");
            port[0] = '\0';
            port++;                                                             //skip : 1 instead of ':'
            SDFLOG_DEBUG((B, "----> %s : %s", host, port))
            if( host != NULL){
                add_conn_d21(cluster, host, atoi(port), 0, NULL);
            }
        }
        if( f_tuple != NULL ){
            SDFLOG_DEBUG((B, "        - connection : %s", ((ejson_data_t *)(f_tuple->data))->value));
        }
        
        t_json_obj = t_json_obj->next;
        if(t_json_obj == json_obj->child)
            break;
    }
    return 0; 
}

int json_object_d21_get(CLUSTER *cluster, ejson_obj_t * json_obj){
    static char func[] = "json_object_d21_get";
    ejson_obj_t *t_json_obj = json_obj;
    TUPLE *f_tuple          = NULL;
    while(t_json_obj){
       //find d21 connection
       hmap_search(t_json_obj->map, "key", 3, &f_tuple); 
        if( f_tuple != NULL ){
            SDFLOG_DEBUG((B, "    - d21 name : %s", ((ejson_data_t *)(f_tuple->data))->value));
            json_object_d21_connect_get(cluster, ((ejson_data_t *)(f_tuple->data))->value, strlen(((ejson_data_t *)(f_tuple->data))->value), t_json_obj->child);
        }
        
        t_json_obj = t_json_obj->next;
        if(t_json_obj == json_obj)
            break;
    }
    return 0;
}

int json_object_cluster_get(ejson_obj_t * json_obj){
    static char func[] = "json_object_cluster_get";
    ejson_obj_t *t_json_obj = json_obj;
    TUPLE *f_tuple          = NULL;
    char *cusid             = NULL;
    int r                   = 0;
    while( t_json_obj ){
        
       //find cluster
       hmap_search(t_json_obj->map, "key", 3, &f_tuple); 
        if( f_tuple != NULL ){
            SDFLOG_DEBUG((B, "cluster name : %s", ((ejson_data_t *)(f_tuple->data))->value));
            
            cusid = ((ejson_data_t *)(f_tuple->data))->value;
            cusid += 23;   //24 instead of "/damocles/d21/clusters/"
            
            SDFLOG_DEBUG((B, "0x%s", cusid))
            //create new cluster
            CLUSTER *cluster = NULL;
            create_cluster(&cluster, cusid, NULL);
            
            //add d21 connection to cluster
            json_object_d21_get(cluster, t_json_obj->child->child);
            
            //add cluster to global cluster
            if( (r = hmap_add_tuple_with_data(&d02global.cluster_group, cusid, strlen(cusid), cluster, 1)) != HMAP_SUCCESS){
                SDFLOG_DEBUG((B, "hmap_add_tuple_with_data return error [%d]", r))
            }
        }
        
        t_json_obj = t_json_obj->next;
        if(t_json_obj == json_obj)
            break;
    }
    return 0;
}

static int process_sync_dmcd(const char * body, int body_len, char *error){
    static char func[] = "process_sync_dmcd";

    //TODO: 1. Prepare data to update cmcd connection.
    ejson_obj_t *json_obj   = NULL;
    unsigned long clusterID          = -1;
    
    SDFLOG_DEBUG((B, "body[%s]", body))
    SDFLOG_DEBUG((B, "----> Body Length : %d", body_len))
    
    cluster_group_cleanup();
    ejson_to_object(body, body_len, &json_obj);
    if( json_obj != NULL && json_obj->child != NULL && json_obj->child->child && json_obj->child->child->child)
    {
        json_object_cluster_get(json_obj->child->child->child);
    }
    
    make_cluster_array();

    //TEST : select cluster by UID
    if ( get_cluster_by_UID("201", &clusterID, error) < 0 ){
        SDFLOG_ERROR((B, "get_cluster_by_UID return code[%s]", error))
    }else{
        char cluster_name[17];
        snprintf(&cluster_name[0], 17, "%016lx", clusterID);
        SDFLOG_DEBUG((B, "find %s ", cluster_name))
        TUPLE * t_tuple = NULL;
        if( hmap_search(d02global.cluster_group, cluster_name, 16, &t_tuple) == HMAP_SUCCESS ) {
            CLUSTER *t_cluster = (CLUSTER *) t_tuple->data;
           if ( t_cluster != NULL && t_cluster->conn_d21) {
                CONN_PROPERTY *t_d21conn = t_cluster->conn_d21;
                SDFLOG_DEBUG((B, "select d21 ----> %s:%d", t_d21conn->host, t_d21conn->port))
            }
        }
        SDFLOG_DEBUG((B, "Testing UID : 513 will go to cluster : %lu", clusterID))
    }
    
    ejson_destroy(json_obj);
    return 0;
}

static int h_clnt_recv_msg(HCSESSION *sess){
    static char func[] = "h_clnt_recv_msg";
    int mlen = 0;
    int remainlen = 0;
    
    SDFLOG_DEBUG((B, "data size [%d]", sess->r_buffer->len))
    SDFLOG_DEBUG((B, "Header[%s]", sess->r_buffer->data))
    SDFLOG_DEBUG((B, "Body[%s]", sess->r_buffer->data + sess->header_length))
    
    // process data from DMCD
    char error[1024];
    if( process_sync_dmcd( sess->r_buffer->data + sess->header_length, sess->body_length, error ) != 0 ){
        SDFLOG_ERROR((B, "process_sync_dmcd return error: %s", error))
    }
    
    mlen = sess->header_length + sess->body_length;
    remainlen = sess->r_buffer->len - mlen;
    memmove(sess->r_buffer->data, sess->r_buffer->data + mlen, remainlen);
    sess->r_buffer->len = remainlen;    
    // reset header
    sess->header_length = -1;
    // reset body
    sess->body_length = -1;
    
    SDFLOG_DEBUG((B, "Got data from DMCD successfull."))
}

static int send_sync_dmcd(){
    static char func[] = "send_sync_dmcd";
    char error[1024];
    int r  = 0;
    /*
    char header[] = "POST / HTTP/1.1\n"
                "Content-Type: text/xml\n"
                "Host localhost:20600\n"
                "Content-Length: 79"
                "\r\n\r\n";
    char body[] = "<EquinoxMessage>\n<EquinoxCommand name=\"getstats\" cid=\"3989\"/>\n</EquinoxMessage>\n";
    */
    char header[] = "GET /v2/keys/damocles/d21/clusters?recursive=true HTTP/1.1\r\n"
                    "User-Agent: curl/7.35.0\r\n"
                    "Host: localhost:4001\r\n"
                    "Accept: *";
    char body[1024];
    HCDATA *hcdata = NULL;
    
    if( d02global.http_clnt[0] == NULL ){
        return HTTP_CLNT_RET_OK;
    }
    SDFLOG_DEBUG((B, "trying send message to queue[%d]", d02global.http_clnt[0]->send_msg_queue_count))
    SDFLOG_DEBUG((B, "number of connection [%d]", d02global.http_clnt[0]->session_count))
    if( d02global.http_clnt[0]->send_msg_queue_count > d02global.http_clnt[0]->session_count){
        return HTTP_CLNT_RET_OK;
    }
    if( (r = HTTP_CLNT_creat_message(&hcdata, header, sizeof(header), body, 0, error)) != HTTP_CLNT_RET_OK ){
        SDFLOG_ERROR((B, "HTTP_CLNT_creat_message [%s] ret[%d]", error, r))
        return -1;
    }
    
    if( (r = HTTP_CLNT_send_message(d02global.http_clnt[0], NULL, hcdata, fd_set_write, error)) != HTTP_CLNT_RET_OK ){
        free(hcdata);
        SDFLOG_ERROR((B, "HTTP_CLNT_send_message [%s] ret[%d]", error, r))
        return -1;
    }
    
    return HTTP_CLNT_RET_OK;
}


#endif

static int shutdown_thread(){
    static char func[] = "shutdown_thread";
    int i = 0;
    for (; i < d02global.conf_warm.thread_log_max; i++){
        if( xthread_is_running(d02global.xthread_log[i]) == true ){
            d02global.xthread_log_exit[i] = 1;
            SDFLOG_DEBUG((B,"shuting down thread [%d]", i))
            xthread_detach(d02global.xthread_log[i]);
        }
    }
    return 0;
}

static int invoke_log_flusher(){
    static char func[] = "invoke_log_flusher";
    int i = 0;
    for (; i < d02global.conf_warm.thread_log_max; i++){
        //if( xthread_is_running(d02global.xthread_log[i]) == false ){
            d02global.xthread_log_exit[i] = 0;
            THREAD_INFO *thread_info = calloc(1, sizeof(THREAD_INFO));
            thread_info->id = i;
            int ret = xthread_create( &d02global.xthread_log[i], log_flusher, thread_info);
            if( ret == 0){
                SDFLOG_DEBUG((B,"Create log thread ok"))
            }else{
                SDFLOG_DEBUG((B,"Create log thread failed"))
            }
        //}
    }
    return 0;
}

int log_flusher(void *args){
    static char func[] = "log_flusher";
    int index = 0;
    time_t ct;
    struct tm tm;
    char buff[1024];
    THREAD_INFO *thread_info = (THREAD_INFO*)args;
    for( ;d02global.xthread_log_exit[thread_info->id] == 0; ){
        pthread_mutex_lock( &sdf_buffer.lock);
        while( sdf_buffer.occupied <= 0 ){
            pthread_cond_wait( &sdf_buffer.more, &sdf_buffer.lock);
        }
        index = sdf_buffer.idx_rcv;
        //!- path file
        ct = time (NULL);
        tm = *localtime(&ct);
        if( d02global.conf_warm.log_path[0] == '\0'){
            sprintf (buff, "%s/log/%s.%s_%04d%02d%02d.cdr", d02global.directory, MY_NAME, d02global.instance, 1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday);
        }else{
            sprintf (buff, "%s/%s.%s_%04d%02d%02d.cdr", d02global.conf_warm.log_path, MY_NAME, d02global.instance, 1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday);
        }
        if( rb_write(buff, sdf_buffer.buffer[index]) < 0){
            SDFLOG_ERROR((B, "Thread[%d] writing failed (%s)\n", thread_info->id, strerror(errno)))
        }else if( rb_write(buff, sdf_buffer.buffer[index]) > 0){
            SDFLOG_WARN((B, "Thread[%d] writing not complete. remaining size[%d]", thread_info->id, sdf_buffer.buffer[index]->len))
        }else{
            sdf_buffer.idx_rcv = (index+1)% sdf_buffer.slot_size;
            sdf_buffer.occupied = sdf_buffer.occupied - 1;
            pthread_cond_signal( &sdf_buffer.less );
        }
        pthread_mutex_unlock( &sdf_buffer.lock );
    }
    return 0;
}

static int write_log(const char *level,
                     int pid,
                     const char *file,
                     const char *function,
                     int line,
                     const char *format, ...){
    int len = 0;
    int micro = 0;
    int index = 0;
    va_list ap;
    struct tm tm;
    struct timeval curTime;

    gettimeofday(&curTime, NULL);
    tm = *localtime(&curTime.tv_sec);
    micro = curTime.tv_usec;
    va_start(ap, format);

    pthread_mutex_lock( &sdf_buffer.lock );
    while( sdf_buffer.occupied >= sdf_buffer.slot_size ){
        pthread_cond_wait( &sdf_buffer.less,&sdf_buffer.lock );
    }
    index = sdf_buffer.idx_snd;
    len += sprintf(sdf_buffer.buffer[index]->raw, "%s|%02d:%02d:%02d.%06d|%d|%s|%s|%d|", level, tm.tm_hour, tm.tm_min, tm.tm_sec, micro, pid, file, function, line);
    len += vsprintf(&sdf_buffer.buffer[index]->raw[len], format, ap);
    sdf_buffer.buffer[index]->len = len;
    sdf_buffer.idx_snd = (index + 1) % sdf_buffer.slot_size;
    sdf_buffer.occupied = sdf_buffer.occupied + 1;
    va_end(ap);
    pthread_cond_signal( &sdf_buffer.more );
    pthread_mutex_unlock( &sdf_buffer.lock );
#ifdef SDF_ONDEBUG
    static char func[] = "write_log";
    SDFLOG_DEBUG((B, "WRITE LOG[%d][%.*s]",index, BUFFER_SIZE, sdf_buffer.buffer[index]->raw))
#endif
    return len;
}

static int write_CDR2(  const char *app_id,
                        const char *refer_id,
                        int record_type,
                        const char *record_format,
                        ...){
    int len = 0;
    int micro = 0;
    int index = 0;
    struct tm tm;
    struct timeval curTime;

    gettimeofday(&curTime, NULL);
    tm = *localtime(&curTime.tv_sec);
    micro = curTime.tv_usec;
    va_list ap;
    va_start(ap, record_format);

    /* critical section */
    pthread_mutex_lock( &sdf_buffer.lock );
    while( sdf_buffer.occupied >= sdf_buffer.slot_size ){
        pthread_cond_wait( &sdf_buffer.less,&sdf_buffer.lock );
    }
    index = sdf_buffer.idx_snd;
    len = sprintf(sdf_buffer.buffer[index]->raw, "%s,%s,%02d:%02d:%02d.%06d,%s,",
                  app_id,
                  refer_id,
                  tm.tm_hour,
                  tm.tm_min,
                  tm.tm_sec,
                  micro,
                  record_to_string(record_type));
    len += vsnprintf(&sdf_buffer.buffer[index]->raw[len],
                    (sdf_buffer.buffer[index]->size - sdf_buffer.buffer[index]->len),
                    record_format, ap);
    sdf_buffer.buffer[index]->raw[len++] = '\n';
    sdf_buffer.buffer[index]->len = len;
    sdf_buffer.idx_snd = (index + 1) % sdf_buffer.slot_size;
    sdf_buffer.occupied = sdf_buffer.occupied + 1;
    pthread_cond_signal( &sdf_buffer.more );
    pthread_mutex_unlock( &sdf_buffer.lock );

#ifdef SDF_ONDEBUG
    static char func[] = "write_CDR";
    SDFLOG_DEBUG((B, "WRITE LOG[%d][%.*s]",index, BUFFER_SIZE, sdf_buffer.buffer[index]->raw))
#endif
    va_end(ap);
    return len;
}

static int write_CDR(const char *app_id,
                     const char *refer_id,
                    int record_type,
                    const char *status,
                    const char *reason,
                    const char *record_format,
                    ...){

        int len = 0;
        int micro = 0;
        int index = 0;
        struct tm tm;
        struct timeval curTime;
        char record_detail[1024];

        gettimeofday(&curTime, NULL);
        tm = *localtime(&curTime.tv_sec);
        micro = curTime.tv_usec;
        va_list ap;
        va_start(ap, record_format);
        vsprintf(record_detail, record_format, ap);
        pthread_mutex_lock( &sdf_buffer.lock );
        while( sdf_buffer.occupied >= sdf_buffer.slot_size ){
            pthread_cond_wait( &sdf_buffer.less,&sdf_buffer.lock );
        }
        index = sdf_buffer.idx_snd;
        len = sprintf(sdf_buffer.buffer[index]->raw, "%s,%s,%02d:%02d:%02d.%06d,%s,%s,%s,%s\n", app_id, refer_id, tm.tm_hour, tm.tm_min, tm.tm_sec, micro, record_to_string(record_type), record_detail, status, reason);
        sdf_buffer.buffer[index]->len = len;
        sdf_buffer.idx_snd = (index + 1) % sdf_buffer.slot_size;
        sdf_buffer.occupied = sdf_buffer.occupied + 1;
        pthread_cond_signal( &sdf_buffer.more );
        pthread_mutex_unlock( &sdf_buffer.lock );
#ifdef SDF_ONDEBUG
        static char func[] = "write_CDR";
        SDFLOG_DEBUG((B, "WRITE LOG[%d][%.*s]",index, BUFFER_SIZE, sdf_buffer.buffer[index]->raw))
#endif
        va_end(ap);
        return len;
    }


static jmp_buf log_recovery;
static void log_write_timeout(int sig) { UNUSED(sig); longjmp(log_recovery, 1); }
static char *
lstate_to_string (int state)
{
    static char buff[32];
    switch (state) {
        case LDAP_CLNT_STATE_OPEN:
            strcpy(buff, "CONNECTION_OPEN");
            break;

        case LDAP_CLNT_STATE_CONNECTING:
            strcpy(buff, "CONNECTIONING");
            break;

        case LDAP_CLNT_STATE_READY:
        case LDAP_CLNT_STATE_WAITING:
            strcpy(buff, "CONNECTION_UP");
            break;

        default:
            strcpy(buff, "CLOSED");
            break;
    }

    return buff;
}

static void
status_gen()
{
    char buff[128*1024];
    char host[LDAP_MAX_STRING_HOST];
    int fd, i, n, hi, count=0;
    time_t ct=time(NULL);
    void (*old_sig)(int);

	(void) sprintf (buff, "%s/tmp/status.%s.%d", d02global.directory, MY_NAME, d02global.shm->main.pid);
    if(access(buff, F_OK ) != -1) remove(buff);
    fd = open(buff, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

    n = i = sprintf(buff, "\n============ %s Status (%d) [%s] ============\n", MY_NAME, d02global.shm->main.pid, time_to_string(ct));

	i += sprintf(&buff[i], "DAMOCLES DB PLATFORM VERSION: %s\n", SDF_VERSION);
	i += sprintf(&buff[i], "Uptime: %s\nControl Pause: %s\nMessage Pause: %s\nShutdown: %s\n",
                 time_to_string(d02global.main_start),
                 ((d02global.control_pause)? "YES" : "NO"),
                 ((d02global.msg_count_pause)? "YES" : "NO"),
                 ((d02global.shutdown)? "YES" : "NO"));

    count = LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_SESSION_COUNT, NULL);
	i += sprintf(&buff[i], "Current Incoming HTTP Sessions: %d\n", count);
    if (count>0)
    {
        int c, max_session;
        struct {char host[20]; int count;} *host_list=NULL;

        max_session = LDAP_svr_get_option(d02global.ldapd, LDAP_SERV_OPTION_MAX_SESSION, NULL);
        host_list = SDF_MALLOC(sizeof(*host_list)*(max_session+1));
        for (c=0; c<max_session; ++c)
        {
            if (d02global.ldapd->session[c].sock > 0)
            {
                int hl;
                for (hl=0; hl<count; ++hl)
                {
                    if (strcmp(host_list[hl].host, d02global.ldapd->session[c].remote_ip)==0)
                    {
                        ++(host_list[hl].count);
                        break;
                    }
                }
                if (hl==count)
                {
                    strcpy(host_list[count].host, d02global.ldapd->session[c].remote_ip);
                    host_list[count].count = 1;
                    ++(count);
                }
            }
        }
        for (c=0; c<count; ++c)
        {
            if (host_list[c].count!=0)
            {
                i += sprintf(&buff[i], "Client Host: [%s]\t\t\t\t%d\n",
                             host_list[c].host,
                             host_list[c].count);
            }
        }
        SDF_FREE(host_list);
    }
#ifdef GRPC
    int c = 0;
    HTTP2_CLUSTER *cluster = NULL;
    HTTP2_SERVICE *service = NULL;
    HTTP2_NODE *node = NULL;
    
    for(hi=0; hi < d02global.http2_service_count ; hi++){
        i += sprintf(&buff[i], "Service[%s]\n", HTTP2_SERVICES[hi]->name);
        service = HTTP2_SERVICES[hi];
        for(c = 0; c < service->cluster_count; c++){
            HTTP2_CLUSTER *cluster = service->clusters[c];
            i += sprintf(&buff[i], "-Cluster[%s]\n", cluster->cluster_name);
            
            if( cluster == NULL ) break;
            int cn = 0;
            for(cn = 0; cn < cluster->node_count; cn++){
                node = cluster->nodes[cn];
                if(node == NULL) break;
                HTTP2_CLNT_ADDR *tmp_ls_addr = node->list_addr;
                while(tmp_ls_addr){
                    i += sprintf(&buff[i], "----- grpc://%s:%d -----\n",
                                tmp_ls_addr->host,
                                tmp_ls_addr->port);
                    if( !STRCASEEQ(service->name, "d11")){  
                        i += sprintf(&buff[i], "             Node: %s\n",
                                    tmp_ls_addr->node_name); 
                        i += sprintf(&buff[i], "          cluster: %s\n",
                                    tmp_ls_addr->cluster_name); 
                        i += sprintf(&buff[i], "      link status: %s\n",
                                    LINK_STATUS_TO_STR(tmp_ls_addr->link_status));
                        i += sprintf(&buff[i], "            state: %s\n",
                                    RAFT_STATE_TO_STR(tmp_ls_addr->state));
                    }
                    i += sprintf(&buff[i], "      Connections: %d\n",
                                tmp_ls_addr->connection_count);
                                
                    tmp_ls_addr = tmp_ls_addr->next;
                    if(tmp_ls_addr == node->list_addr){
                        break;
                    }
                }

            i += sprintf(&buff[i], "Total Connections: %d\n\n", node->connection_count);
            }
        }
    }
    
//#else
    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_HOST, host);
        i += sprintf(&buff[i], "----- ldap://%s:%d -----\n",
                     host, LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_PORT, NULL));

        count = LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_CLIENT_COUNT, NULL);
        i += sprintf(&buff[i], "Total LDAP Connections: %d\n", count);
        if (count>0)
        {
            int c;
            LDAP_CLNT *lc;

            for (c=0; c<count; ++c)
            {
                if ((lc=d02global.ldap_list[hi]->client_array[c])!=NULL)
                {
                    i += sprintf(&buff[i], "LDAP [%d:%d]\t%-10d\t\t%s\n",
                                 lc->local_port,
                                 LDAP_clnt_get_option(d02global.ldap_list[hi], LDAP_CLNT_OPTION_PORT, NULL),
                                 lc->concurrent_count,
                                 lstate_to_string(lc->state));
                }
            }
        }
    }
#endif
    while (n>2)
    {
        buff[i++] = '=';
        --(n);
    }
    buff[i++] = '\n';
    buff[i++] = '\n';

    old_sig = signal(SIGALRM, log_write_timeout);
    if (setjmp(log_recovery) == 0)
    {
        (void)alarm(10);
        if (fd >= 0) (void)write(fd, buff, i);
        (void)write(STDERR_FILENO, buff, i);
        (void)alarm(0);
    }
    (void)signal(SIGALRM, old_sig);
    if (fd >= 0)
        (void)close(fd);
}

static int
housekeeper()
{
	static char func[] = "housekeeper";
	int r, ret, n, hi;
	DSSESSION *sess;
    DBLIST *dbl;
    TIMDBLIST *tim_dbl;
    char error[1024];
#ifdef GRPC
    http2_open();
    LDAPMessage_t *lmsg;
    if (http2_query_registry_requst(error) != 0 ){
        SDFLOG_ERROR((B, "http2_query_registry_requst return error[%s]", error))
    }
    
    if (http2_watch_registry_requst(error) != 0 ){
        SDFLOG_ERROR((B, "http2_query_registry_requst return error[%s]", error))
    }
//#else
    if (d02global.conf_warm.migration_mode != DS4_MODE)
    {
        if (l_clnt_open () != 0) ret = -1;
    }
#endif
 #ifdef SYNC_DMCD
 
    (void) send_sync_dmcd();
    if (h_clnt_open() != 0) ret = -1;
 #endif
	ret = 0;
    rauthen_init(&d02global.authen, NULL);

 
    // TODO: Comment for TEST
//	if (l_clnt_open () != 0) ret = -1;
#ifdef XTHREAD_STAT
   //!--Housekeeper check xthread stat running.
   if( xthread_is_running(d02global.xthread_stat) == false )
   {
		d02global.xthread_stat_exit = 0;
	   int _ret_st = xthread_create(&d02global.xthread_stat, stat_thread , NULL );
	   if( _ret_st == 0 )
	   {
		   SDFLOG_DEBUG((B,"Re-Create stat thread ok"))
	   }
	   else
	   {
		   SDFLOG_DEBUG((B,"Re-Create stat thread failed"))
	   }
   }

#endif

    // Flush data
    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        r = LDAP_clnt_send_message (d02global.ldap_list[hi], NULL, NULL, fd_set_write, NULL);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_clnt_send_message return error"))
            ret = -1;
        }

        r = LDAP_clnt_keep_alive(d02global.ldap_list[hi], NULL);
        if (r != LDAP_RET_OK)
        {
            SDFLOG_ERROR((B, "LDAP_clnt_send_message return error"))
            ret = -1;
        }
    }

    r = 0;
    while ((dbl = d02global.dbl) != NULL)
    {
        n = (int)(time (NULL) - dbl->time);
        if (n < d02global.conf_warm.sdfdb_time_to_wait) break;
        SDFLOG_INFO((B, "Message session[%.*s] purged",dbl->node->hash_key_len,dbl->node->hash_key))
        LINKEDLIST_REMOVE(d02global.dbl,dbl);
        HASH_REMOVE(&(d02global.htable),dbl->node)
        --(d02global.sdfdb_count);
        ++(d02global.sdfdb_purge_count);
        ++(r);

        sess = dbl->node->ref;
        if ((sess!=NULL)&&(sess->sock >= 0))
        {            
            l_sess_send_error(sess, dbl->node->lmsg, LDAP_RESULT_UNAVAILABLE, "");
            if ((lmsg=sess->rdata)!=NULL)
            {
                LINKEDLIST_REMOVE(sess->rdata, lmsg);
                SDF_FREE(lmsg);
            }

            if (SDF_log_level() & SDFLOG_LEVEL_INFO)
            {
                sess->write_count = sess->total_wait_write_io = 0;
                gettimeofday(&(sess->timestamp_write),0);
            }
        }
        else
        {
            SDFLOG_WARN((B, "Incomming session's gone"))
        }
        /*
        if (dbl->node->instance != NULL)
        {
            SDF_FREE(dbl->node->instance)
            dbl->node->instance = NULL;
        }
        if (dbl->node != NULL)
        {
            SDF_FREE(dbl->node);
            dbl->node = NULL;
        }
        */
    }
    if (r>0) SDFLOG_INFO((B, "edb_db_purge purged (%d) message", r));

    r = 0;
    while((tim_dbl = d02global.tim_dbl) != NULL)
    {
        n = (int)(time (NULL) - tim_dbl->time);
        if(n < d02global.conf_warm.tim_dbl_expiry_time) break;
        // if(n < 2) break;
        SDFLOG_INFO((B, "Transaction ID [%d] expired", tim_dbl->node->l_sess_tid))
        SDFLOG_DEBUG((B, "d02global.tim_dbl [%p]", d02global.tim_dbl))
        if (d02global.tim_dbl != NULL)
        {
            LINKEDLIST_REMOVE(d02global.tim_dbl, tim_dbl);
        }
        HASH_REMOVE(&(d02global.trans_id_map),tim_dbl->node)
        ++r;

        sess = tim_dbl->node->ref;
        if ((sess!=NULL)&&(sess->sock >= 0))
        {
            --(sess->concurrent_count);
        }
    }
    if (r>0) SDFLOG_INFO((B, "Transactions have been purged (%d) IDs", r));

    char err[MY_ERR_BUFFER_SIZE];
    while (LDAP_sess_examine(d02global.ldapd, fd_clear, err)==LDAP_RET_ERR_IDLE_TIMEOUT)
    {
        SDFLOG_WARN((B, "LDAP_verify_connection return error[%s]", err))
    }

	return ret;
}

#ifdef XTHREAD_STAT
time_t calc_next_stat_gen(time_t start_time, int interval, int alignment)
{
	time_t ct;
	if (start_time == 0) ct = time(NULL);
	else ct = start_time + 1;
	return ct + (interval - ((((ct % 60) + 60) - alignment) % interval));
}

int stat_thread(void * param)
{
	time_t nt = calc_next_stat_gen(0, d02global.conf_warm.stat_interval, d02global.conf_warm.stat_alignment);
	while(d02global.xthread_stat_exit == 0)
	{
		time_t ct = time (NULL);
		if (ct >= nt)
		{
			(void) stat_gen ();
			nt = calc_next_stat_gen(ct, d02global.conf_warm.stat_interval, d02global.conf_warm.stat_alignment);
		}
		sleep(1);
	}
	(void) stat_gen ();
    UNUSED(param);
	return 0;
}

#endif

#ifdef USE_RPC
static void call_rpc(){
    static char func[] = "call_rpc";
	D21Client *D21 = new_D21Client("127.0.0.1:50051");

	Request *req = new_Request();
	Response *res = new_Response();

	/* create Request */
	Req_set_BaseDn(req, "dc=C-NTDB");
	Req_set_Filter(req, "");
	Req_set_Method(req, GET);
	Req_set_Scope(req, Subtree);
	Req_set_Dn(req, "dc=C-NTDB");

	/* Send Request */
	c_Do_param(D21, req, res);

	/* Recv Request */
    SDFLOG_DEBUG((B, "Response Result: %d", Res_ResultCode(res)));
	SDFLOG_DEBUG((B, "Matcheddn :: %s\n", Res_MatchedDn(res)));
    SDFLOG_DEBUG((B, "referrals size :: %d\n", Res_Referrals_Size(res)));

	/* Print Refferals */
	int i = 0;
	int r = Res_Referrals_Size(res);
	for ( ;i < r; i++){
        SDFLOG_DEBUG((B, "referrals i :: %d = %s\n",i,Res_Referrals_Index(res, i)));
	}

	/* Print Entry */
	i = 0;
	r = Res_Entry_Size(res);
	for ( ;i < r; i++){
	Entry *e = (Entry*)Res_entries(res, i); 
	SDFLOG_DEBUG((B, "Entry [%d]\n",i));
	SDFLOG_DEBUG(("Dn      : %s\n", Res_Entry_Dn(e)));
	SDFLOG_DEBUG(("Methode : %d\n", Res_Entry_Method(e)));

	int a_len = Res_EntryAttribute_Size(e);
	int j = 0;

     for( ;j < a_len; j++){
		EntryAttribute *ea = (EntryAttribute *)Res_EntryAttributes_Index(e, j);
		SDFLOG_DEBUG((B, "-Attr name[%s]\n", Res_EntryAttribute_Name(ea)));
		SDFLOG_DEBUG((B, "-Attr value[%s]\n", Res_EntryAttribute_Value(ea,0)));
		}
	}

}
#endif

static int
main_loop()
{
	static char func[] = "main_loop";
	int cc, r, pause, wconf;
	pid_t pid;
	time_t ct, ht;
#ifdef XTHREAD_STAT
	int wait_stat_thread = 0;
#else
	time_t st;
#endif

	d02global.main_start = time(NULL);
	d02global.shm->main.kill = d02global.shm->main.pid = d02global.shm->main.response = pid = d02global.main_pid = getpid();

    d02global.ldap_host_index = 0;
    d02global.ldap_ext_index = 0;
    d02global.ldap_ready_flag = 0;
#ifdef GRPC
    http2_open();
    char error[1024];
    if ( http2_query_registry_requst(error) != 0 ){
        SDFLOG_ERROR((B, "http2_test_send return error[%s]", error))
    }
//#else
    if (d02global.conf_warm.migration_mode != DS4_MODE)
    {
        l_clnt_open();
    }
#endif
    
#ifdef SYNC_DMCD
    if( test_h_clnt_open() == HTTP_CLNT_RET_OK ){
        SDFLOG_INFO((B, "Test Open Connnection to DMCD success."))
    }else{
        SDFLOG_INFO((B, "Test Open Connnection to DMCD fail."))
    }
#endif

#ifdef XTHREAD_STAT
   d02global.xthread_stat_exit = 0;
   int _ret_st = xthread_create(&d02global.xthread_stat, stat_thread , NULL );
   if( _ret_st == 0 )
   {
	   SDFLOG_DEBUG((B,"Create stat thread ok"))
   }
   else
   {
	   SDFLOG_DEBUG((B,"Create stat thread failed"))
   }

#endif

#ifdef USE_RPC
	//call_rpc();
#endif

//!- create log flusher
    invoke_log_flusher();

	SDFLOG_INFO((B, "Ready"))
	if (d02global.ipc_sock >= 0)
	{
		write(d02global.ipc_sock, "\x00", 1);
		close(d02global.ipc_sock);
		d02global.ipc_sock = -1;
	}

	ht = 0;
#ifndef XTHREAD_STAT
	st = 0;
#endif
	cc = 0;
	sleep(0);

	pause = d02global.shm->pause;
	wconf = d02global.shm->conf;
	if (pause)
	{
		d02global.control_pause = 1;
		SDFLOG_INFO((B, "Control PAUSE"))
	}
	for (;;)
	{
		if (d02global.shutdown)
		{
            break;
/*
			if (d02global.sf_clnt_count <= 0 && d02global.hs_session_count <= 0)
				break;*/
		}
		else if (d02global.shm->main.kill != pid || d02global.shm->main.pid != pid || d02global.shm->main.response != pid)
		{
			sleep(0);
			if (d02global.shm->main.kill == -1)
			{
				if (d02global.shutdown == 0)
				{
                    int hi;
                    shutdown_thread();
					SDFLOG_INFO((B, "Beginning shutdown"))
					d02global.shutdown = 1;
					pause = d02global.control_pause = 1;
                    //!- shutdown log thread
                    shutdown_thread();
					SDFLOG_INFO((B, "Control PAUSE"))
                    for (hi=0; hi<d02global.ldap_list_count; hi++)
                        LDAP_clnt_close_all(d02global.ldap_list[hi], NULL);
					//hs_svr_close_listener(); //--> this should be done in cleanup
				}
			}
			else
			{
				SDFLOG_FATAL((B, "Shared memory has been altered"))
				SDFLOG_INFO((B, "Process terminated"))
				d02global.shm->main.response = 0;
				return -1;
			}
		}

		++(d02global.shm->main.active);
		if (pause != d02global.shm->pause && d02global.shutdown == 0)
		{
			sleep(0);
			pause = d02global.shm->pause;
			if (TO_BOOL(pause) != TO_BOOL(d02global.control_pause))
			{
				if (pause)
				{
					d02global.control_pause = 1;
					SDFLOG_INFO((B, "Control PAUSE"))
				}
				else
				{
					d02global.control_pause = 0;
					SDFLOG_INFO((B, "Control RESUME"))
				}
			}
		}

		r = epoll_event_process(d02global.base_epoll);
		++cc;


		if (r == 0 || cc > 10)
		{
			cc = 0;
			if (wconf != d02global.shm->conf && d02global.shutdown == 0)
			{
				sleep(0);
				wconf = d02global.shm->conf;
				SDFLOG_INFO((B, "Reload warm config"))
				config_load_warm();
			}
/*			if (d02global.msg_count_pause && d02global.sf_send_msg_queue_count <= d02global.conf_warm.sf_low_msg_count)
			{
				d02global.msg_count_pause = 0;
				SDFLOG_INFO((B,"LowMessageCount ACCEPT"))
				//SDFLOG_INFO((B, "LowMessageCount RESUME"))
				//if (d02global.control_pause == 0)
				//	sf_send_control(d02global.msg_count_pause);
			}*/
			ct = time(NULL);
#ifndef XTHREAD_STAT
			if (d02global.conf_warm.stat_interval > 0 && (ct - st) > d02global.conf_warm.stat_interval)
			{
				stat_gen();
				st = ct;
			}
#endif
            if (d02global.shm->status==1)
            {
                status_gen();
                d02global.shm->status = d02global.shm->main.pid;
            }
#ifdef STAT_RESET
            if (d02global.shm->clearstats)
            {
                d02global.stat_reset_time = 0;
                d02global.shm->clearstats = 0;
            }
			if (ct >= (d02global.stat_reset_time + (d02global.conf_warm.stat_reset_interval * 60)))
            {
				stat_reset();
			}
#endif
			if ((ct - ht) >= d02global.conf_warm.housekeeper_interval)
			{
				housekeeper();
				ht = ct;
			}
			
		}
	}

#ifdef XTHREAD_STAT
	d02global.xthread_stat_exit = 1;
	while (xthread_is_running(d02global.xthread_stat) != false && wait_stat_thread < 5)
	{
		sleep(1);
		wait_stat_thread++;
	}
#else
	stat_gen();
#endif

	SDFLOG_INFO((B, "Shutdown completed, process terminated"))
	d02global.shm->main.response = 0;
	return 0;
}

static int
fmon_loop()
{
	static char func[] = "fmon_loop";
	int r, s;
	int wconf;
	pid_t pid;
	time_t st
;
	d02global.fmon_start = time(NULL);
	d02global.fmon_fault_count = 0;
#ifdef STAT_RESET
	d02global.stat_reset_time = 0;
#endif
	d02global.shutdown = 0;
	d02global.shm->fmon.kill = d02global.shm->fmon.pid = d02global.shm->fmon.response = pid = d02global.fmon_pid = getpid();
	r = fork();
	if (r < 0)
	{
		SDFLOG_FATAL((B, "fork return error [%s]", strerror(errno)))
		SDFLOG_INFO((B, "Process terminated"))
		write(d02global.ipc_sock, "\xFF", 1);
		close(d02global.ipc_sock);
		d02global.ipc_sock = -1;
		return -1;
	}
	if (r == 0)
		return main_loop();
	close(d02global.ipc_sock);
	d02global.ipc_sock = -1;

	SDFLOG_INFO((B, "Ready"))

	wconf = d02global.shm->conf;
	st = 0;
	for (;;)
	{
		if (st > 0 && (time(NULL) - st) >= d02global.conf_warm.restart_delay)
		{
			SDFLOG_INFO((B, "Restart process"))
			st = 0;
			r = fork();
			if (r < 0)
			{
				SDFLOG_FATAL((B, "fork return error [%s]", strerror(errno)))
				SDFLOG_INFO((B, "Process terminated"))
				d02global.shm->fmon.response = 0;
				d02global.shm->fmon.kill = -1;
				d02global.shm->main.kill = -1;
				return -1;
			}
			if (r == 0)
				return main_loop();
			sleep(1);
		}
		++(d02global.shm->fmon.active);
		sleep(3);

		if (d02global.shm->fmon.kill != pid || d02global.shm->fmon.pid != pid || d02global.shm->fmon.response != pid)
		{
			if (d02global.shm->fmon.kill == -1)
				break;
			SDFLOG_FATAL((B, "Shared memory has been altered"))
			SDFLOG_INFO((B, "Process terminated"))
			d02global.shm->fmon.response = 0;
			d02global.shm->fmon.kill = -1;
			d02global.shm->main.kill = -1;
			return -1;
		}

		if (wconf != d02global.shm->conf)
		{
			sleep(0);
			wconf = d02global.shm->conf;
			SDFLOG_INFO((B, "Reload warm config"))
			config_load_warm();
		}

		if (st > 0)
			continue;

		r = waitpid(-1, &s, WNOHANG);
		if (r < 0)
		{
			if (errno == EINTR)
				continue;
			SDFLOG_FATAL((B, "waitpid return error [%s]", strerror(errno)))
			SDFLOG_INFO((B, "Process terminated"))
			d02global.shm->fmon.response = 0;
			d02global.shm->fmon.kill = -1;
			d02global.shm->main.kill = -1;
			return -1;
		}
		if (r == 0)
			continue;

		if (WIFEXITED(s))
		{
			SDFLOG_INFO((B, "Process %d normal termination, exit status = %d", r, WEXITSTATUS(s)))
		}
		else if (WIFSIGNALED(s))
		{
#ifdef WCOREDUMP
			SDFLOG_INFO((B, "Process %d abnormal termination on signal [%s]%s", r, signal_to_string(WTERMSIG(s)), WCOREDUMP(s)? " (core dumped)" : ""))
#else
			SDFLOG_INFO((B, "Process %d abnormal termination on signal [%s]", r, signal_to_string(WTERMSIG(s))))
#endif         
		}
		else if (WIFSTOPPED(s))
			SDFLOG_INFO((B, "Process %d stop on signal %s", r, signal_to_string(WTERMSIG(s))))
		else
			SDFLOG_INFO((B, "Process %d terminate with unknown exit status = %X(hex)", r, s))
		++(d02global.fmon_fault_count);
		st = time(NULL);
		SDFLOG_INFO((B, "Will restart process after (%d) second", d02global.conf_warm.restart_delay))
	}

	SDFLOG_INFO((B, "Process terminated"))
	d02global.shm->fmon.response = 0;
	d02global.shm->fmon.kill = -1;
	d02global.shm->main.kill = -1;
	return 0;
}


static int
shm_open(int creat)
{
	static char func[] = "shm_open";
	char buff[1024];
	int fd;
    key_t key;

	sprintf(buff, "%s/ipc/%s.%s.shm", d02global.directory, MY_NAME, d02global.instance);
	fd = open(buff, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
	if (fd >= 0)
		close(fd);
	if (access(buff, R_OK) != 0)
	{
		SDFLOG_FATAL((B, "access [%s] return error [%s]", buff, strerror(errno)))
		return -1;
	}
    key = 0x0D020000 + atoi(d02global.instance);
	if (creat)
		d02global.shm_id = shmget(key, sizeof(*(d02global.shm)), S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|IPC_CREAT|IPC_EXCL);
	else
		d02global.shm_id = shmget(key, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
	if (d02global.shm_id < 0)
	{
		SDFLOG_FATAL((B, "shmget return error [%s]", strerror(errno)))
		return -1;
	}
	d02global.shm = (RAHS_SHM*)shmat(d02global.shm_id, NULL, 0);
	if (d02global.shm == (RAHS_SHM *) - 1)
	{
		SDFLOG_FATAL((B, "shmat return error [%s]", strerror(errno)))
		d02global.shm = NULL;
		shmctl(d02global.shm_id, IPC_RMID, NULL);
		d02global.shm_id = -1;
		return -1;
	}
	return 0;
}


static int
shm_close()
{
	static char func[] = "shm_close";
	int ret;

	ret = 0;
	if (d02global.shm != NULL)
	{
		if (shmdt((char *)d02global.shm) != 0)
		{
			SDFLOG_FATAL((B, "shmdt return error [%s]", strerror(errno)))
			ret = -1;
		}
		d02global.shm = NULL;
	}
	return ret;
}


static int
shm_remove()
{
	static char func[] = "shm_remove";
	int ret;

	ret = 0;
	if (d02global.shm != NULL)
	{
		if (shmdt((char *)d02global.shm) != 0)
		{
			SDFLOG_FATAL((B, "shmdt return error [%s]", strerror(errno)))
			ret = -1;
		}
		d02global.shm = NULL;
	}
	if (d02global.shm_id >= 0)
	{
		if (shmctl(d02global.shm_id, IPC_RMID, NULL) != 0)
		{
			SDFLOG_FATAL((B,"shmctl return error [%s]",strerror (errno)))
			ret = -1;
		}
		d02global.shm_id = -1;
	}
	return ret;
}


static int
wait_for_daemon(int ipc_sock, int tout)
{
   static char func[] = "wait_for_daemon";
   char buff[1024];
   fd_set rfd;
   int r;
   struct timeval tv;
   time_t st;

   st = time (NULL);
   for (;;)
   {
      tv.tv_sec = 1;
      tv.tv_usec = 0;
      FD_ZERO(&rfd);
      FD_SET(ipc_sock, &rfd);
      r = select (ipc_sock+1, &rfd, NULL, NULL, &tv);
      if (r < 0)
      {
         if (errno != EINTR)
         {
            SDFLOG_ERROR((B,"select return error [%s]", strerror(errno)))
            return -1;
         }
      }
      if (r > 0)
      {
         r = (int) read (ipc_sock, buff, 1);
         if (r < 0)
         {
            SDFLOG_ERROR((B,"read return error [%s]",strerror (errno)))
            return -1;
         }
         if (r == 0)
         {
            SDFLOG_ERROR((B,"socketpair has been closed"))
            return -1;
         }
         return ((unsigned char *)buff)[0];
      }
      if ((time (NULL) - st) > tout)
         break;
   }
   return -1;
}


static int
startup ()
{
   static char func[] = "startup";
   int fd, r, sk[2];
   pid_t pid;
   struct rlimit rl;
   struct sigaction sa;
#define _SU_CLOSE(_fd)                                                 \
{                                                                      \
   if ((_fd) >= 0)                                                     \
   {                                                                   \
      if (close ((_fd)) != 0)                                          \
         SDFLOG_ERROR((B,"close return error [%s]",strerror (errno)))  \
      (_fd) = -1;                                                      \
   }                                                                   \
}
#define _SU_CLEANUP                                                    \
{                                                                      \
   _SU_CLOSE(fd)                                                       \
   _SU_CLOSE(sk[0])                                                    \
   _SU_CLOSE(sk[1])                                                    \
   (void) shm_close ();                                                \
}
#define _SU_RET_ERROR                                                  \
{                                                                      \
   if (sk[1] >= 0)                                                     \
      (void) write (sk[1], "\xFF", 1);                                 \
   _SU_CLEANUP                                                         \
   return -1;                                                          \
}

    fd = -1;
    sk[0] = sk[1] = -1;

    d02global.shm_id = -1;
    d02global.ipc_sock = -1;

    if (shm_open (1) != 0)
        return -1;
    (void) memset (d02global.shm, 0, sizeof(*(d02global.shm)));
    sleep (0);

    /* make sure all STDXX are opened */
    fd = open ("/dev/null", O_RDWR);
    for (;;)
    {
        if (fd == STDIN_FILENO || fd == STDOUT_FILENO || fd == STDERR_FILENO)
            fd = dup (fd);
        else
        {
            (void) close (fd);
            break;
        }
    }
    fd = -1;

    /* create ipc socket */
    if (socketpair (AF_UNIX, SOCK_STREAM, 0, sk) != 0)
    {
        SDFLOG_FATAL((B,"socketpair return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }

    if ((pid = fork ()) < 0)
    {
        SDFLOG_FATAL((B,"fork return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    else if (pid != 0)
    {
        /* never return */
        _SU_CLOSE(sk[1])
        /* wait */
        r = wait_for_daemon (sk[0], 30);
        _SU_CLOSE(sk[0])
        if (r != 0)
        {
            (void) fprintf (stderr, "%s %s start failed\n", MY_NAME, d02global.instance);
            (void) fflush (NULL);
            exit (1);
        }
        (void) fprintf (stdout, "%s %s start OK\n", MY_NAME, d02global.instance);
        (void) fflush (NULL);
        exit (0);
    }

    /* starting daemon */
    _SU_CLOSE(sk[0])
    (void) sleep (1);

    umask (0);
    SDFLOG_INFO((B, "Starting...")) // Fix starting problem in RHEL6

    if (getrlimit (RLIMIT_NOFILE, &rl) < 0)
    {
        SDFLOG_FATAL((B,"getrlimit return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }

    if ((pid = fork ()) < 0)
    {
        SDFLOG_FATAL((B,"fork return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    else if (pid != 0)
        exit (0);
    setsid ();

    sa.sa_handler = SIG_IGN;
    sigemptyset (&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction (SIGHUP, &sa, NULL) < 0)
    {
        SDFLOG_FATAL((B,"sigaction return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    if (sigaction (SIGPIPE, &sa, NULL) < 0)
    {
        SDFLOG_FATAL((B,"sigaction return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    if ((pid = fork ()) < 0)
    {
        SDFLOG_FATAL((B,"fork return error [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    else if (pid != 0)
    {
        SDFLOG_ERROR((B,"exit (0)"))
        exit (0);
    }

    if (rl.rlim_max == RLIM_INFINITY) rl.rlim_max = 1024;
    rl.rlim_cur = rl.rlim_max = HTTP_MAX_SESSION + 50;
#define NO_RLIMIT
#ifndef NO_RLIMIT
    if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
    {

        SDFLOG_ERROR((B, "setrlimit(%d) error. Please extend open file limit -> http://docs.basho.com/riak/latest/ops/tuning/open-files-limit/ ", HTTP_MAX_SESSION))

                _SU_RET_ERROR;

    }
#endif
    //SDFLOG_DEBUG((B, "RLIMIT current -> [%llu] max -> [%llu]", rl.rlim_cur, rl.rlim_max))
    for (fd = 0; fd < (int)rl.rlim_max; fd++)
    {
        if (fd != sk[1])
            (void) close (fd);
    }
    fd = open ("/dev/null", O_RDWR);
    dup2 (fd, STDIN_FILENO);
    dup2 (fd, STDOUT_FILENO);
    dup2 (fd, STDERR_FILENO);
    if (fd != STDIN_FILENO &&
        fd != STDOUT_FILENO &&
        fd != STDERR_FILENO)
    {
        (void) close (fd);
    }
    fd = -1;

    SDFLOG_INFO((B, "Initialized local variables..."))
    d02global.base_epoll = epoll_base_new( HTTP_MAX_SESSION, 128 , 1 );
    if( d02global.base_epoll != NULL)
    {
        //my_rah.base_epoll->timeout_callback = base_epoll_timeout_callback;
    }
    else
    {
        SDFLOG_FATAL((B,"cannot init epoll [%s]",strerror (errno)))
        _SU_RET_ERROR;
    }
    memset (&(d02global.htable), 0, sizeof(d02global.htable));
    d02global.htable.hash_bucket = sizeof(d02global.htable.hash_array) / sizeof(d02global.htable.hash_array[0]);
    d02global.dbl = NULL;

    memset (&(d02global.trans_id_map), 0, sizeof(d02global.trans_id_map));
    d02global.trans_id_map.hash_bucket = sizeof(d02global.trans_id_map.hash_array) / sizeof(d02global.trans_id_map.hash_array[0]);
    d02global.tim_dbl = NULL;
    
    //init host_equiv
    rauthen_init(&d02global.authen, NULL);

#ifdef SYNC_DMCD
    /* init cluster group */
    //TODO : change bucket size.
    unsigned long clusterID = -9;
    char error[1024];
    hmap_init(2048, &d02global.cluster_group);
    test_create_cluster("50");
    test_create_cluster("100");
    test_create_cluster("200");
    make_cluster_array();
    
    if ( get_cluster_by_UID("30", &clusterID, error) != 0 ){
        SDFLOG_ERROR((B, "get_cluster_by_UID return error[%s]", error))
    }else{
        SDFLOG_DEBUG((B, "UID : 30 will go to cluster : %lu", clusterID))
    }
    
    if ( get_cluster_by_UID("201", &clusterID, error) != 0 ){
        SDFLOG_ERROR((B, "get_cluster_by_UID return error[%s]", error))
    }else{
        SDFLOG_DEBUG((B, "UID : 201 will go to cluster : %lu", clusterID))
    }
#endif


    /* read common config */
    // SDFLOG_INFO((B, "Loaded common configuration..."))
    // if (config_load_common () != 0)
    //     _SU_RET_ERROR;

    /* read cold config */
    SDFLOG_INFO((B, "Loaded cold configuration..."))
    if (config_load_cold () != 0)
        _SU_RET_ERROR;
        
    /* init after read cold config */
    SDFLOG_INFO((B, "Start LDAP service..."))
    if (l_svr_open () != 0)
        _SU_RET_ERROR;
            
    /* read warm config */
    SDFLOG_INFO((B, "Loaded warm configuration..."))
    if (config_load_warm () != 0)
        _SU_RET_ERROR;

    /* read application config */
    SDFLOG_INFO((B, "Loaded Application configuration..."))
    if (config_load_common () != 0)
        _SU_RET_ERROR;

    /* init after read warm config */
    d02global.ipc_sock = sk[1];

    /* init log buffer */
    rb_init(&sdf_buffer, 32);

    SDF_random(&ds_tid, sizeof(ds_tid)-1);
    SDF_random(&grpc_tid, sizeof(grpc_tid)-1);
    // SDF_random(&trans_id, sizeof(trans_id)-1);
    trans_id = 100;
    SDFLOG_DEBUG((B, "init trans_id: %d", trans_id))
    char gidKey[512];
    uint64_t ghn;
    gethostname(gidKey, 256);
    strcat(gidKey, d02global.instance);
    HASH_COMPUTE(gidKey, strlen(gidKey), ghn)
    SDFLOG_DEBUG((B, "GID key: %s | hash: %lu", gidKey, ghn))
    ghn %= 1000000;
    d02global.gid_prefix = ghn*100000000000;
    SDFLOG_DEBUG((B, "GID prefix: %06u (%lu)", ghn, d02global.gid_prefix))

#ifdef GRPC
    d02global.D11_status = D11_STATUS_UNSYNC;
    int i = 0;
    for(i = 0;i < MAX_SEARCH_ATTRS; i++){
        d02global.global_search_attributes[i] = malloc(sizeof(char) * MAX_ATTRS_LENGTH);
    }
    DEFAULT_CLUSTER_D21[0] = 0;
    DEFAULT_CLUSTER_D20[0] = 0;
    ds2a_setup_default();
#endif
    return 0;
}

static int
cleanup ()
{
    static char func[] = "cleanup";
    int ret=0, hi;

    SDFLOG_DEBUG((B, "Cleaning up"))

    rauthen_free(d02global.authen, NULL);

    for (hi=0; hi<d02global.ldap_list_count; hi++)
    {
        LDAP_clnt_free(d02global.ldap_list[hi]);
    }

    if (LDAP_svr_close(d02global.ldapd, fd_clear, NULL) != HTTP_RET_OK)
        ret = -1;

    LDAP_svr_free(d02global.ldapd);

    epoll_base_delete(d02global.base_epoll);

 #ifdef SYNC_DMCD
    cluster_group_cleanup();
 #endif
    SDF_SHOW_MEM

    if(d02global.conf_warm.matching_rule_count > 0)
    {
        MatchingRule *mr = NULL;
        for(hi=0; hi<d02global.conf_warm.matching_rule_count; hi++)
        {
            mr = d02global.conf_warm.matching_rule[hi];
            switch(mr->mode)
            {
                case MATCHING_RULE_PREFIX :
                    free(mr->prefix.trie);
                    break;
                case MATCHING_RULE_MAXMIN :
                    break;
                case MATCHING_RULE_RANGE :
                    break;
                default:
                    break;
            }
        }
    }

    if(d02global.conf_warm.migration_state != NULL)
    {
        for (hi=0; hi<MIGRATION_STATE_NUM; hi++)
        {
            free(d02global.conf_warm.migration_state->list[hi]);
        }
        free(d02global.conf_warm.migration_state->trie);
        free(d02global.conf_warm.migration_state);
    }
    hmap_destroy(&d02global.global_conf.adaptive_naming_dn);
    hmap_destroy(&d02global.global_conf.adaptive_naming);
    hmap_destroy(&d02global.global_conf.attributevalue_mapping);
    hmap_destroy(&d02global.global_conf.invert_adaptive_naming);
    hmap_destroy(&d02global.global_conf.variant_db);
    hmap_destroy(&d02global.global_configuration);

    return ret;
}

static int
cmd_start ()
{
   if (startup () != 0)
   {
      shm_remove();
      return -1;
   }
   if (fmon_loop () != 0)
   {
      (void) cleanup ();
      return -1;
   }
   if (cleanup () != 0)
      return -1;
   
   return 0;
}

static int
cmd_stop ()
{
   int fa, ffa, fs, ma, mma, ms;
   time_t st;
   if (shm_open (0) != 0)
      return -1;
   sleep (0);
   ffa = fa = d02global.shm->fmon.active;
   mma = ma = d02global.shm->main.active;
   d02global.shm->main.kill = -1;
   d02global.shm->fmon.kill = -1;
   fs = 0;
   ms = 0;
   st = time (NULL);
   for (;;)
   {
      sleep (1);
      if (fs == 0)
      {
         if (d02global.shm->fmon.response == 0)
         {
            fs = 1;
            (void) fprintf (stderr, "fmon process (%d) stop\n", d02global.shm->fmon.pid);
         }
         else if (fa != d02global.shm->fmon.active)
         {
            fa = d02global.shm->fmon.active;
            (void) write (STDOUT_FILENO, "+", 1);
         }
      }
      if (ms == 0)
      {
         if (d02global.shm->main.response == 0)
         {
            ms = 1;
            (void) fprintf (stderr, "main process (%d) stop\n", d02global.shm->main.pid);
         }
         else if (ma != d02global.shm->main.active)
         {
            ma = d02global.shm->main.active;
            (void) write (STDOUT_FILENO, ".", 1);
         }
      }
      if (fs && ms)
         break;
      if ((time (NULL) - st) > 120)
      {
         if (fs == 0)
         {
            sleep (0);
            (void) fprintf (stderr, "fmon process (%d) %s\n", d02global.shm->fmon.pid,
                                    (d02global.shm->fmon.response == 0)? "stop" : ((ffa == d02global.shm->fmon.active)? "not respond" : "still working"));
         }
         if (ms == 0)
         {
            sleep (0);
            (void) fprintf (stderr, "main process (%d) %s\n", d02global.shm->main.pid,
                                     (d02global.shm->main.response == 0)? "stop" : ((mma == d02global.shm->main.active)? "not respond" : "still working"));
         }
         (void) fflush (NULL);
         (void) shm_remove ();
         return -1;
      }
   }
   (void) fflush (NULL);
 #ifdef SYNC_DMCD
   cluster_group_cleanup();
 #endif
   if (shm_remove () != 0)
      return -1;
   return 0;
}

static int
cmd_reload ()
{
   if (shm_open (0) != 0)
      return -1;
   sleep (0);
   ++(d02global.shm->conf);
   if (shm_close () != 0)
      return -1;
   return 0;
}

static int
cmd_pause (int pause)
{
   if (shm_open (0) != 0)
      return -1;
   sleep (0);
   d02global.shm->pause = pause;
   if (shm_close () != 0)
      return -1;
   return 0;
}

static int
cmd_status ()
{
    time_t ct=time(NULL);
    if (shm_open (0) != 0)
        return -1;
    sleep (0);
    d02global.shm->status = 1;
    (void)fprintf(stdout, "Sync with working process");
    fflush(stdout);
    while ((time(NULL)-ct<5)&&(d02global.shm->status==1))
    {
        (void)fprintf(stdout, ".");
        fflush(stdout);
        usleep(500000);
    }
    (void)fprintf(stdout, "\n");
    if (d02global.shm->status==0)
    {
        (void)fprintf(stdout, "Status report is disable\n");
    }
    else if (d02global.shm->status==1)
    {
        (void)fprintf(stderr, "Cannot show status due to process is busy or unreachable\n");
    }
    else
    {
        int fd, r;
        char buff[128*1024];
        struct flock lck;
        struct stat st;

        d02global.shm->status = 0;
        (void)sprintf(buff, "%s/tmp/status.%s.%d", d02global.directory, MY_NAME, d02global.shm->main.pid);
        fd = open (buff, O_RDONLY);
        if (fd < 0)
        {
            (void)fprintf(stderr, "open [%s] return error [%s]\n", buff, strerror (errno));
            goto status_end;
        }
        lck.l_type = F_RDLCK;
        lck.l_start = 0;
        lck.l_whence = SEEK_SET;
        lck.l_len = 0;
        if (fcntl (fd, F_SETLKW, &lck) < 0)
        {
            (void)fprintf(stderr, "fcntl return error [%s]",strerror (errno));
            (void) close (fd);
            goto status_end;
        }
        if (fstat (fd, &st) != 0)
        {
            (void)fprintf(stderr, "fstat return error [%s]",strerror (errno));
            (void) close (fd);
            goto status_end;
        }
        r = (int) read (fd, buff, st.st_size);
        if (r < 0)
        {
            (void)fprintf(stderr, "read return error [%s]",strerror (errno));
            (void) close (fd);
            goto status_end;
        }
        if (r != st.st_size)
        {
            (void)fprintf(stderr, "read return (%d), expected (%d)",r,(int)st.st_size);
            (void) close (fd);
            goto status_end;
        }
        if (close (fd) != 0)
        {
            (void)fprintf(stderr, "close return error [%s]\n",strerror (errno));
            goto status_end;
        }
        (void)fprintf(stdout, "%s", buff);
        (void)sprintf(buff, "%s/tmp/status.%s.%d", d02global.directory, MY_NAME, d02global.shm->main.pid);
        r = remove(buff);
    }
status_end:
    if (shm_close () != 0)
        return -1;
    return 0;
}

#ifdef STAT_RESET
static int cmd_clearstats()
{
   if (shm_open(0) != 0)
      return -1;
   sleep(0);
   d02global.shm->clearstats = 1;
   if (shm_close() != 0)
      return -1;
   return 0;
}
#endif


static int
init_name (char *process, char *instance)
{
#ifndef SDFLOG_SPLIT
	char buff[1024];
#endif
    char *str, *pch=NULL;
    char logDirectory[300];

    (void) memset (&d02global, 0, sizeof(d02global));
    str = process;
    do {
        pch = strchr(str, '/');
        if (pch!=NULL) str = pch + 1;
    } while (pch!=NULL);
    memcpy(d02global.directory, process, str-process-1);
    strcat(d02global.directory, "/..");
    STRCPY(d02global.instance,instance);

    /* init SFLOG */
    (void) sprintf (d02global.common_config, "%s/conf/Common.xml", d02global.directory);
    (void) sprintf (d02global.config, "%s/conf/%s.xml", d02global.directory, MY_NAME);
#ifndef SDFLOG_SPLIT
	(void) sprintf(buff, "%s.%s", MY_NAME, instance);
	strcpy(logDirectory, d02global.directory);
	strcat(logDirectory, "/log");
	SDF_log_init(buff, logDirectory);
#else
	strcpy(logDirectory, d02global.directory);
	strcat(logDirectory, "/tmp");
	SDF_log_init("initlog", logDirectory, 0);
#endif

    /* validate name */
    if (config_load_cold () != 0)
        return -1;
    
    return 0;
}


static void
copyright ()
{
   (void) printf ("%s version %s\nCopyright (C) 2014, \nTORO, MIMO Tech Co., Ltd.\n", MY_NAME, MY_VERSION);
   (void) fflush (stdout);
}


static void
usage (FILE *ofp)
{
    (void)fprintf(ofp, "usage: %s <instance> <command>\n", MY_NAME);
    (void)fprintf(ofp, "command:\n");
    (void)fprintf(ofp, "start      - start the application\n");
    (void)fprintf(ofp, "stop       - stop the application\n");
    (void)fprintf(ofp, "reload     - reload configuration\n");
    (void)fprintf(ofp, "pause      - temporary stop the application\n");
    (void)fprintf(ofp, "resume     - continue the application\n");
    (void)fprintf(ofp, "status     - print process status\n");
#ifdef STAT_RESET
    (void)fprintf(ofp, "clearstats - clear internal statistics\n");
#endif
    (void)fflush(ofp);
}


int
main (int argc, char **argv)
{
    copyright ();
    uid_t uid;
    struct passwd *pwd;

    uid = getuid();
    pwd = getpwuid(uid);
    printf("Real user = %ld (%s)\n", (long)uid, pwd->pw_name);

    /*   if(strcmp(pwd->pw_name,"toro")!=0){
     printf("Please start with toro user!\n");
     return EXIT_FAILURE;
     }*/

    if (argc == 1)
    {
        usage (stdout);
        return 0;
    }
    if (argc > 1)
    {
        if (init_name (argv[0],argv[1]) != 0)
            return -1;
    }

    if (argc == 3)
    {
        if (strcmp (argv[2], "start") == 0)
        {
            if (cmd_start () != 0)
                return -1;
            return 0;
        }
        else if (strcmp (argv[2], "stop") == 0)
        {
            if (cmd_stop () != 0)
                return -1;
            return 0;
        }
        else if (strcmp (argv[2], "reload") == 0)
        {
            if (cmd_reload () != 0)
                return -1;
            return 0;
        }
        else if (strcmp (argv[2], "pause") == 0)
        {
            if (cmd_pause (1) != 0)
                return -1;
            return 0;
        }
        else if (strcmp (argv[2], "resume") == 0)
        {
            if (cmd_pause (0) != 0)
                return -1;
            return 0;
        }
        else if (strcmp (argv[2], "status") == 0)
        {
            if (cmd_status () != 0)
                return -1;
            return 0;
        }
#ifdef STAT_RESET
        else if (strcmp(argv[2], "clearstats") == 0) {
            if (cmd_clearstats() != 0)
                return -1;
            return 0;
        }
#endif
    }
    
    (void) fprintf (stderr, "Invalid argrument!\n");
    usage (stderr);
    return -1;
}

